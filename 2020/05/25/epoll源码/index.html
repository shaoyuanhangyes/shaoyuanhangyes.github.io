<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="epoll源码(注释版)">
<meta property="og:type" content="article">
<meta property="og:title" content="epoll源码">
<meta property="og:url" content="http://example.com/2020/05/25/epoll%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="shaoyuanhangyes">
<meta property="og:description" content="epoll源码(注释版)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-25T07:57:00.000Z">
<meta property="article:modified_time" content="2020-09-09T07:19:48.219Z">
<meta property="article:author" content="syh">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/05/25/epoll%E6%BA%90%E7%A0%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>epoll源码 | shaoyuanhangyes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shaoyuanhangyes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">shaoyuanhangyes@outlook.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">53</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/shaoyuanhangyes" class="github-corner" title="Ruojhen_syh" aria-label="Ruojhen_syh" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/25/epoll%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="syh">
      <meta itemprop="description" content="Algorithm & Open source by Ruojhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shaoyuanhangyes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          epoll源码
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 15:57:00" itemprop="dateCreated datePublished" datetime="2020-05-25T15:57:00+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-09 15:19:48" itemprop="dateModified" datetime="2020-09-09T15:19:48+08:00">2020-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="epoll源码-注释版"><a href="#epoll源码-注释版" class="headerlink" title="epoll源码(注释版)"></a>epoll源码(注释版)</h2><span id="more"></span> 
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  fs/eventpoll.c (Efficient event retrieval implementation)</span></span><br><span class="line"><span class="comment"> *  Copyright (C) 2001,...,2009  Davide Libenzi</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> *  it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment"> *  (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Davide Libenzi &lt;davidel@xmailserver.org&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在深入了解epoll的实现之前, 先来了解内核的3个方面.</span></span><br><span class="line"><span class="comment"> * 1. 等待队列 waitqueue</span></span><br><span class="line"><span class="comment"> * 我们简单解释一下等待队列:</span></span><br><span class="line"><span class="comment"> * 队列头(wait_queue_head_t)往往是资源生产者,</span></span><br><span class="line"><span class="comment"> * 队列成员(wait_queue_t)往往是资源消费者,</span></span><br><span class="line"><span class="comment"> * 当头的资源ready后, 会逐个执行每个成员指定的回调函数,</span></span><br><span class="line"><span class="comment"> * 来通知它们资源已经ready了, 等待队列大致就这个意思.</span></span><br><span class="line"><span class="comment"> * 2. 内核的poll机制</span></span><br><span class="line"><span class="comment"> * 被Poll的fd, 必须在实现上支持内核的Poll技术,</span></span><br><span class="line"><span class="comment"> * 比如fd是某个字符设备,或者是个socket, 它必须实现</span></span><br><span class="line"><span class="comment"> * file_operations中的poll操作, 给自己分配有一个等待队列头.</span></span><br><span class="line"><span class="comment"> * 主动poll fd的某个进程必须分配一个等待队列成员, 添加到</span></span><br><span class="line"><span class="comment"> * fd的对待队列里面去, 并指定资源ready时的回调函数.</span></span><br><span class="line"><span class="comment"> * 用socket做例子, 它必须有实现一个poll操作, 这个Poll是</span></span><br><span class="line"><span class="comment"> * 发起轮询的代码必须主动调用的, 该函数中必须调用poll_wait(),</span></span><br><span class="line"><span class="comment"> * poll_wait会将发起者作为等待队列成员加入到socket的等待队列中去.</span></span><br><span class="line"><span class="comment"> * 这样socket发生状态变化时可以通过队列头逐个通知所有关心它的进程.</span></span><br><span class="line"><span class="comment"> * 这一点必须很清楚的理解, 否则会想不明白epoll是如何</span></span><br><span class="line"><span class="comment"> * 得知fd的状态发生变化的.</span></span><br><span class="line"><span class="comment"> * 3. epollfd本身也是个fd, 所以它本身也可以被epoll,</span></span><br><span class="line"><span class="comment"> * 可以猜测一下它是不是可以无限嵌套epoll下去...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * epoll基本上就是使用了上面的1,2点来完成.</span></span><br><span class="line"><span class="comment"> * 可见epoll本身并没有给内核引入什么特别复杂或者高深的技术,</span></span><br><span class="line"><span class="comment"> * 只不过是已有功能的重新组合, 达到了超过select的效果.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 相关的其它内核知识:</span></span><br><span class="line"><span class="comment"> * 1. fd我们知道是文件描述符, 在内核态, 与之对应的是struct file结构,</span></span><br><span class="line"><span class="comment"> * 可以看作是内核态的文件描述符.</span></span><br><span class="line"><span class="comment"> * 2. spinlock, 自旋锁, 必须要非常小心使用的锁,</span></span><br><span class="line"><span class="comment"> * 尤其是调用spin_lock_irqsave()的时候, 中断关闭, 不会发生进程调度,</span></span><br><span class="line"><span class="comment"> * 被保护的资源其它CPU也无法访问. 这个锁是很强力的, 所以只能锁一些</span></span><br><span class="line"><span class="comment"> * 非常轻量级的操作.</span></span><br><span class="line"><span class="comment"> * 3. 引用计数在内核中是非常重要的概念,</span></span><br><span class="line"><span class="comment"> * 内核代码里面经常有些release, free释放资源的函数几乎不加任何锁,</span></span><br><span class="line"><span class="comment"> * 这是因为这些函数往往是在对象的引用计数变成0时被调用,</span></span><br><span class="line"><span class="comment"> * 既然没有进程在使用在这些对象, 自然也不需要加锁.</span></span><br><span class="line"><span class="comment"> * struct file 是持有引用计数的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* --- epoll相关的数据结构 --- */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span></span><br><span class="line"><span class="comment"> * structure and rapresent the main data sructure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 每创建一个epollfd, 内核就会分配一个eventpoll与之对应, 可以说是</span></span><br><span class="line"><span class="comment"> * 内核态的epollfd. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> &#123;</span><br><span class="line">    <span class="comment">/* Protect the this structure access */</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">     * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">     * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">     * code and the ctl operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 添加, 修改或者删除监听fd的时候, 以及epoll_wait返回, 向用户空间</span></span><br><span class="line"><span class="comment">     * 传递数据时都会持有这个互斥锁, 所以在用户空间可以放心的在多个线程</span></span><br><span class="line"><span class="comment">     * 中同时执行epoll相关的操作, 内核级已经做了保护. */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mutex</span> mtx;</span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="comment">/* 调用epoll_wait()时, 我们就是&quot;睡&quot;在了这个等待队列上... */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wq;</span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="comment">/* 这个用于epollfd本事被poll的时候... */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="comment">/* 所有已经ready的epitem都在这个链表里面 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllist;</span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="comment">/* 所有要监听的epitem都在这里 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这是一个单链表链接着所有的struct epitem当event转移到用户空间时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">     * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *ovflist;</span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">    <span class="comment">/* 这里保存了一些用户变量, 比如fd监听数量的最大值等等 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* epitem 表示一个被监听的fd */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line">    <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">    <span class="comment">/* rb_node, 当使用epoll_ctl()将一批fds加入到某个epollfd时, 内核会分配</span></span><br><span class="line"><span class="comment">     * 一批的epitem与fds们对应, 而且它们以rb_tree的形式组织起来, tree的root</span></span><br><span class="line"><span class="comment">     * 保存在epollfd, 也就是struct eventpoll中.</span></span><br><span class="line"><span class="comment">     * 在这里使用rb_tree的原因我认为是提高查找,插入以及删除的速度.</span></span><br><span class="line"><span class="comment">     * rb_tree对以上3个操作都具有O(lgN)的时间复杂度 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;</span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="comment">/* 链表节点, 所有已经ready的epitem都会被链到eventpoll的rdllist中 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">     * single linked chain of items.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 这个在代码中再解释... */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *next;</span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="comment">/* epitem对应的fd和struct file */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;</span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">    <span class="type">int</span> nwait;</span><br><span class="line">    <span class="comment">/* List containing poll wait queues */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist;</span><br><span class="line">    <span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line">    <span class="comment">/* 当前epitem属于哪个eventpoll */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> fllink;</span><br><span class="line">    <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="comment">/* 当前的epitem关系哪些events, 这个数据是调用epoll_ctl时从用户态传递过来 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *file;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* poll所用到的钩子Wait structure used by the poll hooks */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eppoll_entry</span> &#123;</span><br><span class="line">    <span class="comment">/* List header used to link this structure to the &quot;struct epitem&quot; */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> llink;</span><br><span class="line">    <span class="comment">/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *base;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wait queue item that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">     * queue head.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">wait_queue_t</span> wait;</span><br><span class="line">    <span class="comment">/* The wait queue head that linked the &quot;wait&quot; wait queue item */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Wrapper struct used by poll queueing */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ep_pqueue</span> &#123;</span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Used by the ep_send_events() function as callback private data */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ep_send_events_data</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxevents;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> __user *events;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* --- 代码注释 --- */</span></span><br><span class="line"><span class="comment">/* 你没看错, 这就是epoll_create()的真身, 基本啥也不干直接调用epoll_create1了,</span></span><br><span class="line"><span class="comment"> * 另外你也可以发现, size这个参数其实是没有任何用处的... */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE1</span>(epoll_create, <span class="type">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sys_epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这才是真正的epoll_create啊~~ */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE1</span>(epoll_create1, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep = <span class="literal">NULL</span>;<span class="comment">//主描述符</span></span><br><span class="line">    <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">    <span class="comment">/* 这句没啥用处... */</span></span><br><span class="line">    <span class="built_in">BUILD_BUG_ON</span>(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line">    <span class="comment">/* 对于epoll来讲, 目前唯一有效的FLAG就是CLOEXEC */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the internal data structure (&quot;struct eventpoll&quot;).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 分配一个struct eventpoll, 分配和初始化细节我们随后深聊~ */</span></span><br><span class="line">    error = <span class="built_in">ep_alloc</span>(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Creates all the items needed to setup an eventpoll file. That is,</span></span><br><span class="line"><span class="comment">     * a file structure and a free file descriptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 这里是创建一个匿名fd, 说起来就话长了...长话短说:</span></span><br><span class="line"><span class="comment">     * epollfd本身并不存在一个真正的文件与之对应, 所以内核需要创建一个</span></span><br><span class="line"><span class="comment">     * &quot;虚拟&quot;的文件, 并为之分配真正的struct file结构, 而且有真正的fd.</span></span><br><span class="line"><span class="comment">     * 这里2个参数比较关键:</span></span><br><span class="line"><span class="comment">     * eventpoll_fops, fops就是file operations, 就是当你对这个文件(这里是虚拟的)进行操作(比如读)时,</span></span><br><span class="line"><span class="comment">     * fops里面的函数指针指向真正的操作实现, 类似C++里面虚函数和子类的概念.</span></span><br><span class="line"><span class="comment">     * epoll只实现了poll和release(就是close)操作, 其它文件系统操作都有VFS全权处理了.</span></span><br><span class="line"><span class="comment">     * ep, ep就是struct epollevent, 它会作为一个私有数据保存在struct file的private指针里面.</span></span><br><span class="line"><span class="comment">     * 其实说白了, 就是为了能通过fd找到struct file, 通过struct file能找到eventpoll结构.</span></span><br><span class="line"><span class="comment">     * 如果懂一点Linux下字符设备驱动开发, 这里应该是很好理解的,</span></span><br><span class="line"><span class="comment">     * 推荐阅读 &lt;Linux device driver 3rd&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = <span class="built_in">anon_inode_getfd</span>(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">ep_free</span>(ep);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建好epollfd后, 接下来我们要往里面添加fd咯</span></span><br><span class="line"><span class="comment">* 来看epoll_ctl</span></span><br><span class="line"><span class="comment">* epfd 就是epollfd</span></span><br><span class="line"><span class="comment">* op ADD,MOD,DEL</span></span><br><span class="line"><span class="comment">* fd 需要监听的描述符</span></span><br><span class="line"><span class="comment">* event 我们关心的events</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE4</span>(epoll_ctl, <span class="type">int</span>, epfd, <span class="type">int</span>, op, <span class="type">int</span>, fd,</span><br><span class="line">        <span class="keyword">struct</span> epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *file, *tfile;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epds;</span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 错误处理以及从用户空间将epoll_event结构copy到内核空间.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ep_op_has_event</span>(op) &amp;&amp;</span><br><span class="line">        <span class="built_in">copy_from_user</span>(&amp;epds, event, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span></span><br><span class="line">    <span class="comment">/* 取得struct file结构, epfd既然是真正的fd, 那么内核空间</span></span><br><span class="line"><span class="comment">     * 就会有与之对于的一个struct file结构</span></span><br><span class="line"><span class="comment">     * 这个结构在epoll_create1()中, 由函数anon_inode_getfd()分配 */</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = <span class="built_in">fget</span>(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the target file */</span></span><br><span class="line">    <span class="comment">/* 我们需要监听的fd, 它当然也有个struct file结构, 上下2个不要搞混了哦 */</span></span><br><span class="line">    tfile = <span class="built_in">fget</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> (!tfile)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line">    <span class="comment">/* The target file descriptor must support poll */</span></span><br><span class="line">    error = -EPERM;</span><br><span class="line">    <span class="comment">/* 如果监听的文件不支持poll, 那就没辙了.</span></span><br><span class="line"><span class="comment">     * 你知道什么情况下, 文件会不支持poll吗?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check that the file structure underneath the file descriptor</span></span><br><span class="line"><span class="comment">     * the user passed to us _is_ an eventpoll file. And also we do not permit</span></span><br><span class="line"><span class="comment">     * adding an epoll file descriptor inside itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="comment">/* epoll不能自己监听自己... */</span></span><br><span class="line">    <span class="keyword">if</span> (file == tfile || !<span class="built_in">is_file_epoll</span>(file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 取到我们的eventpoll结构, 来自与epoll_create1()中的分配 */</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    <span class="comment">/* 接下来的操作有可能修改数据结构内容, 锁之~ */</span></span><br><span class="line">    <span class="built_in">mutex_lock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to lookup the file inside our RB tree, Since we grabbed &quot;mtx&quot;</span></span><br><span class="line"><span class="comment">     * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="comment">     * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 对于每一个监听的fd, 内核都有分配一个epitem结构,</span></span><br><span class="line"><span class="comment">     * 而且我们也知道, epoll是不允许重复添加fd的,</span></span><br><span class="line"><span class="comment">     * 所以我们首先查找该fd是不是已经存在了.</span></span><br><span class="line"><span class="comment">     * ep_find()其实就是RBTREE查找, 跟C++STL的map差不多一回事, O(lgn)的时间复杂度.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    epi = <span class="built_in">ep_find</span>(ep, tfile, fd);</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="comment">/* 首先我们关心添加 */</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">            <span class="comment">/* 之前的find没有找到有效的epitem, 证明是第一次插入, 接受!</span></span><br><span class="line"><span class="comment">             * 这里我们可以知道, POLLERR和POLLHUP事件内核总是会关心的</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            <span class="comment">/* rbtree插入, 详情见ep_insert()的分析</span></span><br><span class="line"><span class="comment">             * 其实我觉得这里有insert的话, 之前的find应该</span></span><br><span class="line"><span class="comment">             * 是可以省掉的... */</span></span><br><span class="line">            error = <span class="built_in">ep_insert</span>(ep, &amp;epds, tfile, fd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* 找到了!? 重复添加! */</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 删除和修改操作都比较简单 */</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="keyword">if</span> (epi)</span><br><span class="line">            error = <span class="built_in">ep_remove</span>(ep, epi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = <span class="built_in">ep_modify</span>(ep, epi, &amp;epds);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">error_tgt_fput:</span><br><span class="line">    <span class="built_in">fput</span>(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">    <span class="built_in">fput</span>(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 分配一个eventpoll结构 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_alloc</span><span class="params">(<span class="keyword">struct</span> eventpoll **pep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="comment">/* 获取当前用户的一些信息, 比如是不是root啦, 最大监听fd数目啦 */</span></span><br><span class="line">    user = <span class="built_in">get_current_user</span>();</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    ep = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*ep), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(!ep))</span><br><span class="line">        <span class="keyword">goto</span> free_uid;</span><br><span class="line">    <span class="comment">/* 这些都是初始化啦 */</span></span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;ep-&gt;lock);</span><br><span class="line">    <span class="built_in">mutex_init</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;ep-&gt;wq);<span class="comment">//初始化自己睡在的等待队列</span></span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;ep-&gt;poll_wait);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;ep-&gt;rdllist);<span class="comment">//初始化就绪链表</span></span><br><span class="line">    ep-&gt;rbr = RB_ROOT;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    ep-&gt;user = user;</span><br><span class="line">    *pep = ep;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">free_uid:</span><br><span class="line">    <span class="built_in">free_uid</span>(user);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ep_insert()在epoll_ctl()中被调用, 完成往epollfd里面添加一个监听fd的工作</span></span><br><span class="line"><span class="comment"> * tfile是fd在内核态的struct file结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_insert</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event *event,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">struct</span> file *tfile, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error, revents, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ep_pqueue</span> epq;</span><br><span class="line">    <span class="comment">/* 查看是否达到当前用户的最大监听数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">atomic_read</span>(&amp;ep-&gt;user-&gt;epoll_watches) &gt;=</span><br><span class="line">             max_user_watches))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    <span class="comment">/* 从著名的slab中分配一个epitem */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_***_alloc(epi_***, GFP_KERNEL)))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">/* Item initialization follow here ... */</span></span><br><span class="line">    <span class="comment">/* 这些都是相关成员的初始化... */</span></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;epi-&gt;rdllink);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;epi-&gt;fllink);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    <span class="comment">/* 这里保存了我们需要监听的文件fd和它的file结构 */</span></span><br><span class="line">    <span class="built_in">ep_set_ffd</span>(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 这个指针的初值不是NULL哦... */</span></span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="comment">/* Initialize the poll table using the queue callback */</span></span><br><span class="line">    <span class="comment">/* 好, 我们终于要进入到poll的正题了 */</span></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    <span class="comment">/* 初始化一个poll_table</span></span><br><span class="line"><span class="comment">     * 其实就是指定调用poll_wait(注意不是epoll_wait!!!)时的回调函数,和我们关心哪些events,</span></span><br><span class="line"><span class="comment">     * ep_ptable_queue_proc()就是我们的回调啦, 初值是所有event都关心 */</span></span><br><span class="line">    <span class="built_in">init_poll_funcptr</span>(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attach the item to the poll hooks and get current event bits.</span></span><br><span class="line"><span class="comment">     * We can safely use the file* here because its usage count has</span></span><br><span class="line"><span class="comment">     * been increased by the caller of this function. Note that after</span></span><br><span class="line"><span class="comment">     * this operation completes, the poll callback can start hitting</span></span><br><span class="line"><span class="comment">     * the new item.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 这一部很关键, 也比较难懂, 完全是内核的poll机制导致的...</span></span><br><span class="line"><span class="comment">     * 首先, f_op-&gt;poll()一般来说只是个wrapper, 它会调用真正的poll实现,</span></span><br><span class="line"><span class="comment">     * 拿UDP的socket来举例, 这里就是这样的调用流程: f_op-&gt;poll(), sock_poll(),</span></span><br><span class="line"><span class="comment">     * udp_poll(), datagram_poll(), sock_poll_wait(), 最后调用到我们上面指定的</span></span><br><span class="line"><span class="comment">     * ep_ptable_queue_proc()这个回调函数...(好深的调用路径...).</span></span><br><span class="line"><span class="comment">     * 完成这一步, 我们的epitem就跟这个socket关联起来了, 当它有状态变化时,</span></span><br><span class="line"><span class="comment">     * 会通过ep_poll_callback()来通知.</span></span><br><span class="line"><span class="comment">     * 最后, 这个函数还会查询当前的fd是不是已经有啥event已经ready了, 有的话</span></span><br><span class="line"><span class="comment">     * 会将event返回. */</span></span><br><span class="line">    revents = tfile-&gt;f_op-&gt;<span class="built_in">poll</span>(tfile, &amp;epq.pt);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check if something went wrong during the poll wait queue</span></span><br><span class="line"><span class="comment">     * install process. Namely an allocation for a wait queue failed due</span></span><br><span class="line"><span class="comment">     * high memory pressure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error_unregister;</span><br><span class="line">    <span class="comment">/* Add the current item to the list of active epoll hook for this file */</span></span><br><span class="line">    <span class="comment">/* 这个就是每个文件会将所有监听自己的epitem链起来 */</span></span><br><span class="line">    <span class="built_in">spin_lock</span>(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="built_in">list_add_tail</span>(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    <span class="built_in">spin_unlock</span>(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Add the current item to the RB tree. All RB tree operations are</span></span><br><span class="line"><span class="comment">     * protected by &quot;mtx&quot;, and ep_insert() is called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 都搞定后, 将epitem插入到对应的eventpoll中去 */</span></span><br><span class="line">    <span class="built_in">ep_rbtree_insert</span>(ep, epi);</span><br><span class="line">    <span class="comment">/* We have to drop the new item inside our item list to keep track of it */</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span></span><br><span class="line">    <span class="comment">/* 到达这里后, 如果我们监听的fd已经有事件发生, 那就要处理一下 */</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        <span class="comment">/* 将当前的epitem加入到ready list中去 */</span></span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        <span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">        <span class="comment">/* 谁在epoll_wait, 就唤醒它... */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">            <span class="built_in">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="comment">/* 谁在epoll当前的epollfd, 也唤醒它... */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="built_in">atomic_inc</span>(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error_unregister:</span><br><span class="line">    <span class="built_in">ep_unregister_pollwait</span>(ep, epi);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to do this because an event could have been arrived on some</span></span><br><span class="line"><span class="comment">     * allocated wait queue. Note that we don&#x27;t care about the ep-&gt;ovflist</span></span><br><span class="line"><span class="comment">     * list, since that is used/cleaned only inside a section bound by &quot;mtx&quot;.</span></span><br><span class="line"><span class="comment">     * And ep_insert() is called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink))</span><br><span class="line">        <span class="built_in">list_del_init</span>(&amp;epi-&gt;rdllink);</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    kmem_***_free(epi_***, epi);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="comment"> * target file wakeup lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数在调用f_op-&gt;poll()时会被调用.</span></span><br><span class="line"><span class="comment"> * 也就是epoll主动poll某个fd时, 用来将epitem与指定的fd关联起来的.</span></span><br><span class="line"><span class="comment"> * 关联的办法就是使用等待队列(waitqueue)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="params"><span class="function">                 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi = <span class="built_in">ep_item_from_epqueue</span>(pt);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eppoll_entry</span> *pwq;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_***_alloc(pwq_***, GFP_KERNEL))) &#123;</span><br><span class="line">        <span class="comment">/* 初始化等待队列, 指定ep_poll_callback为唤醒时的回调函数,</span></span><br><span class="line"><span class="comment">         * 当我们监听的fd发生状态改变时, 也就是队列头被唤醒时,</span></span><br><span class="line"><span class="comment">         * 指定的回调函数将会被调用. */</span></span><br><span class="line">        <span class="built_in">init_waitqueue_func_entry</span>(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        <span class="comment">/* 将刚分配的等待队列成员加入到头中, 头是由fd持有的 */</span></span><br><span class="line">        <span class="built_in">add_wait_queue</span>(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        <span class="comment">/* nwait记录了当前epitem加入到了多少个等待队列中,</span></span><br><span class="line"><span class="comment">         * 我认为这个值最大也只会是1... */</span></span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is passed to the wait queue wakeup</span></span><br><span class="line"><span class="comment"> * machanism. It is called by the stored file descriptors when they</span></span><br><span class="line"><span class="comment"> * have events to report.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个是关键性的回调函数, 当我们监听的fd发生状态改变时, 它会被调用.</span></span><br><span class="line"><span class="comment"> * 参数key被当作一个unsigned long整数使用, 携带的是events.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="type">wait_queue_t</span> *wait, <span class="type">unsigned</span> mode, <span class="type">int</span> sync, <span class="type">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi = <span class="built_in">ep_item_from_wait</span>(wait);<span class="comment">//从等待队列获取epitem.需要知道哪个进程挂载到这个设备</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep = epi-&gt;ep;<span class="comment">//获取</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If the event mask does not contain any poll(2) event, we consider the</span></span><br><span class="line"><span class="comment">     * descriptor to be disabled. This condition is likely the effect of the</span></span><br><span class="line"><span class="comment">     * EPOLLONESHOT bit that disables the descriptor when an event is received,</span></span><br><span class="line"><span class="comment">     * until the next EPOLL_CTL_MOD will be issued.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check the events coming with the callback. At this stage, not</span></span><br><span class="line"><span class="comment">     * every device reports the events in the &quot;key&quot; parameter of the</span></span><br><span class="line"><span class="comment">     * callback. We need to be able to handle both cases here, hence the</span></span><br><span class="line"><span class="comment">     * test for &quot;key&quot; != NULL before the event match test.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 没有我们关心的event... */</span></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !((<span class="type">unsigned</span> <span class="type">long</span>) key &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we are trasfering events to userspace, we can hold no locks</span></span><br><span class="line"><span class="comment">     * (because we&#x27;re accessing user memory, and because of linux f_op-&gt;poll()</span></span><br><span class="line"><span class="comment">     * semantics). All the events that happens during that period of time are</span></span><br><span class="line"><span class="comment">     * chained in ep-&gt;ovflist and requeued later on.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里看起来可能有点费解, 其实干的事情比较简单:</span></span><br><span class="line"><span class="comment">     * 如果该callback被调用的同时, epoll_wait()已经返回了,</span></span><br><span class="line"><span class="comment">     * 也就是说, 此刻应用程序有可能已经在循环获取events,</span></span><br><span class="line"><span class="comment">     * 这种情况下, 内核将此刻发生event的epitem用一个单独的链表</span></span><br><span class="line"><span class="comment">     * 链起来, 不发给应用程序, 也不丢弃, 而是在下一次epoll_wait</span></span><br><span class="line"><span class="comment">     * 时返回给用户.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">            epi-&gt;next = ep-&gt;ovflist;</span><br><span class="line">            ep-&gt;ovflist = epi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If this file is already in the ready list we exit soon */</span></span><br><span class="line">    <span class="comment">/* 将当前的epitem放入ready list */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink))</span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="comment">     * wait list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 唤醒epoll_wait... */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">        <span class="built_in">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="comment">/* 如果epollfd也在被poll, 那就唤醒队列里面的所有成员. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line">out_unlock:</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Implement the event wait interface for the eventpoll file. It is the kernel</span></span><br><span class="line"><span class="comment"> * part of the user space epoll_wait(2).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE4</span>(epoll_wait, <span class="type">int</span>, epfd, <span class="keyword">struct</span> epoll_event __user *, events,</span><br><span class="line">        <span class="type">int</span>, maxevents, <span class="type">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *file;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="comment">/* The maximum number of event must be greater than zero */</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* Verify that the area passed by the user is writeable */</span></span><br><span class="line">    <span class="comment">/* 这个地方有必要说明一下:</span></span><br><span class="line"><span class="comment">     * 内核对应用程序采取的策略是&quot;绝对不信任&quot;,</span></span><br><span class="line"><span class="comment">     * 所以内核跟应用程序之间的数据交互大都是copy, 不允许(也时候也是不能...)指针引用.</span></span><br><span class="line"><span class="comment">     * epoll_wait()需要内核返回数据给用户空间, 内存由用户程序提供,</span></span><br><span class="line"><span class="comment">     * 所以内核会用一些手段来验证这一段内存空间是不是有效的.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access_ok</span>(VERIFY_WRITE, events, maxevents * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    <span class="comment">/* 获取epollfd的struct file, epollfd也是文件嘛 */</span></span><br><span class="line">    file = <span class="built_in">fget</span>(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check that the file structure underneath the fd</span></span><br><span class="line"><span class="comment">     * the user passed to us _is_ an eventpoll file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="comment">/* 检查一下它是不是一个真正的epollfd... */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_file_epoll</span>(file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 获取eventpoll结构 */</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    <span class="comment">/* Time to fish for events ... */</span></span><br><span class="line">    <span class="comment">/* OK, 睡觉, 等待事件到来~~ */</span></span><br><span class="line">    error = <span class="built_in">ep_poll</span>(ep, events, maxevents, timeout);</span><br><span class="line">error_fput:</span><br><span class="line">    <span class="built_in">fput</span>(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个函数真正将执行epoll_wait的进程带入睡眠状态... */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_poll</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event __user *events,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span> maxevents, <span class="type">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res, eavail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">long</span> jtimeout;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait;<span class="comment">//等待队列</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Calculate the timeout by checking for the &quot;infinite&quot; value (-1)</span></span><br><span class="line"><span class="comment">     * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment">     * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 计算睡觉时间, 毫秒要转换为HZ */</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line">retry:</span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 如果ready list不为空, 就不睡了, 直接干活... */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We don&#x27;t have any available event to return to the caller.</span></span><br><span class="line"><span class="comment">         * We need to sleep here, and we will be wake up by</span></span><br><span class="line"><span class="comment">         * ep_poll_callback() when events will become available.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* OK, 初始化一个等待队列, 准备直接把自己挂起,</span></span><br><span class="line"><span class="comment">         * 注意current是一个宏, 代表当前进程 */</span></span><br><span class="line">        <span class="built_in">init_waitqueue_entry</span>(&amp;wait, current);<span class="comment">//初始化等待队列,wait表示当前进程</span></span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);<span class="comment">//挂载到ep结构的等待队列</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We don&#x27;t want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">             * a wakeup in between. That&#x27;s why we set the task state</span></span><br><span class="line"><span class="comment">             * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">/* 将当前进程设置位睡眠, 但是可以被信号唤醒的状态,</span></span><br><span class="line"><span class="comment">             * 注意这个设置是&quot;将来时&quot;, 我们此刻还没睡! */</span></span><br><span class="line">            <span class="built_in">set_current_state</span>(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="comment">/* 如果这个时候, ready list里面有成员了,</span></span><br><span class="line"><span class="comment">             * 或者睡眠时间已经过了, 就直接不睡了... */</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* 如果有信号产生, 也起床... */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">signal_pending</span>(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 啥事都没有,解锁, 睡觉... */</span></span><br><span class="line">            <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/* jtimeout这个时间后, 会被唤醒,</span></span><br><span class="line"><span class="comment">             * ep_poll_callback()如果此时被调用,</span></span><br><span class="line"><span class="comment">             * 那么我们就会直接被唤醒, 不用等时间了...</span></span><br><span class="line"><span class="comment">             * 再次强调一下ep_poll_callback()的调用时机是由被监听的fd</span></span><br><span class="line"><span class="comment">             * 的具体实现, 比如socket或者某个设备驱动来决定的,</span></span><br><span class="line"><span class="comment">             * 因为等待队列头是他们持有的, epoll和当前进程</span></span><br><span class="line"><span class="comment">             * 只是单纯的等待...</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">            jtimeout = <span class="built_in">schedule_timeout</span>(jtimeout);<span class="comment">//睡觉</span></span><br><span class="line">            <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        <span class="comment">/* OK 我们醒来了... */</span></span><br><span class="line">        <span class="built_in">set_current_state</span>(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Is it worth to try to dig for events ? */</span></span><br><span class="line">    eavail = !<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="comment">     * there&#x27;s still timeout left over, we go trying again in search of</span></span><br><span class="line"><span class="comment">     * more luck.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 如果一切正常, 有event发生, 就开始准备数据copy给用户空间了... */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = <span class="built_in">ep_send_events</span>(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个简单, 我们直奔下一个... */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_send_events</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">struct</span> epoll_event __user *events, <span class="type">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ep_send_events_data</span> esed;</span><br><span class="line">    esed.maxevents = maxevents;</span><br><span class="line">    esed.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ep_scan_ready_list</span>(ep, ep_send_events_proc, &amp;esed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for</span></span><br><span class="line"><span class="comment"> *                      the scan code, to call f_op-&gt;poll(). Also allows for</span></span><br><span class="line"><span class="comment"> *                      O(NumReady) performance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @ep: Pointer to the epoll private data structure.</span></span><br><span class="line"><span class="comment"> * @sproc: Pointer to the scan callback.</span></span><br><span class="line"><span class="comment"> * @priv: Private opaque data passed to the @sproc callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: The same integer error code returned by the @sproc callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> (*sproc)(<span class="keyword">struct</span> eventpoll *,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">struct</span> list_head *, <span class="type">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi, *nepi;</span><br><span class="line">    <span class="built_in">LIST_HEAD</span>(txlist);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">     * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">mutex_lock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Steal the ready list, and re-init the original one to the</span></span><br><span class="line"><span class="comment">     * empty list. Also, set ep-&gt;ovflist to NULL so that events</span></span><br><span class="line"><span class="comment">     * happening while looping w/out locks, are not lost. We cannot</span></span><br><span class="line"><span class="comment">     * have the poll callback to queue directly on ep-&gt;rdllist,</span></span><br><span class="line"><span class="comment">     * because we want the &quot;sproc&quot; callback to be able to do it</span></span><br><span class="line"><span class="comment">     * in a lockless way.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* 这一步要注意, 首先, 所有监听到events的epitem都链到rdllist上了,</span></span><br><span class="line"><span class="comment">     * 但是这一步之后, 所有的epitem都转移到了txlist上, 而rdllist被清空了,</span></span><br><span class="line"><span class="comment">     * 要注意哦, rdllist已经被清空了! */</span></span><br><span class="line">    <span class="built_in">list_splice_init</span>(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    <span class="comment">/* ovflist, 在ep_poll_callback()里面我解释过, 此时此刻我们不希望</span></span><br><span class="line"><span class="comment">     * 有新的event加入到ready list中了, 保存后下次再处理... */</span></span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now call the callback function.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 在这个回调函数里面处理每个epitem</span></span><br><span class="line"><span class="comment">     * sproc 就是 ep_send_events_proc, 下面会注释到. */</span></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * During the time we spent inside the &quot;sproc&quot; callback, some</span></span><br><span class="line"><span class="comment">     * other events might have been queued by the poll callback.</span></span><br><span class="line"><span class="comment">     * We re-insert them inside the main ready-list here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 现在我们来处理ovflist, 这些epitem都是我们在传递数据给用户空间时</span></span><br><span class="line"><span class="comment">     * 监听到了事件. */</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We need to check if the item is already in the list.</span></span><br><span class="line"><span class="comment">         * During the &quot;sproc&quot; callback execution time, items are</span></span><br><span class="line"><span class="comment">         * queued into -&gt;ovflist but the &quot;txlist&quot; might already</span></span><br><span class="line"><span class="comment">         * contain them, and the list_splice() below takes care of them.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* 将这些直接放入readylist */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink))</span><br><span class="line">            <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span></span><br><span class="line"><span class="comment">     * releasing the lock, events will be queued in the normal way inside</span></span><br><span class="line"><span class="comment">     * ep-&gt;rdllist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Quickly re-inject items left on &quot;txlist&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 上一次没有处理完的epitem, 重新插入到ready list */</span></span><br><span class="line">    <span class="built_in">list_splice</span>(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line">    <span class="comment">/* ready list不为空, 直接唤醒... */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="comment">         * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">            <span class="built_in">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 该函数作为callbakc在ep_scan_ready_list()中被调用</span></span><br><span class="line"><span class="comment"> * head是一个链表, 包含了已经ready的epitem,</span></span><br><span class="line"><span class="comment"> * 这个不是eventpoll里面的ready list, 而是上面函数中的txlist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_send_events_proc</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ep_send_events_data</span> *esed = priv;</span><br><span class="line">    <span class="type">int</span> eventcnt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> revents;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> __user *uevent;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can loop without lock because we are passed a task private list.</span></span><br><span class="line"><span class="comment">     * Items cannot vanish during the loop because ep_scan_ready_list() is</span></span><br><span class="line"><span class="comment">     * holding &quot;mtx&quot; during this call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 扫描整个链表... */</span></span><br><span class="line">    <span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">         !<span class="built_in">list_empty</span>(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;</span><br><span class="line">        <span class="comment">/* 取出第一个成员 */</span></span><br><span class="line">        epi = <span class="built_in">list_first_entry</span>(head, <span class="keyword">struct</span> epitem, rdllink);</span><br><span class="line">        <span class="comment">/* 然后从链表里面移除 */</span></span><br><span class="line">        <span class="built_in">list_del_init</span>(&amp;epi-&gt;rdllink);</span><br><span class="line">        <span class="comment">/* 读取events,</span></span><br><span class="line"><span class="comment">         * 注意events我们ep_poll_callback()里面已经取过一次了, 为啥还要再取?</span></span><br><span class="line"><span class="comment">         * 1. 我们当然希望能拿到此刻的最新数据, events是会变的~</span></span><br><span class="line"><span class="comment">         * 2. 不是所有的poll实现, 都通过等待队列传递了events, 有可能某些驱动压根没传</span></span><br><span class="line"><span class="comment">         * 必须主动去读取. */</span></span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;<span class="built_in">poll</span>(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp;</span><br><span class="line">            epi-&gt;event.events;</span><br><span class="line">        <span class="keyword">if</span> (revents) &#123;</span><br><span class="line">            <span class="comment">/* 将当前的事件和用户传入的数据都copy给用户空间,</span></span><br><span class="line"><span class="comment">             * 就是epoll_wait()后应用程序能读到的那一堆数据. */</span></span><br><span class="line">            <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">                <span class="built_in">list_add</span>(&amp;epi-&gt;rdllink, head);</span><br><span class="line">                <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            eventcnt++;</span><br><span class="line">            uevent++;</span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">                <span class="comment">/* 嘿嘿, EPOLLET和非ET的区别就在这一步之差呀~</span></span><br><span class="line"><span class="comment">                 * 如果是ET, epitem是不会再进入到readly list,</span></span><br><span class="line"><span class="comment">                 * 除非fd再次发生了状态改变, ep_poll_callback被调用.</span></span><br><span class="line"><span class="comment">                 * 如果是非ET, 不管你还有没有有效的事件或者数据,</span></span><br><span class="line"><span class="comment">                 * 都会被重新插入到ready list, 再下一次epoll_wait</span></span><br><span class="line"><span class="comment">                 * 时, 会立即返回, 并通知给用户空间. 当然如果这个</span></span><br><span class="line"><span class="comment">                 * 被监听的fds确实没事件也没数据了, epoll_wait会返回一个0,</span></span><br><span class="line"><span class="comment">                 * 空转一次.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eventcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ep_free在epollfd被close时调用,</span></span><br><span class="line"><span class="comment"> * 释放一些资源而已, 比较简单 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ep_free</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> *rbp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="comment">/* We need to release all tasks waiting for these file */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">     * eventpoll_release_file() while we&#x27;re freeing the &quot;struct eventpoll&quot;.</span></span><br><span class="line"><span class="comment">     * We do not need to hold &quot;ep-&gt;mtx&quot; here because the epoll file</span></span><br><span class="line"><span class="comment">     * is on the way to be removed and no one has references to it</span></span><br><span class="line"><span class="comment">     * anymore. The only hit might come from eventpoll_release_file() but</span></span><br><span class="line"><span class="comment">     * holding &quot;epmutex&quot; is sufficent here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">mutex_lock</span>(&amp;epmutex);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walks through the whole tree by unregistering poll callbacks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (rbp = <span class="built_in">rb_first</span>(&amp;ep-&gt;rbr); rbp; rbp = <span class="built_in">rb_next</span>(rbp)) &#123;</span><br><span class="line">        epi = <span class="built_in">rb_entry</span>(rbp, <span class="keyword">struct</span> epitem, rbn);</span><br><span class="line">        <span class="built_in">ep_unregister_pollwait</span>(ep, epi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walks through the whole tree by freeing each &quot;struct epitem&quot;. At this</span></span><br><span class="line"><span class="comment">     * point we are sure no poll callbacks will be lingering around, and also by</span></span><br><span class="line"><span class="comment">     * holding &quot;epmutex&quot; we can be sure that no file cleanup code will hit</span></span><br><span class="line"><span class="comment">     * us during this operation. So we can avoid the lock on &quot;ep-&gt;lock&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 之所以在关闭epollfd之前不需要调用epoll_ctl移除已经添加的fd,</span></span><br><span class="line"><span class="comment">     * 是因为这里已经做了... */</span></span><br><span class="line">    <span class="keyword">while</span> ((rbp = <span class="built_in">rb_first</span>(&amp;ep-&gt;rbr)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        epi = <span class="built_in">rb_entry</span>(rbp, <span class="keyword">struct</span> epitem, rbn);</span><br><span class="line">        <span class="built_in">ep_remove</span>(ep, epi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;epmutex);</span><br><span class="line">    <span class="built_in">mutex_destroy</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="built_in">free_uid</span>(ep-&gt;user);</span><br><span class="line">    <span class="built_in">kfree</span>(ep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* File callbacks that implement the eventpoll file behaviour */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> eventpoll_fops = &#123;</span><br><span class="line">    .release    = ep_eventpoll_release,</span><br><span class="line">    .poll       = ep_eventpoll_poll</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Fast test to see if the file is an evenpoll file */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">is_file_epoll</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f-&gt;f_op == &amp;eventpoll_fops;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* OK, eventpoll我认为比较重要的函数都注释完了... */</span></span><br></pre></td></tr></table></figure>
<h3 id="epoll介绍"><a href="#epoll介绍" class="headerlink" title="epoll介绍"></a>epoll介绍</h3><p>epoll是一种I&#x2F;O事件通知机制 是linux内核实现I&#x2F;O多路复用的一个实现<br>I&#x2F;O多路复用是指在一个操作里同时监听多个输入输出源 在其中一个或多个输入输出源可用的时候返回 然后对其进行读写操作<br>简言之 epoll是一种当文件描述符的内核缓冲区非空的时候发出可读信号来通知 当写缓冲区不满的时候发出可写的信号通知的一种机制</p>
<h4 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h4><h5 id="int-epoll-create-int-size"><a href="#int-epoll-create-int-size" class="headerlink" title="int epoll_create(int size)"></a>int epoll_create(int size)</h5><p>内核产生一个epoll实例数据结构并返回一个文件描述符(fd) 这个描述符就是epoll实例的句柄 后面的两个接口都以它为中心(形参epfd)<br>size表示所要监视文件描述符的最大值 不过后来的linux版本中已经被弃用 同时size不能传0 会抛出 invalid argument的error</p>
<h5 id="int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)"></a>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</h5><p>将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span>&#123;</span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">//指向用户自定义数据</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">//注册的文件描述符</span></span><br><span class="line">    <span class="type">unint32_t</span> u32; <span class="comment">//32bit integer</span></span><br><span class="line">    <span class="type">uint64_t</span> u64; <span class="comment">//64bit integer</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epolll_event</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">//描述epoll事件</span></span><br><span class="line">    <span class="comment">//events域描述一组epoll事件 在epoll_ctl调用中解释为描述符所期望的epoll事件 可多选</span></span><br><span class="line"></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">//上面的union </span></span><br><span class="line">    <span class="comment">//data域是唯一能给出描述符信息的字段 所以在调用epoll_ctl加入一个需要检测的描述符时</span></span><br><span class="line">    <span class="comment">//一定要在data域写入描述符相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于需要监听的文件描述符的集合 epoll_ctl对红黑树进行管理 红黑树中的每个成员由描述符的值和所要监控的文件描述符指向的文件表项的引用等组成</p>
<p>op参数的操作类型有:<br>    1. epoll_ctl_add 向interest list添加一个需要监视的描述符<br>    2. epoll_ctl_del 从interest list中删除一个描述符<br>    3. epoll_ctl_mod 修改interest list中的一个描述符</p>
<p>struct epoll_event结构描述一个文件描述符的epoll行为 在使用epoll_wait()返回处于ready状态的描述符列表</p>
<p>常用epoll事件描述:<br>     epollin 描述符处于可读状态<br>     epollout 描述符处于可写状态<br>     epollpri 由带外数据触发 表示描述符有紧急的数据可读<br>     epollet 将epoll event通知模式设置为edge triggered 设置为边缘触发<br>     epolloneshot 第一次进行通知 之后不再监测 如果还想继续监测 就需要再次把这个socket加入到epoll队列中<br>     epollhup 本端描述符产生一个挂断事件 默认监测事件<br>     epollrdhup 对端描述符产生一个挂断事件<br>     epollerr 描述符产生错误时触发 默认监测事件</p>
<h5 id="int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)"></a>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</h5><p>阻塞等待注册的事件发生 返回事件的数目 并将触发的事件写入events数组中<br>epoll_wait返回值number是不会大于maxevents的 返回的是活跃客户端的数量 并且将这些活跃的客户端信息加入到events<br>events:用来记录被触发的events 大小和maxevents一致<br>maxevents:返回events的最大个数</p>
<p>处于ready状态的那些文件描述符会被复制进ready list中 epoll_wait()用于向用户进程返回ready list<br>events和maxevents两个参数描述一个由用户分配的struct epoll event数组 调用返回时 内核将ready list复制到这个数组中 并将实际复制的个数作为返回值<br>如果ready list比maxevents长就只能复制maxevents个成员</p>
<p>timeout:描述函数调用中阻塞时间上限 单位ms<br>    1. timeout &#x3D; -1 表示调用将一直阻塞 直到有文件描述符进入ready状态或者捕捉到信号才返回<br>    2. timeout &#x3D; 0  用于非阻塞检测是否有描述符处于ready状态 不管结果如何 调用都立即返回<br>    3. timeout &gt; 0  表示调用将最多持续timeout时间 如果期间有检测对象变为ready状态或捕捉到信号则返回 否则直到超时</p>
<h4 id="epoll的两种触发方式"><a href="#epoll的两种触发方式" class="headerlink" title="epoll的两种触发方式"></a>epoll的两种触发方式</h4><p>epoll监控多个文件描述符的I&#x2F;O事件 epoll支持边缘触发(edge trigger ET)和水平触发(level trigger LT) 通过epoll_wait()等待I&#x2F;O事件<br>如果当前没有可用事件就阻塞调用线程</p>
<p>select和poll只支持LT工作模式 epoll的默认工作模式是LT模式</p>
<h5 id="LT水平触发的时机"><a href="#LT水平触发的时机" class="headerlink" title="LT水平触发的时机"></a>LT水平触发的时机</h5><p>对于读操作 只要缓冲区不为空 LT模式返回读就绪<br>对于写操作 只要缓冲区还没满 LT模式返回写就绪<br>当被监控的文件描述符上有可读写事件发生时 epoll_wait()会通知处理程序去读写 如果这次没有把数据一次性全读完(读写缓冲区太小)<br>那么下次调用epoll_wait()时 它还会通知你在上次没读写完的文件描述符上继续读写 若你一直不去读写 它会一直通知你<br>若系统中有大量你不需要读写的文件描述符 而他们每次都返回 会大大降低处理程序检索自己关心的文件描述符的效率</p>
<h5 id="ET边缘触发的时机"><a href="#ET边缘触发的时机" class="headerlink" title="ET边缘触发的时机"></a>ET边缘触发的时机</h5><p>对于读操作<br>    1. 当缓冲区由不可读变为可读的时候(缓冲区由空变为不空的时候)<br>    2. 当有新数据到达的时候(缓冲区中的待读数据变多的时候)<br>    3. 当缓冲区内有数据可读 且应用程序对相应的文件描述符进行epoll_ctl_mod修改epollin事件时</p>
<p>对于写操作<br>    1. 当缓冲区由不可写变为可写时<br>    2. 当有旧数据被发送走 即缓冲区种数据变少的时候<br>    3. 当缓冲区有空间可写 且应用进程对相应的文件描述符进行epoll_ctl_mod修改epollout事件时</p>
<p>当被监控的文件描述符上有可读写事件发生时 epoll_wait()会通知处理程序去读写 如果这次没有把数据一次性全读完(读写缓冲区太小)<br>那么下次调用epoll_wait()时 那么下次调用epoll_wait()时 也就是它只会通知你一次 直到该文件描述符上出现第二次可读写事件才会通知你<br>这种模式比水平触发效率高 系统不会充斥大量你不关心的就绪文件描述符</p>
<p>在边缘触发的模式下 缓冲区从不可读变成可读 会唤醒应用进程 缓冲区数据变少的情况下不会再唤醒应用进程</p>
<p>For instance 1):<br>    1. 读缓冲区刚开始是空的<br>    2. 读缓冲区写入2KB数据<br>    3. 水平触发和边缘触发此时都会发出可读信号<br>    4. 收到信号通知后读取了1kb的数据 缓冲区还剩1kb<br>    5. 水平触发会再通知你继续读写 边缘触发不会再通知你</p>
<p>For instance 2):<br>    水平触发:0表示缓冲区无数据 1表示缓冲区有数据 缓冲区有数据则一直为1 就一直触发<br>    边缘触发:0表示缓冲区无数据 1表示缓冲区有数据 只有在0变为1的时候才触发</p>
<h4 id="epoll-select-poll比较"><a href="#epoll-select-poll比较" class="headerlink" title="epoll select poll比较"></a>epoll select poll比较</h4><h5 id="用户态将文件描述符传入内核的方式"><a href="#用户态将文件描述符传入内核的方式" class="headerlink" title="用户态将文件描述符传入内核的方式"></a>用户态将文件描述符传入内核的方式</h5><p>select: 创建3个文件描述符并拷贝到内核中 分别监听读&#x2F;写&#x2F;异常 这里单个进程可以打开的文件描述符fd数量默认限制为1024<br>poll: 将传入的struct pollfd结构体数组拷贝到内核中进行监听<br>epoll: 执行epoll_create会在内核的高速cache区域中建立一棵红黑树以及就绪链表(该链表存储已经就绪的文件描述符) 用户执行的epoll_ctl()添加文件描述符会在红黑树上增加相应的结点</p>
<h5 id="内核态检测文件描述符读写状态的方式"><a href="#内核态检测文件描述符读写状态的方式" class="headerlink" title="内核态检测文件描述符读写状态的方式"></a>内核态检测文件描述符读写状态的方式</h5><p>select: 采用轮询方式 遍历所有fd 最后返回一个描述符读写操作是否就绪的mask掩码 根据这个掩码给fd_set赋值<br>poll: 采用轮询方式 查询每个fd的状态 若就绪则在等待队列中加入一项并继续遍历<br>epoll: 采用回调机制 执行epoll_ctl的add操作时 不仅将文件描述符放进红黑树中 而且也注册了回调函数 内核在检测到某文件描述符可读&#x2F;可写的时候会调用回调函数 该回调函数将fd放在就绪链表中</p>
<h5 id="找到就绪的文件描述符并传递给用户态的方式"><a href="#找到就绪的文件描述符并传递给用户态的方式" class="headerlink" title="找到就绪的文件描述符并传递给用户态的方式"></a>找到就绪的文件描述符并传递给用户态的方式</h5><p>select: 将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数 用户态并不知道是哪些文件描述符处于就绪态 需要遍历来判断<br>poll: 将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数 用户态并不知道是哪些文件描述符处于就绪态 需要遍历来判断<br>epoll: epoll_wait()只用观察就绪链表中有无数据就行 最后将链表的数据返回给数组并返回就绪的数量 内核将就绪的文件描述符放在传入的数组中 所以只用遍历依次处理即可 这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现的 减少了不必要的拷贝</p>
<h5 id="重复监听的处理方式"><a href="#重复监听的处理方式" class="headerlink" title="重复监听的处理方式"></a>重复监听的处理方式</h5><p>select: 将新的监听文件描述符集合拷贝传入内核中 继续以上步骤<br>poll: 将新的struct pollfd结构体数组拷贝传入内核中 继续以上步骤<br>epoll: 无需重新构建红黑树 直接沿用已存在的即可</p>
<h4 id="epoll比select-x2F-poll更高效的原因"><a href="#epoll比select-x2F-poll更高效的原因" class="headerlink" title="epoll比select&#x2F;poll更高效的原因"></a>epoll比select&#x2F;poll更高效的原因</h4><p>1.select采用fd标注位来存放 poll采用链表来进行文件描述符的存储 所以select会受到最大连接数的限制 poll就不会<br>2.select poll epoll虽然都会返回就绪的文件描述符数量 但select&#x2F;poll并不会明确指出哪些fd处于就绪状态 epoll可以 系统调用返回后 调用select&#x2F;poll的程序需要遍历监听的整个fd来找到谁处于就绪 epoll可以直接处理<br>3.select&#x2F;poll都需要将有关文件描述符的数据结构拷贝进内核 最后再拷贝出来 而epoll创建的有关文件描述符的数据结构本身就存在内核态中 epoll使用mmap()减少复制开销<br>4.select&#x2F;poll采用轮询方式来检查fd是否处于就绪态 epoll采用回调机制 随着fd的增加 select&#x2F;poll的效率线性降低 epoll不会受到太大影响 除非活跃的socket太多<br>5.epoll的边缘触发机制效率高 系统不会充斥大量的不关心的就绪文件描述符<br>假如连接数少并且连接都十分活跃情况下 select&#x2F;poll性能比epoll好 因为epoll的通知机制需要很多函数回调 </p>

    </div>

    
    
    
        <div class="reward-container">
  <div>End of reading! -- Thanks for your supporting</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="syh 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="syh 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/22/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/" rel="prev" title="C++ 面试题集合">
      <i class="fa fa-chevron-left"></i> C++ 面试题集合
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/03/Binary-Tree/" rel="next" title="Binary-Tree">
      Binary-Tree <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll%E6%BA%90%E7%A0%81-%E6%B3%A8%E9%87%8A%E7%89%88"><span class="nav-number">1.</span> <span class="nav-text">epoll源码(注释版)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">epoll介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-API"><span class="nav-number">1.1.1.</span> <span class="nav-text">epoll API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#int-epoll-create-int-size"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">int epoll_create(int size)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">epoll的两种触发方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LT%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">LT水平触发的时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ET%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">ET边缘触发的时机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-select-poll%E6%AF%94%E8%BE%83"><span class="nav-number">1.1.3.</span> <span class="nav-text">epoll select poll比较</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%B0%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%BC%A0%E5%85%A5%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">用户态将文件描述符传入内核的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AF%BB%E5%86%99%E7%8A%B6%E6%80%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">内核态检测文件描述符读写状态的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E5%B0%B1%E7%BB%AA%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B9%B6%E4%BC%A0%E9%80%92%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">找到就绪的文件描述符并传递给用户态的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E7%9B%91%E5%90%AC%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">重复监听的处理方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E6%AF%94select-x2F-poll%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.1.4.</span> <span class="nav-text">epoll比select&#x2F;poll更高效的原因</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="syh"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">syh</p>
  <div class="site-description" itemprop="description">Algorithm & Open source by Ruojhen</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/shaoyuanhangyes" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shaoyuanhangyes" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shaoyuanhangoutlook@gmail.com" title="E-Mail → mailto:shaoyuanhangoutlook@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1349974130" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1349974130" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/110657431429268241192" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;110657431429268241192" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Ruojhen_syh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Ruojhen_syh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/Ruojhen_syh" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;Ruojhen_syh" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fab fa-accessible-icon"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syh</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://example.com/2020/05/25/epoll%E6%BA%90%E7%A0%81/',]
      });
      });
  </script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0432aa8796842fef84e6',
      clientSecret: '1f57cccd096d17be4bae86b5ffd966372dc71aad',
      repo        : 'gitalk',
      owner       : 'shaoyuanhangyes',
      admin       : ['shaoyuanhangyes'],
      id          : 'fcf52f51d70dca69417c273be6951804',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
