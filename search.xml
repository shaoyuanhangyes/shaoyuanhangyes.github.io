<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kafka</title>
      <link href="/2023/01/17/kafka/"/>
      <url>/2023/01/17/kafka/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective Golang</title>
      <link href="/2022/04/11/Effective-Golang/"/>
      <url>/2022/04/11/Effective-Golang/</url>
      
        <content type="html"><![CDATA[<p>Go语言精进之路</p><span id="more"></span> <h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="以构建二进制可执行文件为目的"><a href="#以构建二进制可执行文件为目的" class="headerlink" title="以构建二进制可执行文件为目的"></a>以构建二进制可执行文件为目的</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GoProject</span><br><span class="line"> |--LICENSE</span><br><span class="line"> |--Makefile</span><br><span class="line"> |--README.md</span><br><span class="line"> |--cmd/</span><br><span class="line">   |--app1/</span><br><span class="line">     |--main.go</span><br><span class="line">   |--app2/</span><br><span class="line">     |--main.go</span><br><span class="line"> |--go.mod</span><br><span class="line"> |--go.sum</span><br><span class="line"> |--pkg/</span><br><span class="line">   |--lib1/</span><br><span class="line">     |--lib1.go</span><br><span class="line">   |--lib2/</span><br><span class="line">     |--lib2.go</span><br></pre></td></tr></table></figure><p>cmd目录存放项目要构建的可执行文件对应的main包的源文件<br>cmd目录下的各app的main包将整个项目的依赖连接在一起<br>并且通常来说main包应该很简洁<br>我们会在main包中做一些命令行参数解析 资源初始化 日志设施初始化 数据库连接初始化等工作<br>之后就会将程序的执行权限交给更高级的执行控制对象<br>有一些Go项目将cmd这个名字改为app 但其功用并没有变</p><p>Makefile是项目构建工具的脚本 Go没有内置的例如CMake等级别的项目构建工具<br>在Go典型项目中 项目构建工具的脚本一般放在项目顶层目录下</p><p>go.mod go.sum Go 包依赖管理 使用的配置文件</p><p>pkg目录 存放项目自身要使用并且同样也是可执行文件对应main包要依赖的库文件<br>该目录下的包可以被外部项目引用 算是项目导出包的一个聚合</p><h3 id="以只构建库为目的"><a href="#以只构建库为目的" class="headerlink" title="以只构建库为目的"></a>以只构建库为目的</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GoLibProject</span><br><span class="line"> |--LICENSE</span><br><span class="line"> |--Makefile</span><br><span class="line"> |--README.md</span><br><span class="line"> |--go.mod</span><br><span class="line"> |--go.sum</span><br><span class="line"> |--lib.go</span><br><span class="line"> |--lib1/</span><br><span class="line">    |--lib1.go</span><br><span class="line"> |--lib2/</span><br><span class="line">    |--lib2.go</span><br><span class="line"> |--internal</span><br><span class="line">   |--ilib1/</span><br><span class="line">   |--ilib2/</span><br></pre></td></tr></table></figure><p>为何去除cmd和pkg两个子目录<br>因为只构建库所以没必要存放二进制文件main包源文件的cmd目录<br>因为Go库项目的初衷一般是对外部暴露API 因此没必要将其单独聚合在pkg目录下</p><p>若一些包不想暴露给外部引用 仅限项目内部使用 可以引入internal包机制实现<br>在顶层加入一个internal目录 将不想暴露到外部的包都放在该目录下</p><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>使用gofmt即可帮助规范化代码 但gofmt工具无法自动删减文件头部的包导入目标<br>但官方拥有goimports 可根据源码的最新变动自动从导入包列表中增删包</p><h2 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h2><h3 id="命名包"><a href="#命名包" class="headerlink" title="命名包"></a>命名包</h3><p>包package以小写形式的某个单词命名<br>包名可以不唯一 但尽量与包导入路径的最后分段保持一致</p><h3 id="命名变量"><a href="#命名变量" class="headerlink" title="命名变量"></a>命名变量</h3><p>小驼峰拼写法 lowCamelCase </p><p>变量名字中不要带有类型信息</p><h3 id="命名接口"><a href="#命名接口" class="headerlink" title="命名接口"></a>命名接口</h3><p>Go语言中的接口是Go在编程语言层面的一个创新，它为Go代码提供了强大的解耦合能力，因此良好的接口类型设计和接口组合是Go程序设计的静态骨架和基础。良好的接口设计自然离不开良好的接口命名。在Go语言中，对于接口类型优先以单个单词命名。对于拥有唯一方法(method)或通过多个拥有唯一方法的接口组合而成的接口，Go语言的惯例是用“方法名+er”命名。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用一致的变量声明形式"><a href="#使用一致的变量声明形式" class="headerlink" title="使用一致的变量声明形式"></a>使用一致的变量声明形式</h2><p>Go语言有两类变量<br>包级变量 在package级别可见的变量 若是导出变量则该包级变量也可以被视为全局变量<br>局部变量 函数或方法体内声明的变量 仅在函数和方法体内可见</p><h3 id="包级变量声明形式"><a href="#包级变量声明形式" class="headerlink" title="包级变量声明形式"></a>包级变量声明形式</h3><p>声明的同时显示初始化 若不初始化 则会被保证拥有同类型的”零值”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">int32</span>(<span class="number">17</span>)</span><br><span class="line"><span class="keyword">var</span> f = <span class="type">float32</span>(<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure><p>官方更推荐后者 尤其是将这些变量放在同一个var块中声明时</p><p>并且将同一类型的声明放在同一个var块中 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    bufioReaderPool sync.Pool</span><br><span class="line">    bufioWriter2kPoll sync.Pool</span><br><span class="line">    bufioWriter4kPool sync.Pool</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    aLongTimeAgo = time.Unix(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">    noDeadline = time.Time&#123;&#125;</span><br><span class="line">    noCancel = (<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/2022/04/11/Effective-Golang/effective1.jpg" alt="声明决策流程"></p><h2 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h2><p>定义常量使用const关键词</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    num1 <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    str1 <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>绝大多数情况下 Go常量在声明时并不显式指定类型<br>即无类型常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SeekStart = <span class="number">0</span></span><br><span class="line">    SeekCurrent = <span class="number">1</span></span><br><span class="line">    SeekEnd = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="有类型常量的烦恼"><a href="#有类型常量的烦恼" class="headerlink" title="有类型常量的烦恼"></a>有类型常量的烦恼</h3><p>为什么要使用无类型常量呢  因为在Go语言中 两个类型即便拥有相同的底层类型 也仍然是不同的数据类型 因此不能在一个表达式中进行运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span> </span><br><span class="line">    <span class="keyword">var</span> b myInt = <span class="number">8</span></span><br><span class="line">    fmt.Println(a + b) <span class="comment">//编译器报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go在处理不同类型的变量间运算时 不支持隐式的类型转换<br>若要解决上面的编译错误 则必须进行显示类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span> </span><br><span class="line">    <span class="keyword">var</span> b myInt = <span class="number">8</span></span><br><span class="line">    fmt.Println(a + <span class="type">int</span>(b)) <span class="comment">//输出13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 将有类型常量和变量一起运算时 也要遵循此规则<br>若两个类型不同 也会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = n + <span class="number">5</span> <span class="comment">//编译器报错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + n) <span class="comment">//编译器报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须显式类型转换后才能通过编译</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> n myInt = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> m <span class="type">int</span> = <span class="type">int</span>(n) + <span class="number">5</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    fmt.Println(a + <span class="type">int</span>(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无类型常量简化代码"><a href="#无类型常量简化代码" class="headerlink" title="无类型常量简化代码"></a>无类型常量简化代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> myFloat <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> j myInt = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> f myFloat = <span class="number">3.14</span></span><br><span class="line">    <span class="keyword">var</span> str myString = <span class="string">&quot;syh&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见 5 3.14 syh 无需类型转换就可以直接赋值给j f str 等价于下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j myInt = myInt(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> f myFloat = myFloat(<span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">var</span> str myString = myString(<span class="string">&quot;syh&quot;</span>)</span><br></pre></td></tr></table></figure><p>因此无类型常量使混合数据类型运算变的更加灵活 代码也有所简化 </p><p>无类型常量同样也拥有自己的默认类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">无类型的布偶常量 bool</span><br><span class="line">无类型的整数常量 int</span><br><span class="line">无类型的字符常量 int32(rune)</span><br><span class="line">无类型的浮点数常量 float64</span><br><span class="line">无类型的复数常量 complex128</span><br><span class="line">无类型的字符串常量 string</span><br></pre></td></tr></table></figure><p>若常量被赋值给无类型变量 or 接口变量<br>常量的默认类型对于确定无类型变量的类型及接口对应的动态类型是至关重要的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="string">&quot;Ruojhen&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := a</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, n) <span class="comment">//输出int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i) <span class="comment">//输出int</span></span><br><span class="line">    i = s</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, i) <span class="comment">//输出string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iota实现枚举常量"><a href="#iota实现枚举常量" class="headerlink" title="iota实现枚举常量"></a>iota实现枚举常量</h2><h3 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h3><p>C/C++中枚举常量的定义类型如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//c++没有显式的给枚举常量赋初始值 所以第一个常量值为0 后续常量依次+1</span></span><br><span class="line"><span class="function">ing <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Weekday</span> d = Saturday;</span><br><span class="line">    cout&lt;&lt;d;   <span class="comment">// 输出6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Go中没有提供定义枚举常量的语法 通常使用常量来定义枚举常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday    = <span class="number">0</span></span><br><span class="line">    Monday    = <span class="number">1</span></span><br><span class="line">    Tuesday   = <span class="number">2</span></span><br><span class="line">    Wednesday = <span class="number">3</span></span><br><span class="line">    Thursday  = <span class="number">4</span></span><br><span class="line">    Friday    = <span class="number">5</span></span><br><span class="line">    Saturday  = <span class="number">6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同时 Go的const语法还提供了 “隐式重复前一个非空表达式” 的机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape</span><br><span class="line">    Pear, Watermelon</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>尽管常量定义的后两行没有显式的赋初值 但Go编译器将其隐式使用第一行的表达式 因此上述代码等价为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Pear, Watermelon = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota是Go的一个预定义标识符 表示const声明块中每个常量所处位置在块中的偏移量<br>同时每一行中的iota自身也是一个无类型常量 可以自动参与不同类型的求值运算 而无须进行显式类型转换</p><p>下面是Go标准库中sync/mutex.go中的一段枚举常量的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/sync/mutex.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt;<span class="literal">iota</span></span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexStarving</span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第一行 <code>mutexLocked = 1 &lt;&lt;iota</code> 因为iota表示的是所处位置在const块中的偏移量 因此第一行的iota=0 所以<code>mutexLocked = 1 &lt;&lt;iota = 1&lt;&lt;0 = 1</code></p><p>第二行 mutexWoken没有显式的赋予初值 所以会隐式重复前一个非空表达式 即等价于 <code>mutexWoken = 1&lt;&lt;iota</code> 而在第二行中的iota=1 所以<code>mutexWoken = 1&lt;&lt;iota = 1&lt;&lt;1 = 2</code></p><p>第三行 同理 mutexStarving没有显式的赋予初值 所以等价于<code>mutexStarving = 1&lt;&lt;iota</code> 而在第三行中的iota=2 所以<code>mutexStarving = 1&lt;&lt;iota = 1&lt;&lt;2 = 4</code></p><p>第四行 <code>mutexWaiterShift = iota</code> 第四行中的iota=3 因此<code>mutexWaiterShift = iota = 3</code></p><p>位于同一行的iota即便出现多次 其值也是一样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="literal">iota</span>, <span class="literal">iota</span> + <span class="number">10</span> <span class="comment">// 0, 10 (iota = 0)</span></span><br><span class="line">    Strawberry, Grape               <span class="comment">// 1, 11 (iota = 1)</span></span><br><span class="line">    Pear, Watermelon                <span class="comment">// 2, 12 (iota = 2)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果要略过iota = 0 而从iota = 1开始正式定义枚举常量 可以效仿下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/syscall/net_js.go，go 1.12.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="literal">iota</span></span><br><span class="line">    IPV6_V6ONLY                     <span class="comment">// 1</span></span><br><span class="line">    SOMAXCONN                       <span class="comment">// 2</span></span><br><span class="line">    SO_ERROR                        <span class="comment">// 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果要定义非连续枚举值 也可以使用类似方式略过某一枚举值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="literal">iota</span>      <span class="comment">// 0</span></span><br><span class="line">    Pin1</span><br><span class="line">    Pin2</span><br><span class="line">    Pin3</span><br><span class="line">    _             <span class="comment">// 相当于_ = iota，略过了4这个枚举值</span></span><br><span class="line">    Pin5          <span class="comment">// 5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota使得Go在枚举常量定义上的表达力大增</p><p>iota预定义标识符能够以更为灵活的形式为枚举常量赋初值 在C++中就不那么灵活</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    spring,</span><br><span class="line">    summer = spring + <span class="number">2</span>,</span><br><span class="line">    fall = spring + <span class="number">3</span>,</span><br><span class="line">    winter = fall + <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 若要对winter求值 就必须向上查询fall summer spring的值</span></span><br></pre></td></tr></table></figure><p>Go的枚举常量不限于整型值 还可以定义浮点型的枚举常量 而C++就无法定义浮点类型的enum Go之所以可以定义浮点型是因为Go的无类型常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PI   = <span class="number">3.1415926</span>              <span class="comment">// π</span></span><br><span class="line">    PI_2 = <span class="number">3.1415926</span> / (<span class="number">2</span> * <span class="literal">iota</span>) <span class="comment">// π/2</span></span><br><span class="line">    PI_4                          <span class="comment">// π/4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota使得维护枚举常量更加容易 </p><p>传统的声明枚举变量方式为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Black  = <span class="number">1</span></span><br><span class="line">    Red    = <span class="number">2</span></span><br><span class="line">    Yellow = <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量按照首字母顺序排序。假如我们要增加一个颜色Blue，根据字母序，这个新常量应该放在Red的前面，但这样一来，我们就需要手动将从Red开始往后的常量的值都加1，十分费力</p><h2 id="尽量定义零值可用的类型"><a href="#尽量定义零值可用的类型" class="headerlink" title="尽量定义零值可用的类型"></a>尽量定义零值可用的类型</h2><p>C99规范对局部变量的规则是: 若一个变量是在栈上分配的局部变量 且在声明时未对其进行显式的初始化 那么它的值就是不确定的</p><p>因此Go在设计初就对变量默认值进行了规范<br>Go中的每个原生类型都有其默认值即零值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">所有整形类型   0</span><br><span class="line">浮点类型     0.0</span><br><span class="line">布尔类型    <span class="literal">false</span></span><br><span class="line">字符串类型    <span class="string">&quot;&quot;</span></span><br><span class="line">指针         nil</span><br><span class="line">interface    nil</span><br><span class="line">slice        nil</span><br><span class="line">channel      nil</span><br><span class="line"><span class="keyword">function</span>     nil</span><br><span class="line">map          nil</span><br></pre></td></tr></table></figure><p>并且 Go的零值初始是递归的  即数组 结构体等类型的零值初始化就是对其组成元素逐一进行零值初始</p><h3 id="零值可用"><a href="#零值可用" class="headerlink" title="零值可用"></a>零值可用</h3><p>零值可用即没有进行显式初始化的变量可以无需赋值即可直接进行操作 </p><p>例如 切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zeroSlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">zeroSlice = <span class="built_in">append</span>(zeroSlice, <span class="number">1</span>)</span><br><span class="line">zeroSlice = <span class="built_in">append</span>(zeroSlice, <span class="number">2</span>)</span><br><span class="line">zeroSlice = <span class="built_in">append</span>(zeroSlice, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(zeroSlice) <span class="comment">// 输出：[1 2 3]</span></span><br></pre></td></tr></table></figure><p>例如 通过nil指针调用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter3/sources/call_method_through_nil_pointer.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *net.TCPAddr</span><br><span class="line">    fmt.Println(p) <span class="comment">//输出：&lt;nil&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个net.TCPAddr类型的指针变量p 由于未对其显示初始化 指针变量p会被赋值为nil<br>在标准输出上输出该变量 <code>fmt.Println()</code>会调用<code>p.String()</code> 再来看看TCPAddr这个类型的String方法实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/tcpsock.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *TCPAddr)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;nil&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ip := ipEmptyString(a.IP)</span><br><span class="line">    <span class="keyword">if</span> a.Zone != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JoinHostPort(ip+<span class="string">&quot;%&quot;</span>+a.Zone, itoa(a.Port))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JoinHostPort(ip, itoa(a.Port))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到Go标准库在定义TCPAddr类型及方法充分考虑了零值可用 使得通过值为nil的TCPAddr指针变量依然可以调用String方法</p><p>Go标准库中<code>sync.Mutex</code>和<code>bytes.Buffer</code>也是充分践行了零值可用</p><p>先来看看<code>sync.Mutex</code> 在C中 想要使用线程互斥锁需要先初始化 然后才能上锁解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">// 不能直接使用</span></span><br><span class="line"><span class="comment">// 必须先对mutex进行初始化</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 然后才能执行lock或unlock</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>在Go中 直接使用即可 可以省略掉对Mutex的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure><p><code>bytes.Buffer</code>也是如此 无须对bytes.Buffer类型的变量b进行任何显式初始化 即可通过b调用Buffer类型的方法进行写入操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter3/sources/bytes_buffer_write.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">    b.Write([]<span class="type">byte</span>(<span class="string">&quot;Effective Go&quot;</span>))</span><br><span class="line">    fmt.Println(b.String()) <span class="comment">// 输出：Effective Go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为bytes.Buffer结构体用于存储数据的字段buf是支持零值可用的切片类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/bytes/buffer.go</span></span><br><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf      []<span class="type">byte</span></span><br><span class="line">    off      <span class="type">int</span></span><br><span class="line">    lastRead readOp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有提供零值可用的特例"><a href="#没有提供零值可用的特例" class="headerlink" title="没有提供零值可用的特例"></a>没有提供零值可用的特例</h3><p>在append场景下 零值可用的切片类型不能通过下标形式操作数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">12</span>         <span class="comment">// 报错！</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>map也没有提供零值可用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;go&quot;</span>] = <span class="number">1</span> <span class="comment">// 报错！</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m1[<span class="string">&quot;go&quot;</span>] = <span class="number">1</span> <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>零值可用的类型要注意尽量避免值传递  可以通过指针方式传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu1 := mu <span class="comment">// 错误: 避免值复制</span></span><br><span class="line">foo(mu) <span class="comment">// 错误: 避免值复制</span></span><br><span class="line">foo(&amp;mu) <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="为变量赋予适当的初值可保证正确的状态参与后续计算"><a href="#为变量赋予适当的初值可保证正确的状态参与后续计算" class="headerlink" title="为变量赋予适当的初值可保证正确的状态参与后续计算"></a>为变量赋予适当的初值可保证正确的状态参与后续计算</h2><p>有些时候 零值并非是最好的选择 我们有必要为变量赋予适当的初值以保证其后续以正确的状态参与业务流程计算 尤其是Go中的一些复合类型变量 例如 结构体 数组 切片 map<br>对于复合类型变量 最常见的值构造方式是对其内部进行逐个赋值 例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s myStruct</span><br><span class="line">s.name = <span class="string">&quot;tony&quot;</span></span><br><span class="line">s.age = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">13</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">14</span></span><br><span class="line">...</span><br><span class="line">a[<span class="number">4</span>] = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">sl := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">sl[<span class="number">0</span>] = <span class="number">23</span></span><br><span class="line">sl[<span class="number">1</span>] = <span class="number">24</span></span><br><span class="line">...</span><br><span class="line">sl[<span class="number">4</span>] = <span class="number">27</span></span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">&quot;gopher&quot;</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure><p>但这样的值构造方式让代码显得很繁琐<br>Go提供的复合字面值(composite literal)语法可以作为复合类型变量的初值构造器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;<span class="string">&quot;tony&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;</span><br><span class="line">sl := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> &#123;<span class="number">1</span>:<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>:<span class="string">&quot;gopher&quot;</span>, <span class="number">3</span>:<span class="string">&quot;!&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>复合字面值由两部分组成 一部分是类型 比如上述示例代码中赋值操作符右侧的myStruct [5]int []int map[int]string<br>另一部分是由大括号包裹的字面值 这里的字面值形式仅仅是Go复合字面值作为值构造器的基本用法 下面来看复合字面值对于不同复合类型的高级用法</p><h3 id="结构体复合字面值"><a href="#结构体复合字面值" class="headerlink" title="结构体复合字面值"></a>结构体复合字面值</h3><p>Go推荐使用field:value的复合字面值形式对struct类型变量进行值构造 这种值构造方式可以降低结构体类型使用者与结构体类型设计者之间的耦合<br>在Go标准库中 通过field:value格式的复合字面值进行结构体类型变量初值构造的例子比比皆是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/net/http/transport.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment,</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">        DualStack: <span class="literal">true</span>,</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">    IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">    TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">    ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/io/pipe.go</span></span><br><span class="line"><span class="keyword">type</span> pipe <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrMu sync.Mutex</span><br><span class="line">    wrCh <span class="keyword">chan</span> []<span class="type">byte</span></span><br><span class="line">    rdCh <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    once sync.Once</span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    rerr onceError</span><br><span class="line">    werr onceError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span></span> (*PipeReader, *PipeWriter) &#123;</span><br><span class="line">    p := &amp;pipe&#123;</span><br><span class="line">        wrCh: <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">byte</span>),</span><br><span class="line">        rdCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">        done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;PipeReader&#123;p&#125;, &amp;PipeWriter&#123;p&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种field:value形式的复合字面值初值构造器颇为强大 field:value形式字面值中的字段可以以任意次序出现 未显式出现在字面值的结构体中的字段将采用其对应类型的零值</p><p>以上述的pipe类型为例 Pipe函数在使用复合字面值对pipe类型进行初值构造时<br>仅对wrCh rdCh和done进行了field:value形式的显式赋值 这样pipe结构体中的其他变量的值将为其类型的初值 如wrMu</p><p>从上面例子中还可以看到 通过在复合字面值构造器的类型前面增加&amp; 可以得到对应类型的指针类型变量 如上面例子中的变量p的类型即为Pipe类型指针</p><p>复合字面值作为结构体值构造器的大量使用 使得即便采用类型零值时我们也会使用字面值构造器形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;&#125; <span class="comment">// 常用</span></span><br></pre></td></tr></table></figure><p>而较少使用new这一个Go预定义的函数来创建结构体变量实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">new</span>(myStruct) <span class="comment">// 较少使用</span></span><br></pre></td></tr></table></figure><p>值得注意的是 不允许将从其他包导入的结构体中的未导出字段作为复合字面值中的field 这会导致编译错误</p><h3 id="数组-切片复合字面值"><a href="#数组-切片复合字面值" class="headerlink" title="数组/切片复合字面值"></a>数组/切片复合字面值</h3><p>与结构体类型不同 数组/切片使用下标(index)作为field:value形式中的field 从而实现数组/切片初始元素值的高级构造形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers := [<span class="number">256</span>]<span class="type">int</span>&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [10]float&#123;-1, 0, 0, 0, -0.1, -0.1, 0, 0.1, 0, -1&#125;</span></span><br><span class="line">fnumbers := [...]float&#123;<span class="number">-1</span>, <span class="number">4</span>: <span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">7</span>:<span class="number">0.1</span>, <span class="number">9</span>: <span class="number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/sort/search_test.go</span></span><br><span class="line"><span class="keyword">var</span> data = []<span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">-10</span>, <span class="number">1</span>: <span class="number">-5</span>, <span class="number">2</span>: <span class="number">0</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">3</span>, <span class="number">6</span>: <span class="number">5</span>, <span class="number">7</span>: <span class="number">7</span>,</span><br><span class="line">       <span class="number">8</span>: <span class="number">11</span>, <span class="number">9</span>: <span class="number">100</span>, <span class="number">10</span>: <span class="number">100</span>, <span class="number">11</span>: <span class="number">100</span>, <span class="number">12</span>: <span class="number">1000</span>, <span class="number">13</span>: <span class="number">10000</span>&#125;</span><br><span class="line"><span class="keyword">var</span> sdata = []<span class="type">string</span>&#123;<span class="number">0</span>: <span class="string">&quot;f&quot;</span>, <span class="number">1</span>: <span class="string">&quot;foo&quot;</span>, <span class="number">2</span>: <span class="string">&quot;foobar&quot;</span>, <span class="number">3</span>: <span class="string">&quot;x&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>不同于结构体复合字面值较多采用field:value形式作为值构造器</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis3-0-note-chapter-2</title>
      <link href="/2021/09/07/Redis3-0-note-chapter-2/"/>
      <url>/2021/09/07/Redis3-0-note-chapter-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis3-0源码阅读笔记-二"><a href="#Redis3-0源码阅读笔记-二" class="headerlink" title="Redis3.0源码阅读笔记 (二)"></a>Redis3.0源码阅读笔记 (二)</h1><p>继上篇文章<a href="https://shaoyuanhangyes.github.io/2021/08/30/Redis3-0-note-chapter-1/#more">Redis3.0源码阅读笔记 (一)</a></p><table><thead><tr><th align="center">源码文件</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>ae_epoll.c</code>,<code>ae_evport.h</code>,<code>ae_kqueue.c</code>,<code>ae_select.c</code></td><td align="center">基于I/O多路复用的事件驱动库</td></tr><tr><td align="center"><code>znalloc.c</code>,<code>zmalloc.h</code></td><td align="center">内存管理程序</td></tr></tbody></table><span id="more"></span> ]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Database </tag>
            
            <tag> C </tag>
            
            <tag> Nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis3.0-note chapter 1</title>
      <link href="/2021/08/30/Redis3-0-note-chapter-1/"/>
      <url>/2021/08/30/Redis3-0-note-chapter-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis3-0源码阅读笔记-一"><a href="#Redis3-0源码阅读笔记-一" class="headerlink" title="Redis3.0源码阅读笔记 (一)"></a>Redis3.0源码阅读笔记 (一)</h1><table><thead><tr><th align="center">源码文件</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>adlist.c</code>,<code>adlist.h</code></td><td align="center">双端链表数据结构的实现</td></tr><tr><td align="center"><code>znalloc.c</code>,<code>zmalloc.h</code></td><td align="center">内存管理程序</td></tr></tbody></table><span id="more"></span> <h2 id="adlist-h"><a href="#adlist-h" class="headerlink" title="adlist.h"></a>adlist.h</h2><p>双端链表节点实现 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *prev; <span class="comment">// 前置节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *next; <span class="comment">// 后置节点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *value; <span class="comment">// 节点的值</span></span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>双端链表迭代器实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listIter</span> &#123;</span><br><span class="line"></span><br><span class="line">    listNode *next; <span class="comment">// 当前迭代到的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> direction; <span class="comment">// 迭代的方向</span></span><br><span class="line"></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure><p>双端链表结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line"></span><br><span class="line">    listNode *head; <span class="comment">// 表头节点</span></span><br><span class="line"></span><br><span class="line">    listNode *tail; <span class="comment">// 表尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr); <span class="comment">// 节点值复制函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*free)(<span class="type">void</span> *ptr); <span class="comment">// 节点值释放函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key); <span class="comment">// 节点值对比函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len; <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line"></span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>宏定义的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的表头节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的表尾节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定节点的前置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定节点的后置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定节点的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表的对比函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值复制函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值释放函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值对比函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure><p>宏定义的迭代器描述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从表头向表尾进行迭代</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从表尾到表头进行迭代</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_TAIL 1</span></span><br></pre></td></tr></table></figure><p><code>adlist.c</code>函数声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="function">list *<span class="title">listCreate</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRelease</span><span class="params">(list *list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">list *<span class="title">listAddNodeHead</span><span class="params">(list *list, <span class="type">void</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">list *<span class="title">listAddNodeTail</span><span class="params">(list *list, <span class="type">void</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">list *<span class="title">listInsertNode</span><span class="params">(list *list, listNode *old_node, <span class="type">void</span> *value, <span class="type">int</span> after)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listDelNode</span><span class="params">(list *list, listNode *node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(list *list, <span class="type">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">list *<span class="title">listDup</span><span class="params">(list *orig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(list *list, <span class="type">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(list *list, <span class="type">long</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRewind</span><span class="params">(list *list, listIter *li)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRewindTail</span><span class="params">(list *list, listIter *li)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRotate</span><span class="params">(list *list)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="adlist-c"><a href="#adlist-c" class="headerlink" title="adlist.c"></a>adlist.c</h2><p>头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adlist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zmalloc.h&quot;</span> <span class="comment">// 内存管理文件</span></span></span><br></pre></td></tr></table></figure><p>创建链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建成功返回链表，失败返回 NULL 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">list *<span class="title">listCreate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list</span> *list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((list = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*list))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    list-&gt;head = list-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    list-&gt;len = <span class="number">0</span>;</span><br><span class="line">    list-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    list-&gt;free = <span class="literal">NULL</span>;</span><br><span class="line">    list-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放整个链表，以及链表中所有节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRelease</span><span class="params">(list *list)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line">    current = list-&gt;head; <span class="comment">// 指向头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个链表</span></span><br><span class="line">    len = list-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></span><br><span class="line">        <span class="keyword">if</span> (list-&gt;free) list-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点结构</span></span><br><span class="line">        <span class="built_in">zfree</span>(current);</span><br><span class="line"></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表结构</span></span><br><span class="line">    <span class="built_in">zfree</span>(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加新节点到双端链表的表头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将一个包含有给定值指针 value 的新节点添加到链表的表头</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果执行成功，返回传入的链表指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">list *<span class="title">listAddNodeHead</span><span class="params">(list *list, <span class="type">void</span> *value)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (list-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        list-&gt;head = list-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 添加节点到非空链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = list-&gt;head;</span><br><span class="line">        list-&gt;head-&gt;prev = node;</span><br><span class="line">        list-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    list-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加新节点到双端链表的表尾</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将一个包含有给定值指针 value 的新节点添加到链表的表尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果执行成功，返回传入的链表指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">list *<span class="title">listAddNodeTail</span><span class="params">(list *list, <span class="type">void</span> *value)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (list-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        list-&gt;head = list-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 目标链表非空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = list-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        list-&gt;tail-&gt;next = node;</span><br><span class="line">        list-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    list-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入新节点到某一个节点之前或之后 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 after 为 0 ，将新节点插入到 old_node 之前。</span></span><br><span class="line"><span class="comment"> * 如果 after 为 1 ，将新节点插入到 old_node 之后。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">list *<span class="title">listInsertNode</span><span class="params">(list *list, listNode *old_node, <span class="type">void</span> *value, <span class="type">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((node = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将新节点添加到给定节点之后</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123; </span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="comment">// 给定节点是原表尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (list-&gt;tail == old_node) &#123;</span><br><span class="line">            list-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 将新节点添加到给定节点之前</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="comment">// 给定节点是原表头节点</span></span><br><span class="line">        <span class="keyword">if</span> (list-&gt;head == old_node) &#123;</span><br><span class="line">            list-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新新节点的前置指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新新节点的后置指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    list-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除给定的某节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从链表 list 中删除给定节点 node </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对节点私有值(private value of the node)的释放工作由调用者进行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listDelNode</span><span class="params">(list *list, listNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调整前置节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list-&gt;head = node-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整后置节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list-&gt;tail = node-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放值</span></span><br><span class="line">    <span class="keyword">if</span> (list-&gt;free) list-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点</span></span><br><span class="line">    <span class="built_in">zfree</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表数减一</span></span><br><span class="line">    list-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为链表添加迭代器 并决定迭代方向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为给定链表创建一个迭代器，</span></span><br><span class="line"><span class="comment"> * 之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * direction 参数决定了迭代器的迭代方向：</span></span><br><span class="line"><span class="comment"> *  AL_START_HEAD ：从表头向表尾迭代</span></span><br><span class="line"><span class="comment"> *  AL_START_TAIL ：从表尾想表头迭代</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(list *list, <span class="type">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为迭代器分配内存</span></span><br><span class="line">    listIter *iter;</span><br><span class="line">    <span class="keyword">if</span> ((iter = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = list-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = list-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录迭代方向</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放迭代器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">zfree</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将迭代器的方向设置为从表头开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将迭代器的方向设置为 AL_START_HEAD ，</span></span><br><span class="line"><span class="comment"> * 并将迭代指针重新指向表头节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRewind</span><span class="params">(list *list, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = list-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将迭代器的方向设置为从表尾开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将迭代器的方向设置为 AL_START_TAIL ，</span></span><br><span class="line"><span class="comment"> * 并将迭代指针重新指向表尾节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRewindTail</span><span class="params">(list *list, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = list-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回迭代器当前所指向的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回迭代器当前所指向的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 删除当前节点是允许的，但不能修改链表里的其他节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数要么返回一个节点，要么返回 NULL ，常见的用法是：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iter = listGetIterator(list,&lt;direction&gt;);</span></span><br><span class="line"><span class="comment"> * while ((node = listNext(iter)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     doSomethingWith(listNodeValue(node));</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据方向选择下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复制链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 复制整个链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复制成功返回输入链表的副本，</span></span><br><span class="line"><span class="comment"> * 如果因为内存不足而造成复制失败，返回 NULL 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，</span></span><br><span class="line"><span class="comment"> * 否则，新节点将和旧节点共享同一个指针。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 无论复制是成功还是失败，输入节点都不会修改。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">list *<span class="title">listDup</span><span class="params">(list *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span> ((copy = <span class="built_in">listCreate</span>()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点值处理函数</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;free = orig-&gt;free;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个输入链表</span></span><br><span class="line">    iter = <span class="built_in">listGetIterator</span>(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = <span class="built_in">listNext</span>(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制节点值到新节点</span></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;<span class="built_in">dup</span>(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">listRelease</span>(copy);</span><br><span class="line">                <span class="built_in">listReleaseIterator</span>(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点添加到链表</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listAddNodeTail</span>(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">listRelease</span>(copy);</span><br><span class="line">            <span class="built_in">listReleaseIterator</span>(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    <span class="built_in">listReleaseIterator</span>(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回副本</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找链表内某一个节点 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 查找链表 list 中值和 key 匹配的节点。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 对比操作由链表的 match 函数负责进行，</span></span><br><span class="line"><span class="comment"> * 如果没有设置 match 函数，</span></span><br><span class="line"><span class="comment"> * 那么直接通过对比值的指针来决定是否匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果匹配成功，那么第一个匹配的节点会被返回。</span></span><br><span class="line"><span class="comment"> * 如果没有匹配任何节点，那么返回 NULL 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(list *list, <span class="type">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个链表</span></span><br><span class="line">    iter = <span class="built_in">listGetIterator</span>(list, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = <span class="built_in">listNext</span>(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对比</span></span><br><span class="line">        <span class="keyword">if</span> (list-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list-&gt;<span class="built_in">match</span>(node-&gt;value, key)) &#123;</span><br><span class="line">                <span class="built_in">listReleaseIterator</span>(iter);</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                <span class="built_in">listReleaseIterator</span>(iter);</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">listReleaseIterator</span>(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入索引 返回链表中该索引对应的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回链表在给定索引上的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 索引以 0 为起始，也可以是负数， -1 表示链表最后一个节点，诸如此类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果索引超出范围（out of range），返回 NULL 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(list *list, <span class="type">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果索引为负数，从表尾开始查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = list-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    <span class="comment">// 如果索引为正数，从表头开始查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = list-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将表尾节点移动到表头 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listRotate</span><span class="params">(list *list)</span> </span>&#123;</span><br><span class="line">    listNode *tail = list-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listLength</span>(list) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="comment">// 取出表尾节点</span></span><br><span class="line">    list-&gt;tail = tail-&gt;prev;</span><br><span class="line">    list-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="comment">// 插入到表头</span></span><br><span class="line">    list-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = list-&gt;head;</span><br><span class="line">    list-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Database </tag>
            
            <tag> C </tag>
            
            <tag> Nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-Tree</title>
      <link href="/2021/08/20/B-Tree/"/>
      <url>/2021/08/20/B-Tree/</url>
      
        <content type="html"><![CDATA[<p>本篇文章为<a href="https://shaoyuanhangyes.github.io/2020/06/03/Binary-Tree/#more"><code>shaoyuanhangyes.github.io/Binary_Tree</code></a>的拆分后续 将继续讲述<code>B-Tree</code>与<code>红黑树</code> <code>B+树</code> 的区别</p><span id="more"></span><h2 id="BST复习"><a href="#BST复习" class="headerlink" title="BST复习"></a>BST复习</h2><p><code>Binary Search Tree</code> 二叉搜索树 or 二叉查找树 </p><p>BST的特点为 某一节点的值 总是大于其任意左侧子节点的值 总是小于其任意右侧子节点的值</p><p>这么设计的目的是为了提高查找的性能 使得查找效率接近于二分查找</p><p>但是 当二叉树高度和二叉树节点数量相同的时候 即</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">6</span></span><br><span class="line">         <span class="regexp">/</span></span><br><span class="line"><span class="regexp">        5</span></span><br><span class="line"><span class="regexp">       /</span></span><br><span class="line">      <span class="number">4</span></span><br><span class="line">     <span class="regexp">/   </span></span><br><span class="line"><span class="regexp">    3     </span></span><br><span class="line"><span class="regexp">   /</span>   </span><br><span class="line">  <span class="number">2</span>  </span><br><span class="line"> <span class="regexp">/</span></span><br><span class="line"><span class="regexp">1</span></span><br></pre></td></tr></table></figure><p>在此BST中查找元素1 需要查找6次 </p><p>它已经退化为一个单向链表 其查找效率就会很低 最坏情况下的时间复杂度为O(H) H为二叉树的高度</p><p>若变更为如下的存储方式呢</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number"> 3 </span> </span><br><span class="line">   / \</span><br><span class="line"> <span class="number"> 2 </span>  5</span><br><span class="line"> /   / \</span><br><span class="line">1  <span class="number"> 4 </span>  6</span><br></pre></td></tr></table></figure><p>此时查询元素1 只需要查找3次 查找效率得到提高</p><p>可以得出结论BST的查找效率 取决于树的高度 因此只要能保持树的高度最小 就能保证BST的查找效率 </p><p>因此 就需要引入平衡二叉树的概念</p><h2 id="AVL复习"><a href="#AVL复习" class="headerlink" title="AVL复习"></a>AVL复习</h2><p>AVL 平衡二叉查找树 简称平衡二叉树</p><p>AVL的任何一个节点的左右子树高度差不能超过1 </p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number"> 3 </span> </span><br><span class="line">   / \</span><br><span class="line"> <span class="number"> 2 </span>  5</span><br><span class="line"> /   / \</span><br><span class="line">1  <span class="number"> 4 </span> <span class="number"> 6 </span> 这就是一个平衡二叉树</span><br></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      4</span><br><span class="line">     / \</span><br><span class="line">   <span class="number"> 3 </span>  5</span><br><span class="line">   /   / \</span><br><span class="line"> <span class="number"> 2 </span> <span class="number"> 6 </span>  7</span><br><span class="line"> /  </span><br><span class="line">1          这不是平衡二叉树 因为节点3的左子树不是平衡二叉树</span><br></pre></td></tr></table></figure><h3 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h3><p>为能够准确判断某个二叉搜索树是否为平衡二叉树 引入平衡因子的概念</p><p>二叉树中某节点的左子树和右子树的高度(深度)差值即为该节点的平衡因子BF(Balance Factor)</p><p>当某个树的平衡因子为 <code>-1</code>或<code>0</code>或<code>1</code>时 说明此树为平衡二叉树</p><p>当平衡二叉树不平衡时 就需要对此二叉树进行平衡调整</p><p>调整的策略为 旋转最小失衡子树 </p><p>最小失衡子树的定义为 在新插入的节点向上查找 以第一个平衡因子绝对值超过1的节点为root的子树 为最小失衡子树</p><p>一个失衡的树 是有可能有多个子树同时失衡的 而我们只需要调整最小的不平衡子树 就可以将不平衡的树调整为平衡的树</p><p>旋转最小失衡子树有两种旋转方式  左旋 右旋 </p><p>旋转的目的是减少高度 通过降低树的高度来实现平衡 哪边的树高 就把哪边的树向上旋转</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>针对不平衡的二叉搜索树 共总结出四个常用结论 分别为 <code>LL</code> <code>RR</code> <code>LR</code> <code>RL</code></p><p>右旋</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number"> 3 </span>                                 2</span><br><span class="line">   /                                  / \</span><br><span class="line"> <span class="number"> 2 </span>         此为LL型 旋转后变为     <span class="number"> 1 </span>   3</span><br><span class="line"> /  </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>左旋</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>                                  <span class="number">2</span></span><br><span class="line"> <span class="string">\</span>                                / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>      此为RR型 旋转后变为      <span class="number">1</span>    <span class="number">3</span></span><br><span class="line">   <span class="string">\</span></span><br><span class="line">    <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number"> 4 </span>                     <span class="number"> 4 </span>                  3</span><br><span class="line"> /                       /                   / \</span><br><span class="line">2 此为LR型 先左旋变为   <span class="number"> 3 </span>   再经右旋变为   <span class="number"> 2 </span>   4</span><br><span class="line"> \                     /</span><br><span class="line"> <span class="number"> 3 </span>                  2</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>                        <span class="number">2</span>                        <span class="number">3</span></span><br><span class="line"> <span class="string">\</span>                        <span class="string">\</span>                      / <span class="string">\</span></span><br><span class="line">  <span class="number">4</span> 此为RL型 先右旋旋变为    <span class="number">3</span>    再经左旋变为    <span class="number">2</span>    <span class="number">4</span></span><br><span class="line"> /                          <span class="string">\</span></span><br><span class="line"><span class="number">3</span>                            <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="红黑树复习"><a href="#红黑树复习" class="headerlink" title="红黑树复习"></a>红黑树复习</h2><p>虽然AVL的查找效率很高 但是对AVL进行插入和删除操作的时候需要大量的自旋来满足平衡要求 而AVL的旋转特别的麻烦 因此 引入了一个新的概念 ——RBT红黑树</p><p>红黑树是一个自平衡的二叉查找树 RBT的平衡性没有AVL那么强 并且在插入和删除操作时的旋转操作也没有AVL那么多</p><p>因此 在插入和删除较少 但查找更为频繁的情况下 AVL会是更好的选择<br>相反 在插入和删除较多 查找没那么频繁的情况下 RBT会是更好的选择</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>结点是红色或黑色<br>根结点一定是黑色的<br>每一个叶子结点(NIL)都是黑色<br>每个红色结点的两个子结点都是黑色<br>没有两个相邻的红色结点(红色结点不能有红色父结点和红色子结点 并没有说不能有两个连续的黑结点)<br>任意一个结点到其每个叶子结点(NIL)的路径都包含相同数目的黑色结点 简称为黑高</p><p>红黑树的高度 一定小于 $2·log_2(n+1)$<br>由此可见 RBT和AVL的时间复杂度大致接近</p><h4 id="插入新结点"><a href="#插入新结点" class="headerlink" title="插入新结点"></a>插入新结点</h4><ol><li>若一个树为空树 则插入的新结点必是黑色的 </li><li>若一个树不为空 则插入的新结点总是先当作红色结点 </li><li>若新插入的结点的父结点是黑色的 则符合要求 不做修改</li><li>若新插入的结点的父结点是红色的 则需要检查父结点的兄弟结点是否也为红色 若为红色 则将父结点及其兄弟结点一起变色(变黑) 然后继续父结点的父结点也要变色 (除非它是根结点可以不用变色 因为根结点必是黑色)</li><li>若新插入的结点的父结点是红色的 则需要检查父结点的兄弟结点是否也为红色 若不为红色或没有兄弟结点 则需要先进行相应的自旋之后 再按照4的要求变色 </li></ol><h4 id="删除新结点"><a href="#删除新结点" class="headerlink" title="删除新结点"></a>删除新结点</h4><ol><li>要删除的结点没有子结点<br>若是红色结点 直接删除即可<br>若是黑色结点 需要进行平衡操作</li><li>要删除的结点有一个子结点</li></ol>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go技能树</title>
      <link href="/2021/08/13/Go%E6%8A%80%E8%83%BD%E6%A0%91/"/>
      <url>/2021/08/13/Go%E6%8A%80%E8%83%BD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Golang后台云原生技能点</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h2 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h2><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h3><h3 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h3><h3 id="json-protobuf"><a href="#json-protobuf" class="headerlink" title="json/protobuf"></a>json/protobuf</h3><h3 id="服务间的同步机制"><a href="#服务间的同步机制" class="headerlink" title="服务间的同步机制"></a>服务间的同步机制</h3><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><h2 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h2><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><h3 id="CVM云服务器"><a href="#CVM云服务器" class="headerlink" title="CVM云服务器"></a>CVM云服务器</h3><h3 id="TKE容器服务"><a href="#TKE容器服务" class="headerlink" title="TKE容器服务"></a>TKE容器服务</h3>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next8.x配置gitalk</title>
      <link href="/2021/07/18/Next8-x%E9%85%8D%E7%BD%AEgitalk/"/>
      <url>/2021/07/18/Next8-x%E9%85%8D%E7%BD%AEgitalk/</url>
      
        <content type="html"><![CDATA[<p>升级Hexo和Next版本后 发现gitalk总是挂掉 阅读了Next的文档后 发现gitalk配置方式进行了更新 所以此文为<a href="https://shaoyuanhangyes.github.io/2020/03/17/Hexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AEgitalk/">Hexo-Next主题配置gitalk</a>这篇文章的升级版本 读者可根据自己Next的主题版本自行取用</p><span id="more"></span> <h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>有存放gitalk的issue的仓库 有创建OAuth的接口 并且记住<code>Client Id</code> <code>Client secret</code> </p><h2 id="配置config-yml"><a href="#配置config-yml" class="headerlink" title="配置config.yml"></a>配置config.yml</h2><p>Next8.x版本起 不需要我们自己再去写md5.js及其余swig格式文件 新版本已经将gitalk完全集成在了Next中 只需要改变config中的配置信息即可 </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">shaoyuanhangyes</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">gitalk</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="number">0432</span><span class="string">***********84e6</span> <span class="comment">#GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">1f57***********1aad</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="string">shaoyuanhangyes</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># When the official proxy is not available, you can change it to your own proxy address</span></span><br><span class="line">  <span class="attr">proxy:</span> <span class="string">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span> <span class="comment"># This is official proxy adress</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure><p>因为经常出现请求失败403等问题 gitalk作者给出了相应的解决方法 即<code>proxy</code>替换为<br><code>https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</code></p><h2 id="npm安装gitalk"><a href="#npm安装gitalk" class="headerlink" title="npm安装gitalk"></a>npm安装gitalk</h2><p>在bolg文件夹下 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save gitalk</span><br></pre></td></tr></table></figure><h2 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h2><p>经过以上操作 gitalk即可使用 不要忘记<code>hexo clean &amp;&amp; hexo g -d</code></p>]]></content>
      
      
      <categories>
          
          <category> Hexo配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题之Golang模版</title>
      <link href="/2021/05/13/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8BGolang%E6%A8%A1%E7%89%88/"/>
      <url>/2021/05/13/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8BGolang%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在LeetCode上刷题时 有的时候自己无法理解和追踪某个变量的变化 因此需要debug代码 但LeetCode的debug功能很鸡肋 不如自己在本地编译器中进行断点调试 但LeetCode的解题只需要写出功能的函数即可 所以我们需要自己补写出其他函数来保证debug的成功</p><span id="more"></span><h2 id="链表模版"><a href="#链表模版" class="headerlink" title="链表模版"></a>链表模版</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//链表结构体</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val <span class="type">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用数组创建对应的链表 后插法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createList</span><span class="params">(nums []<span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">prev := <span class="built_in">new</span>(ListNode)</span><br><span class="line">prev.Val = nums[<span class="number">0</span>]</span><br><span class="line">prevHead := <span class="built_in">new</span>(ListNode)</span><br><span class="line">prevHead = prev</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">temp := <span class="built_in">new</span>(ListNode)</span><br><span class="line">temp.Val = nums[i]</span><br><span class="line">prev.Next = temp</span><br><span class="line">prev = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prevHead</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示链表中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowList</span><span class="params">(L *ListNode)</span></span> &#123;</span><br><span class="line">temp := L</span><br><span class="line"><span class="keyword">for</span> temp != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Print(temp.Val,<span class="string">&quot; &quot;</span>)</span><br><span class="line">temp = temp.Next</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树模版"><a href="#树模版" class="headerlink" title="树模版"></a>树模版</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//二叉树结构体</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val   <span class="type">int</span></span><br><span class="line">Left  *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTree</span><span class="params">(nums []<span class="type">int</span>, <span class="built_in">len</span> <span class="type">int</span>, index <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">root := <span class="built_in">new</span>(TreeNode)</span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span> &amp;&amp; nums[index] != <span class="number">-1</span> &#123;</span><br><span class="line">root.Val = nums[index]</span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span>*index+<span class="number">1</span> &lt; <span class="built_in">len</span> &#123;</span><br><span class="line">root.Left = createTree(nums, <span class="built_in">len</span>, <span class="number">2</span>*index+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span>*index+<span class="number">2</span> &lt; <span class="built_in">len</span> &#123;</span><br><span class="line">root.Right = createTree(nums, <span class="built_in">len</span>, <span class="number">2</span>*index+<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的层序遍历 输出到一个二维数组中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">temp := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(queue); j++ &#123;</span><br><span class="line">node := queue[j]</span><br><span class="line">res[i] = <span class="built_in">append</span>(res[i], node.Val)</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">temp = <span class="built_in">append</span>(temp, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">temp = <span class="built_in">append</span>(temp, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintMartrix</span><span class="params">(res [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(res); i++ &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;[&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(res[i]); j++ &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot; &quot;</span>, res[i][j], <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;]&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Modules</title>
      <link href="/2021/03/31/Go-trap/"/>
      <url>/2021/03/31/Go-trap/</url>
      
        <content type="html"><![CDATA[<h2 id="开启go-mod"><a href="#开启go-mod" class="headerlink" title="开启go mod"></a>开启go mod</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GO111MODULE=<span class="string">&quot;on&quot;</span></span><br></pre></td></tr></table></figure><h2 id="编写测试程序"><a href="#编写测试程序" class="headerlink" title="编写测试程序"></a>编写测试程序</h2><ol><li>源码文件以<code>_test</code>结尾 : <code>xxx_test.go</code></li><li>测试方法名以<code>Test</code>开头 ：`func TestXXX(t *testing.T) {…}</li></ol><span id="more"></span> ]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go反射</title>
      <link href="/2021/03/26/Go%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/03/26/Go%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Go反射"><a href="#Go反射" class="headerlink" title="Go反射"></a>Go反射</h2>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go面向对象</title>
      <link href="/2021/03/12/Go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/03/12/Go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Go面向对象"><a href="#Go面向对象" class="headerlink" title="Go面向对象"></a>Go面向对象</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言中没有class类的概念 只有struct结构体的概念</p><span id="more"></span> <h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Profile 定义结构体</span></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">age    <span class="type">int</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">mother *Profile</span><br><span class="line">father *Profile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(person Profile)</span></span> fmtProfile() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;名字:&quot;</span>, person.name)</span><br><span class="line">fmt.Println(<span class="string">&quot;年龄:&quot;</span>, person.age)</span><br><span class="line">fmt.Println(<span class="string">&quot;性别:&quot;</span>, person.gender)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmtProfile是方法名</span></span><br><span class="line"><span class="comment">//(person Profile) 表示将fmtProfile方法与Profile的实例绑定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">individual := Profile&#123;name: <span class="string">&quot;Tom&quot;</span>, age: <span class="number">18</span>, gender: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">individual.fmtProfile()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">名字: Tom</span><br><span class="line">年龄: 18</span><br><span class="line">性别: male</span><br></pre></td></tr></table></figure><h4 id="函数的参数传递方式"><a href="#函数的参数传递方式" class="headerlink" title="函数的参数传递方式"></a>函数的参数传递方式</h4><p>若要在函数内改变实例的属性 必须要用指针作为函数的接受者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Profile 定义结构体</span></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">age    <span class="type">int</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">mother *Profile</span><br><span class="line">father *Profile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(person *Profile)</span></span> increase() &#123;</span><br><span class="line">person.age ++ </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">individual := Profile&#123;name: <span class="string">&quot;Tom&quot;</span>, age: <span class="number">18</span>, gender: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;当前年龄:&quot;</span>,individual.age)</span><br><span class="line">individual.increase()</span><br><span class="line">fmt.Println(<span class="string">&quot;增加年龄后:&quot;</span>,individual.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前年龄: 18</span><br><span class="line">增加年龄后: 19</span><br></pre></td></tr></table></figure><p>若不使用指针作为函数的接收者 实例的age是不会改变的 </p><h4 id="结构体利用组合实现”继承”"><a href="#结构体利用组合实现”继承”" class="headerlink" title="结构体利用组合实现”继承”"></a>结构体利用组合实现”继承”</h4><p>因为Go语言本身没有继承 但我们用组合的方式 实现继承的效果<br>组合 是指把一个结构体嵌入到另一个结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公司</span></span><br><span class="line"><span class="keyword">type</span> company <span class="keyword">struct</span> &#123;</span><br><span class="line">companyName <span class="type">string</span></span><br><span class="line">companyAddr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//员工</span></span><br><span class="line"><span class="keyword">type</span> staff <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">position <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要将公司和员工关联起来 有很多方法</p><p>若采用将公司结构体的内容直接抄录到员工中 实现效果方面没有任何问题 但实际操作中会出现对同一个公司的多个员工初始化的时候 都得重复初始化这同一个公司的信息 借助继承的思想 可以将公司的属性继承给员工<br>Go中没有类的概念 可以将公司company这个结构体直接嵌入在员工staff中 成为staff的一个匿名字段 此时staff就直接拥有了company的所有属性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> company <span class="keyword">struct</span> &#123;</span><br><span class="line">companyName <span class="type">string</span></span><br><span class="line">companyAddr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> staff <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">age      <span class="type">int</span></span><br><span class="line">gender   <span class="type">string</span></span><br><span class="line">position <span class="type">string</span></span><br><span class="line">company  <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ComInfo := company&#123;</span><br><span class="line">companyName: <span class="string">&quot;Facebook&quot;</span>,</span><br><span class="line">companyAddr: <span class="string">&quot;USA&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">StaffInfo := staff&#123;</span><br><span class="line">name:     <span class="string">&quot;Ruojhen&quot;</span>,</span><br><span class="line">age:      <span class="number">24</span>,</span><br><span class="line">gender:   <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">position: <span class="string">&quot;Go Developer&quot;</span>,</span><br><span class="line">company: ComInfo,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 在 %s 工作\n&quot;</span>,StaffInfo.name,StaffInfo.company.companyName)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 在 %s 工作&quot;</span>,StaffInfo.name,StaffInfo.companyName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ruojhen 在 Facebook 工作</span><br><span class="line">Ruojhen 在 Facebook 工作</span><br></pre></td></tr></table></figure><p>由此可见 <code>StaffInfo.company.companyName</code>与<code>StaffInfo.companyName</code>实现效果相同</p><h4 id="内部-外部"><a href="#内部-外部" class="headerlink" title="内部/外部"></a>内部/外部</h4><p>Go语言中 函数名的首字母大小写被用来实现控制函数的访问权限<br>函数首字母为大写时 这个函数对所有包都是Public<br>函数首字母为小写时 这个函数为Private 其他包无法访问这个函数</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口定义了一个对象的行为 即接口只说明了对象该做什么 而具体如何实现 则不关心 那需要对象自己本身去确定</p><h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><p>使用<code>type</code>+接口名+<code>interface</code>来定义接口 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中 定义了一个电话的接口 接口要求实现call函数</p><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>实现了某一接口中的所有方法 就称之为实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Apple <span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Apple)</span></span> call() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Apple is a phone)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="接口实现多态"><a href="#接口实现多态" class="headerlink" title="接口实现多态"></a>接口实现多态</h4><p>代码举例演示 先定义一个商品Good的接口 只要某个类型或结构体实现了接口Good内的<code>settleAccount()</code>和<code>orderInfo()</code> 这个类型或结构体就是一个Good</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Good <span class="keyword">interface</span> &#123;</span><br><span class="line">settleAccount() <span class="type">int</span></span><br><span class="line">orderInfo() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义两个结构体 手机 礼物</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">quantity <span class="type">int</span></span><br><span class="line">price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gift <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">quantity <span class="type">int</span></span><br><span class="line">price <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别为手机Phone和礼物Gift实现Good接口的两个函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span></span> settleAccount() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> phone.price * phone.quantity</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span></span> orderInfo() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;您要购买&quot;</span> + strconv.Itoa(phone.quantity) + <span class="string">&quot;个&quot;</span> + phone.name + <span class="string">&quot;共计:&quot;</span> + strconv.Itoa(phone.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift Gift)</span></span> settleAccount() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift Gift)</span></span> orderInfo() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;您要购买&quot;</span> + strconv.Itoa(gift.quantity) + <span class="string">&quot;个&quot;</span> + gift.name + <span class="string">&quot;共计:&quot;</span> + strconv.Itoa(gift.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这两个方法后 手机和礼物就是Good类型了<br>此时 创建两个商品的实例化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iPhone := Phone&#123;</span><br><span class="line">name: <span class="string">&quot;iPhone&quot;</span>,</span><br><span class="line">quantity: <span class="number">1</span>,</span><br><span class="line">price: <span class="number">8888</span>,</span><br><span class="line">&#125;</span><br><span class="line">earphones := Gift&#123;</span><br><span class="line">name: <span class="string">&quot;耳机&quot;</span>,</span><br><span class="line">quantity: <span class="number">1</span>,</span><br><span class="line">price: <span class="number">400</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个购物车 来存放这些商品 创建类型为Good的切片来作为购物车</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goods :=[]Good&#123;iPhone,earphones&#125;</span><br></pre></td></tr></table></figure><p>新建一个函数用来计算购物车内的订单金额</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">caculate</span><span class="params">(goods []Good)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> allPrice <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _,j := <span class="keyword">range</span> goods&#123;</span><br><span class="line">fmt.Println(j.orderInfo())</span><br><span class="line">allPrice += j.settleAccount()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> allPrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出订单总金额</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allPrice := caculate(goods)</span><br><span class="line">fmt.Println(<span class="string">&quot;订单共需要支付&quot;</span>,allPrice)</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Good <span class="keyword">interface</span> &#123;</span><br><span class="line">settleAccount() <span class="type">int</span></span><br><span class="line">orderInfo() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">quantity <span class="type">int</span></span><br><span class="line">price    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gift <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">quantity <span class="type">int</span></span><br><span class="line">price    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span></span> settleAccount() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> phone.price * phone.quantity</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone Phone)</span></span> orderInfo() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;您要购买&quot;</span> + strconv.Itoa(phone.quantity) + <span class="string">&quot;个&quot;</span> + phone.name + <span class="string">&quot;共计:&quot;</span> + strconv.Itoa(phone.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift Gift)</span></span> settleAccount() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gift Gift)</span></span> orderInfo() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;您要购买&quot;</span> + strconv.Itoa(gift.quantity) + <span class="string">&quot;个&quot;</span> + gift.name + <span class="string">&quot;共计:&quot;</span> + strconv.Itoa(gift.settleAccount()) + <span class="string">&quot;元&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">caculate</span><span class="params">(goods []Good)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> allPrice <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> _,j := <span class="keyword">range</span> goods&#123;</span><br><span class="line">fmt.Println(j.orderInfo())</span><br><span class="line">allPrice += j.settleAccount()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> allPrice</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">iPhone := Phone&#123;</span><br><span class="line">name: <span class="string">&quot;iPhone&quot;</span>,</span><br><span class="line">quantity: <span class="number">1</span>,</span><br><span class="line">price: <span class="number">8888</span>,</span><br><span class="line">&#125;</span><br><span class="line">earphones := Gift&#123;</span><br><span class="line">name: <span class="string">&quot;耳机&quot;</span>,</span><br><span class="line">quantity: <span class="number">1</span>,</span><br><span class="line">price: <span class="number">400</span>,</span><br><span class="line">&#125;</span><br><span class="line">goods :=[]Good&#123;iPhone,earphones&#125;</span><br><span class="line">allPrice := caculate(goods)</span><br><span class="line">fmt.Println(<span class="string">&quot;订单共需要支付&quot;</span>,allPrice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">您要购买1个iPhone共计:8888元</span><br><span class="line">您要购买1个耳机共计:0元</span><br><span class="line">订单共需要支付 8888</span><br></pre></td></tr></table></figure><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>空接口是特殊的接口 普通的接口内都有函数 但空接口内没有定义任何的函数</p><p>每一个接口都包含两个属性 一是接口值 二是接口类型<br>但对于空接口来说 这两者都是<code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;type: %T,value: %T&quot;</span>,i,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>: &lt;nil&gt;,value: &lt;nil&gt;</span><br></pre></td></tr></table></figure><h4 id="使用空接口"><a href="#使用空接口" class="headerlink" title="使用空接口"></a>使用空接口</h4><p>一 可以直接使用<code>interface&#123;&#125;</code>作为类型声明的一个实例 这个实例可以承载任何类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明一个空接口实例</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存 int 没有问题</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存字符串也没有问题</span></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存布尔值也没有问题</span></span><br><span class="line">i = <span class="literal">false</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二 希望函数可以接收任意类型的值 可以用空接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveValue</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10086</span></span><br><span class="line">b := <span class="string">&quot;Ruojhen&quot;</span></span><br><span class="line">c := <span class="literal">false</span></span><br><span class="line">receiveValue(a)</span><br><span class="line">receiveValue(b)</span><br><span class="line">receiveValue(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以一次接收人一个任意类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveValue</span><span class="params">(it ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _,i := <span class="keyword">range</span> it&#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10086</span></span><br><span class="line">b := <span class="string">&quot;Ruojhen&quot;</span></span><br><span class="line">c := <span class="literal">false</span></span><br><span class="line">receiveValue(a,b,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三 也可以定义一个可以接收任意类型的 数组 切片 哈希表 结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">any := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">5</span>)</span><br><span class="line">any[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">any[<span class="number">1</span>] = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">any[<span class="number">2</span>] = []<span class="type">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> any &#123;</span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">hello world</span><br><span class="line">[11 22 33 44]</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></table></figure><h4 id="使用空接口的注意事项"><a href="#使用空接口的注意事项" class="headerlink" title="使用空接口的注意事项"></a>使用空接口的注意事项</h4><p>一 可以将任何类型的值赋予给空接口 但反过来将一个空接口类型的变量赋予给一个固定类型的变量就不可以 Go禁止这种反向操作 底层原理之后再总结</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明a变量, 类型int, 初始值为1</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明i变量, 类型为interface&#123;&#125;, 初始值为a, 此时i的值变为1</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明b变量, 尝试赋值i</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台报错 cannot use i (type interface {}) as type int in assignment: need type assertion</p><p>二 当空接口被赋值数组或切片后  这个空接口类型的变量不能再被切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sli := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    i = sli</span><br><span class="line"></span><br><span class="line">    g := i[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台报错 cannot slice i (type interface {})</p><p>三 当使用空接口来接收任意类型的赋值的时候 这个空接口变量的静态类型是<code>interface&#123;&#125;</code> 但它的动态类型(int string ..) 并不清楚 所以需要类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 string&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    myfunc(a)</span><br><span class="line">    myfunc(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数的类型是 int<br>参数的类型是 string</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h4 id="Type-Assertion"><a href="#Type-Assertion" class="headerlink" title="Type Assertion"></a>Type Assertion</h4><p>类型断言 通常用来检查某个接口对象i是否为nil 或用来检查某个接口对象i是否为某个类型</p><p>第一种方式:写一段代码测试i是否为整型和字符型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">10</span></span><br><span class="line">t1 := i.(<span class="type">int</span>) <span class="comment">//判断i是否为int类型 </span></span><br><span class="line"><span class="comment">//若是int 就返回值给t1 若不是 触发panic</span></span><br><span class="line">fmt.Println(t1)</span><br><span class="line">fmt.Println(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line">t2 := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">---------</span><br><span class="line">panic: interface conversion: interface &#123;&#125; is int, not string</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">d:/Code/My Code/Golang/Hexomd/src/github.com/Ruojhen/hexomd01/test.go:13 +0x10e</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><p>可以发现在执行第二次断言的时候失败了 并且触发panic</p><p>下面测试若接口值为nil 观察是否也会触发panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; <span class="comment">//nil</span></span><br><span class="line">t1 := i.(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">fmt.Println(t1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface is nil, not interface &#123;&#125;</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">d:/Code/My Code/Golang/Hexomd/src/github.com/Ruojhen/hexomd01/test.go:10 +0x34</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><p>同样触发了panic</p><p>第二种方式:返回两个值<br>若断言成功 第一个值为返回类型 第二个值为true<br>若断言失败 不会触发panic 第二个值为false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">10</span></span><br><span class="line">t1, judge := i.(<span class="type">int</span>)</span><br><span class="line">fmt.Println(t1, <span class="string">&quot; - &quot;</span>, judge)</span><br><span class="line">fmt.Println(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"></span><br><span class="line">t2,judge := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(t2, <span class="string">&quot; - &quot;</span>, judge)</span><br><span class="line">fmt.Println(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">interface</span>&#123;&#125; <span class="comment">//nil</span></span><br><span class="line">t3,judge := j.(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">fmt.Println(t3, <span class="string">&quot; - &quot;</span>, judge)</span><br><span class="line">fmt.Println(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line">j = <span class="number">20</span></span><br><span class="line">t4,judge := j.(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">fmt.Println(t4, <span class="string">&quot; - &quot;</span>, judge)</span><br><span class="line">t5,judge :=j.(<span class="type">int</span>)</span><br><span class="line">fmt.Println(t5, <span class="string">&quot; - &quot;</span>, judge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10  -  <span class="literal">true</span></span><br><span class="line">----------</span><br><span class="line">  -  <span class="literal">false</span></span><br><span class="line">----------</span><br><span class="line">&lt;nil&gt;  -  <span class="literal">false</span></span><br><span class="line">----------</span><br><span class="line">20  -  <span class="literal">true</span></span><br><span class="line">20  -  <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>发现在执行第二次断言的时候 虽然失败 但是没有触发panic<br>值得注意的是 第二次断言失败 t2并不是没有输出值 而是因为断言失败 t2得到的是string的零值 即空字符串 因为是0长度的 所以看不到输出</p><h4 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h4><p>要对多个变量进行断言 使用type switch 更快速直接高效</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> x := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span> :</span><br><span class="line">fmt.Println(x,<span class="string">&quot;is int&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span> :</span><br><span class="line">fmt.Println(x,<span class="string">&quot;is string&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span> :</span><br><span class="line">fmt.Println(x,<span class="string">&quot;is nil&quot;</span>)</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">fmt.Println(<span class="string">&quot;It is not matched&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">returnType(<span class="number">10</span>)</span><br><span class="line">returnType(<span class="string">&quot;Ruojhen&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> k <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">returnType(k)</span><br><span class="line">returnType(<span class="number">3.14</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 is int</span><br><span class="line">Ruojhen is string</span><br><span class="line">&lt;nil&gt; is nil</span><br><span class="line">It is not matched</span><br></pre></td></tr></table></figure><h3 id="使用接口中的限制"><a href="#使用接口中的限制" class="headerlink" title="使用接口中的限制"></a>使用接口中的限制</h3><h4 id="对函数的调用限制"><a href="#对函数的调用限制" class="headerlink" title="对函数的调用限制"></a>对函数的调用限制</h4><p>接口是一组固定的函数集合 静态类型的限制 导致接口变量有时候仅能调用期中的一些特定的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone iPhone)</span></span>call()  &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, iPhone.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone iPhone)</span></span>send_wechat()  &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, Wechat.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line">    phone = iPhone&#123;name:<span class="string">&quot;ming&#x27;s iphone&quot;</span>&#125;</span><br><span class="line">    phone.call()</span><br><span class="line">    phone.send_wechat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在 <code>phone.send_wechat()</code>处会报错 提示Phone接口中无法找到<code>send_wechat()</code>  phone.send_wechat undefined (type Phone has no field or method send_wechat)</p><p>但我还想让phone可以调用<code>send_wechat()</code>  那就只能用不显示的声明为Phone接口类型</p><p>将<code>main()</code>中phone的声明变为隐式 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">phone := iPhone&#123;name: <span class="string">&quot;ming&#x27;s iphone&quot;</span>&#125;<span class="comment">//取消var声明 直接:=</span></span><br><span class="line">phone.call()</span><br><span class="line">phone.send_wechat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样修改后 运行一切正常<br>一定要清楚phone实际上是隐式的实现了Phone接口 这样函数的调用就不会受到接口类型的限制</p><h4 id="调用函数时的隐式转换"><a href="#调用函数时的隐式转换" class="headerlink" title="调用函数时的隐式转换"></a>调用函数时的隐式转换</h4><p>Go语言中的函数调用都是值传递的 变量会在调用前进行类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 string&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    printType(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后一切正常</p><p>做一些修改 将printType函数内的代码直接搬运到主函数中运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 string&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台报错 cannot type switch on non-interface value a (type int)</p><p>分析原因 Go语言中 空接口类型可以接收任意类型的赋值 其实背后过程中     Go语言会默默的替我们把传入参数的值隐式转换为接口类型 然后才赋值给空接口</p><p>所以要想使得修改后的代码可用 我们必须手动对a进行类型转换 给他转换成接口类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">interface</span>&#123;&#125;(a).(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;参数的类型是 string&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行才会正常</p><h4 id="类型断言中的隐式转换"><a href="#类型断言中的隐式转换" class="headerlink" title="类型断言中的隐式转换"></a>类型断言中的隐式转换</h4><p>因为只有静态类型为接口类型的对象变量才可以进行类型断言 </p><p>而当对某个接口类型断言完成后 会返回一个静态类型为这个接口接收的数据类型</p><h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>应该会有很多小伙伴在看到上一个类型断言隐式转换的内容时对变量动态类型和静态类型有点茫然 这个篇幅就好好的区分一下</p><h4 id="静态类型-static-type"><a href="#静态类型-static-type" class="headerlink" title="静态类型 (static type)"></a>静态类型 (static type)</h4><p>静态类型 即声明变量的时候的类型 需要注意的是 这个类型不是底层数据类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="type">int</span> <span class="comment">//静态类型为int</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> <span class="comment">//string是静态类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><p>尽管i j底层类型都是int 但i j的静态类型不同 除非进行类型转换 否则i和j不能互相赋值 j的静态类型就是MyInt</p><h4 id="动态类型-concrete-type"><a href="#动态类型-concrete-type" class="headerlink" title="动态类型 (concrete type)"></a>动态类型 (concrete type)</h4><p>动态类型 是程序运行时系统才能看见的类型</p><p>空接口可以承接任意类型的值 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; <span class="comment">//i的静态类型为 interface&#123;&#125;</span></span><br><span class="line">i = <span class="number">25</span>  <span class="comment">//i的静态类型为 interface&#123;&#125; i动态类型为int</span></span><br><span class="line">i = <span class="string">&quot;Ruojhen&quot;</span> <span class="comment">//i的静态类型为 interface&#123;&#125; i动态类型为string</span></span><br></pre></td></tr></table></figure><h4 id="接口组成"><a href="#接口组成" class="headerlink" title="接口组成"></a>接口组成</h4><p>每一个接口类型的变量 都由一对type data组成 记录着实际变量的类型和值</p><p>因此声明接口类型的变量也可以有多种方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">interface</span>&#123;&#125; = <span class="number">25</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type: %T data: %v&quot;</span>,age,age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := (<span class="type">int</span>)(<span class="number">25</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type: %T data: %v&quot;</span>,age,age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := (<span class="keyword">interface</span>&#123;&#125;)(<span class="number">25</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type: %T data: %v&quot;</span>,age,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果均为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>: int data: 25</span><br></pre></td></tr></table></figure><h4 id="接口细分"><a href="#接口细分" class="headerlink" title="接口细分"></a>接口细分</h4><p>根据接口中是否包含方法 将接口分为<code>iface</code>和<code>eface</code></p><h5 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h5><p><code>iface</code>表示带有一组函数的接口</p><p><code>iface</code>源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// 非空接口</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab   <span class="comment">//itab类型的指针</span></span><br><span class="line">    data unsafe.Pointer  <span class="comment">//数据指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空接口的类型信息</span></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype <span class="comment">// 接口定义的类型信息 即静态类型指针</span></span><br><span class="line">    _type  *_type <span class="comment">// 接口实际指向值的类型信息 即动态类型指针</span></span><br><span class="line">    link   *itab</span><br><span class="line">    bad    <span class="type">int32</span></span><br><span class="line">    inhash <span class="type">int32</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// 接口方法实现列表，即函数地址列表，按字典序排序  也称为fun方法集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/type.go</span></span><br><span class="line"><span class="comment">// 非空接口类型，接口定义，包路径等。</span></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">   typ     _type</span><br><span class="line">   pkgpath name</span><br><span class="line">   mhdr    []imethod <span class="comment">// 接口方法声明列表，按字典序排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口的方法声明</span></span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line">   name nameOff <span class="comment">// 方法名</span></span><br><span class="line">   ityp typeOff <span class="comment">// 描述方法参数返回值等细节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="eface"><a href="#eface" class="headerlink" title="eface"></a>eface</h5><p><code>eface</code>表示不带有函数的接口</p><p><code>eface1</code>源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type  </span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结动态类型"><a href="#总结动态类型" class="headerlink" title="总结动态类型"></a>总结动态类型</h4><p>在知道了何为动态类型 如何让一个对象拥有动态类型后<br>也知晓了两种接口的内部结构<br>那么做一个实验 在给一个空接口类型的变量赋值的时候 观察接口内部结构会发生什么变化</p><h5 id="iface-1"><a href="#iface-1" class="headerlink" title="iface"></a>iface</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reader io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">reader = tty</span><br></pre></td></tr></table></figure><p>由于io.Reader接口中包含Read() 所以io.Reader为iface类型的接口 所以此时reader的静态类型为io.Reader 暂无动态类型<br>之后声明了tty 为<em>os.File类型的实例 并且将tty的值赋予给了reader<br>所以此时reader的静态类型为io.Reader 动态类型为</em>os.File 数据指针为tty 这些静态类型指针和动态类型指针都存在iface的itab指针内</p><h5 id="eface-1"><a href="#eface-1" class="headerlink" title="eface"></a>eface</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">empty = tty</span><br></pre></td></tr></table></figure><p>因为interface{}是一个eface 且只有一个_type能存变量类型 所以empty的(静态)类型为nil<br>后将tty赋值给empty 此时empty的_type成为了*os.File 数据指针为tty</p><h4 id="引入反射"><a href="#引入反射" class="headerlink" title="引入反射"></a>引入反射</h4><p>由于动态类型的存在 在一个函数中接收的参数类型有可能无法预测 此时就需要反射机制 根据不同的类型做不同的处理 反射的内容将放置在 <a href="">Go反射</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ sets of issues</title>
      <link href="/2021/02/28/C-sets-of-issues/"/>
      <url>/2021/02/28/C-sets-of-issues/</url>
      
        <content type="html"><![CDATA[<h1 id="C-sets-of-issues"><a href="#C-sets-of-issues" class="headerlink" title="C++ sets of issues"></a>C++ sets of issues</h1><p>收录StackOverflow上cpp答疑</p><p>vscode clang_format_style</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>BasedOnStyle<span class="punctuation">:</span> Google <span class="punctuation">,</span> IndentWidth<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> AllowShortFunctionsOnASingleLine<span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> AccessModifierOffset<span class="punctuation">:</span> <span class="number">-4</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><span id="more"></span> <h2 id="001-为什么不建议直接使用-using-namespace-std"><a href="#001-为什么不建议直接使用-using-namespace-std" class="headerlink" title="001 为什么不建议直接使用 using namespace std"></a>001 为什么不建议直接使用 using namespace std</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有人告诉我在代码里直接使用<code>using namespace std;</code>不是一个好习惯  应该用 <code>std::cout</code> <code>std::cin</code>等来代替<br>为什么不好呢 是影响性能还是命名空间冲突呢</p><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><p>命名冲突 与性能无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bar;</span><br></pre></td></tr></table></figure><p>不管是调用<code>foo</code>里的函数<code>Blah()</code> 还是调用<code>bar</code>里的<code>Quux()</code> 都没啥问题<br>然后有一天你的库foo要升级了 里边新加了一个函数<code>Quux()</code> 这样就出现问题了 因为它和命名空间<code>bar</code>里的<code>Quux()</code>冲突了<br>想一想 如果很多函数名都冲突了 你是不是得一个一个去解决 费时费力<br>所以如果你当初没有全局导入这些名称 而是直接调用的foo::Blah() bar::Quux() foo::Quux() 那么这些问题就都不存在了<br>因此 不建议全局导入命名空间 而是你要用到哪个就显示指定哪个命名空间 这样的代码本身阅读性也更好</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Bug</title>
      <link href="/2020/10/23/Hexo-Bug/"/>
      <url>/2020/10/23/Hexo-Bug/</url>
      
        <content type="html"><![CDATA[<p>2022-03 已修复</p><p>在书写markdown数学公式的时候 习惯性的使用<code>｛｝</code>中同一类型运算下的公式括起来 导致有两个同侧括号在一起 导致Hexo生成HTML的时候无法解析<code>｝</code><br>生成的bug提示如下</p><span id="more"></span> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">Template render error: (unknown path) [Line 8, Column 322]</span></span><br><span class="line"><span class="string">  parseAggregate: expected comma after expression</span></span><br><span class="line"><span class="string">    at Object._prettifyError (D:\Code\My Code\blog\node_modules\nunjucks\src\lib.js:36:11)</span></span><br><span class="line"><span class="string">    at Template.render (D:\Code\My Code\blog\node_modules\nunjucks\src\environment.js:526:21)</span></span><br><span class="line"><span class="string">    at Environment.renderString (D:\Code\My Code\blog\node_modules\nunjucks\src\environment.js:364:17)</span></span><br><span class="line"><span class="string">    at D:\Code\My Code\blog\node_modules\hexo\lib\extend\tag.js:62:48</span></span><br><span class="line"><span class="string">    at tryCatcher (D:\Code\My Code\blog\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Function.Promise.fromNode.Promise.fromCallback (D:\Code\My Code\blog\node_modules\bluebird\js\release\promise.js:180:30)</span></span><br><span class="line"><span class="string">    at Tag.render (D:\Code\My Code\blog\node_modules\hexo\lib\extend\tag.js:62:18)</span></span><br><span class="line"><span class="string">    at Object.onRenderEnd (D:\Code\My Code\blog\node_modules\hexo\lib\hexo\post.js:282:20)</span></span><br><span class="line"><span class="string">    at D:\Code\My Code\blog\node_modules\hexo\lib\hexo\render.js:65:19</span></span><br><span class="line"><span class="string">    at tryCatcher (D:\Code\My Code\blog\node_modules\bluebird\js\release\util.js:16:23)</span></span><br><span class="line"><span class="string">    at Promise._settlePromiseFromHandler (D:\Code\My Code\blog\node_modules\bluebird\js\release\promise.js:512:31)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise (D:\Code\My Code\blog\node_modules\bluebird\js\release\promise.js:569:18)</span></span><br><span class="line"><span class="string">    at Promise._settlePromise0 (D:\Code\My Code\blog\node_modules\bluebird\js\release\promise.js:614:10)</span></span><br><span class="line"><span class="string">    at Promise._settlePromises (D:\Code\My Code\blog\node_modules\bluebird\js\release\promise.js:694:18)</span></span><br><span class="line"><span class="string">    at _drainQueueStep (D:\Code\My Code\blog\node_modules\bluebird\js\release\async.js:138:12)</span></span><br><span class="line"><span class="string">    at _drainQueue (D:\Code\My Code\blog\node_modules\bluebird\js\release\async.js:131:9)</span></span><br><span class="line"><span class="string">    at Async._drainQueues (D:\Code\My Code\blog\node_modules\bluebird\js\release\async.js:147:5)</span></span><br><span class="line"><span class="string">    at Immediate.Async.drainQueues (D:\Code\My Code\blog\node_modules\bluebird\js\release\async.js:17:14)</span></span><br><span class="line"><span class="string">    at processImmediate (internal/timers.js:439:21)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathematical Formulas</title>
      <link href="/2020/10/21/Mathematical-Formulas/"/>
      <url>/2020/10/21/Mathematical-Formulas/</url>
      
        <content type="html"><![CDATA[<p>theme/next下_config.yml中<code> mathjax: enable: true</code>要开启</p><h1 id="自记常考数学公式"><a href="#自记常考数学公式" class="headerlink" title="自记常考数学公式"></a>自记常考数学公式</h1><h2 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h2><h3 id="均值不等式"><a href="#均值不等式" class="headerlink" title="均值不等式"></a>均值不等式</h3><p><b>均方根QM</b>:  $\sqrt{\cfrac{x_{1}^2+\cdot\cdot\cdot+x_{n}^2}{n}}$</p><p><b>算术平均AM</b>: $\cfrac{x_1 + \cdot\cdot\cdot + x_n}{n}$</p><p><b>几何平均GM</b>: $\sqrt[n]{x_1 \cdot\cdot\cdot x_n}$</p><p><b>调和平均HM</b>: $\cfrac{n}{\cfrac{1}{x_1}+\cdot\cdot\cdot+\cfrac{1}{x_n}}$</p><span id="more"></span> <p>存在 均方根QM $\geq$ 算术平均AM $\geq$ 几何平均GM $\geq$ 调和平均HM</p><p>$$ \sqrt{\cfrac{x_{1}^2+\cdot\cdot\cdot+x_{n}^2}{n}} \geq \cfrac{x_1 + \cdot\cdot\cdot + x_n}{n} \geq \sqrt[n]{x_1 \cdot\cdot\cdot x_n} \geq \cfrac{n}{\cfrac{1}{x_1}+\cdot\cdot\cdot+\cfrac{1}{x_n}}$$<br>当且仅当$x_1=x_2= \cdot\cdot\cdot =x_n$时  等号成立</p><h3 id="三角不等式"><a href="#三角不等式" class="headerlink" title="三角不等式"></a>三角不等式</h3><h4 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h4><p>$n$维向量$x=(x_1,\cdot\cdot\cdot,x_n) y=(y_1,\cdot\cdot\cdot,y_n)$ 因为两边之和一定大于第三边 所以成立<br>$||x|-|y|| \leq |x \pm y| \leq |x|+|y|$ 当且仅当 $x||y$ (xy平行)的时候才成立<br>即: $$\sqrt{(x_1 \pm y_1)^2+\cdot\cdot\cdot+(x_n \pm y_n)^2} \leq \sqrt{x_{1}^2+\cdot\cdot\cdot+x_{n}^2}+\sqrt{y_{1}^2+\cdot\cdot\cdot+y_{n}^2}$$<br>$$\sqrt{(x_1 \pm y_1)^2+\cdot\cdot\cdot+(x_n \pm y_n)^2} \geq |\sqrt{x_{1}^2+\cdot\cdot\cdot+x_{n}^2}-\sqrt{y_{1}^2+\cdot\cdot\cdot+y_{n}^2}|$$</p><h4 id="1维特别形式"><a href="#1维特别形式" class="headerlink" title="1维特别形式"></a>1维特别形式</h4><p>当$n$维向量的维数n=1时 有<br>$$||a|-|b|| \leq |a+b| \leq |a|+|b|$$ 左处等号当且仅当$ab \leq 0$时成立 右处等号当且仅当$ab \geq 0$时成立</p><p>$$||a|-|b|| \leq |a-b| \leq |a|+|b|$$ 左处等号当且仅当$ab \geq 0$时成立 右处等号当且仅当$ab \leq 0$时成立</p><h3 id="基本初等函数不等式"><a href="#基本初等函数不等式" class="headerlink" title="基本初等函数不等式"></a>基本初等函数不等式</h3><p>$\cfrac{x}{1+x} \leq \ln(1+x) \leq x  \forall x&gt;-1$</p><p>$\sin{x} \leq x \leq \tan{x}$</p><p>$e^x \geq x+1$</p><h3 id="柯西不等式"><a href="#柯西不等式" class="headerlink" title="柯西不等式"></a>柯西不等式</h3><h4 id="离散形式"><a href="#离散形式" class="headerlink" title="离散形式"></a>离散形式</h4><p>$$<br>(\sum_{i=1}^{n}a_ib_i)^2 \leq (\sum_{i=1}^{n}a_i^{2})(\sum_{i=1}^{n}b_i^{2})<br>$$<br>当且仅当$a_i=kb_i$时等号成立</p><h4 id="连续形式"><a href="#连续形式" class="headerlink" title="连续形式"></a>连续形式</h4><p>$$<br>(\int_{a}^{b} f(x)g(x)\mathrm{d}x)^2 \leq \int_{a}^{b}f^2(x)\mathrm{d}x\int_{a}^{b}g^2(x)\mathrm{d}x<br>$$</p><p>当且仅当存在常数k使得$f(x)=kg(x)$成立</p><h4 id="多元形式"><a href="#多元形式" class="headerlink" title="多元形式"></a>多元形式</h4><p>$$<br>(\iint_{D} f(x,y)g(x,y)\mathrm{d}\sigma)^2 \leq (\iint_{D} f^2(x,y)\mathrm{d}\sigma)(\iint_{D} g^2(x,y)\mathrm{d}\sigma)<br>$$</p><h3 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h3><p>$$<br>对于x_1 \geq x_2 \geq \cdot\cdot\cdot \geq x_n 和 y_1 \geq y_2 \geq \cdot\cdot\cdot \geq y_n 存在不等式:<br>$$</p><p>顺序和 $\geq$ 乱序和 $\geq$ 逆序和</p><p>$$<br>x_1y_1+x_2y_2+\cdot\cdot\cdot+x_ny_n \geq \cfrac{1}{n}(x_1+x_2+\cdot\cdot\cdot+x_n)(y_1+y_2+\cdot\cdot\cdot+y_n) \geq x_1y_n+x_2y_{n-1}+\cdot\cdot\cdot+x_ny_1<br>$$</p><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="行列式抽象计算"><a href="#行列式抽象计算" class="headerlink" title="行列式抽象计算"></a>行列式抽象计算</h3><p>涉及到n阶行列式A A的逆矩阵 A的伴随矩阵<br>$$<br>|AB|=|A||B|<br>$$</p><p>$$<br>AA^{\ast}=A^{\ast}A=|A|E \qquad |A||A^{\ast}|=|A|^n|E|<br>$$</p><p>$$<br>|A^{\ast}|=|A|^{n-1}<br>$$</p><p>$$<br>A^{\ast}=|A|A^{-1}<br>$$</p><p>$$<br>|A^{-1}|=\frac{1}{|A|}<br>$$</p><p>n阶行列式A的特征值$\lambda_{1} \dots \lambda_{n}$ </p><p>$$<br>|A|=\sum_{i=1}^{n}\lambda_{i}<br>$$</p><p>行列式的迹 以三阶行列式为例 $a_{11}+a_{22}+a_{33}=\lambda_{1}+\lambda_{2}+\lambda_{3}$</p><p>A B 相似 则有$P^{-1}AP=B$</p><p>$$<br>|P^{-1}AP|=|P^{-1}||A||P|=|B| \implies A B相似 则|A|=|B|<br>$$</p><h3 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h3><p>$$<br>(A^{-1})^{-1}=A<br>$$</p><p>$$<br>(AB)^{-1}=B^{-1}A^{-1}<br>$$</p><p>$$<br>(A^2)^{-1}=(A^{-1})^2<br>$$</p><p>$$<br>(kA)^{-1}=\frac{1}{k}A^{-1}<br>$$</p><p>$$<br>(A^{-1}+B^{-1})^{-1}=(EA^{-1}+B^{-1}E)^{-1}=(B^{-1}BA^{-1}+B^{-1}AA^{-1})^{-1}<br>$$</p><p>$$<br>=(B^{-1}(B+A)A^{-1})^{-1}=A(A+B)^{-1}B<br>$$</p><h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><p>$AA^T=A^TA=E$ 则称A为正交矩阵 $A^T=A^{-1} \implies |A|=1 \quad or \quad |A|=-1$</p><p>正交矩阵的列向量必须互相垂直 且都为单位向量</p><p>A B都为正交矩阵 且$|A|+|B|=0$ 则 $|A+B|=0$</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Morris遍历二叉树</title>
      <link href="/2020/09/24/Morris%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/09/24/Morris%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Morris"><a href="#Morris" class="headerlink" title="Morris"></a>Morris</h1><p>本篇文章为<a href="https://shaoyuanhangyes.github.io/2020/06/03/Binary-Tree/#more">Binary-Tree</a>中遍历二叉树的进阶版本</p><p>二叉树的普通遍历有递归和迭代的方式 递归会有递归空间开销 迭代会有通过栈实现的空间开销 而Morris遍历可以将非递归遍历中的<b>空间复杂度降为O(1)</b> 利用的则是二叉树中大量的叶结点的左右孩子为空(空闲指针) 来实现的极限缩减空间 思想与线索二叉树很像 但不像线索二叉树一样需要开辟两个指针域</p><span id="more"></span> <h2 id="Morris遍历规则"><a href="#Morris遍历规则" class="headerlink" title="Morris遍历规则"></a>Morris遍历规则</h2><p>当前结点为cur </p><p>若cur无左孩子 <code>cur=cur-&gt;right</code> </p><p>若cur有左孩子 则找到cur的左子树上最右侧的结点 记为mostright mostright初值为cur-&gt;left 循环找到最右侧结点再停止<br>    若mostright-&gt;right=NULL 就使mostright-&gt;right=cur 并同时cur=cur-&gt;left<br>    若mostright-&gt;right=cur 就使mostright-&gt;right=NULL 并同时cur=cur-&gt;right</p><p>从结果上来观察 这个mostright结点是cur结点的前驱结点时 cur就借由这个前驱结点的桥梁回到上一个遍历点</p><h2 id="Morris遍历实例"><a href="#Morris遍历实例" class="headerlink" title="Morris遍历实例"></a>Morris遍历实例</h2><p>针对层序遍历结构为{1,2,3,4,5,-1,6}的二叉树实例 来进行Morris遍历</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br></pre></td></tr></table></figure><p>Ⅰ cur=1 存在左孩子 cur左子树上最右侧的结点为5 则mostright=5 并且5-&gt;right=NULL 所以使5-&gt;right=cur=1 同时 cur=cur-&gt;left=2</p><p>Ⅱ cur=2 存在左孩子 cur左子树上最右侧的结点为4 则mostright=4 并且4-&gt;right=NULL 所以使得4-&gt;right=cur=2 同时 cur=cur-&gt;left=4</p><p>Ⅲ cur=4 不存在左孩子 所以cur=cur-&gt;right <b>此时4-&gt;right=2</b> 即cur=2</p><p>Ⅳ cur=2 存在左孩子 cur左子树上最右侧的结点为4 则mostright=4 此时4-&gt;right=2 所以使得4-&gt;right=NULL 同时cur=cur-&gt;right=5</p><p>Ⅴ cur=5 不存在左孩子 所以cur=cur-right <b>此时5-&gt;right=1</b> 即cur=1</p><p>Ⅵ cur=1 存在左孩子 cur左子树上最右侧的结点为5 则mostright=5 并且5-&gt;right=1 所以使5-&gt;right=NULL 同时cur=cur-&gt;right=3</p><p>Ⅶ cur=3 不存在左孩子 cur=cur-&gt;right=6</p><p>Ⅷ cur=6 不存在左孩子 结点遍历完毕</p><h2 id="Morris遍历代码"><a href="#Morris遍历代码" class="headerlink" title="Morris遍历代码"></a>Morris遍历代码</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Morris_preOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    TreeNode* cur=root;</span><br><span class="line">    TreeNode* mostright=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        mostright=cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(mostright!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(mostright-&gt;right!=<span class="literal">NULL</span>&amp;&amp;mostright-&gt;right!=cur) mostright=mostright-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(mostright-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                mostright-&gt;right=cur;</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);<span class="comment">//先序遍历是在向左孩子移动前输出结点值</span></span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mostright-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        cur=cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Morris_inOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    TreeNode* cur=root;</span><br><span class="line">    TreeNode* mostright=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        mostright=cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(mostright!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(mostright-&gt;right!=<span class="literal">NULL</span>&amp;&amp;mostright-&gt;right!=cur) mostright=mostright-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(mostright-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                mostright-&gt;right=cur;</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mostright-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//res.push_back(cur-&gt;val);//中序遍历是在要回溯到上一个结点之前将结点值输出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//else res.push_back(cur-&gt;val);</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        cur=cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 中序遍历代码中的注释 是第一次设计Morris中序遍历时写的代码 对于结点的输出情况 虽然结果相同 但是代码结构上多余了一个else的判断后输出 过于冗余 因此进行修改  但是第一次设计的代码虽然冗余但更为易读 所以以注释的形式保留下来</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostOrder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reverseEdge</span><span class="params">(TreeNode* root)</span></span>&#123;<span class="comment">//使一串右子树的结点逆序</span></span><br><span class="line">        TreeNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next=root-&gt;right;</span><br><span class="line">            root-&gt;right=pre;</span><br><span class="line">            pre=root;</span><br><span class="line">            root=next;</span><br><span class="line">        &#125;<span class="comment">//一顿操作下来树结构 pre-&gt;right=root</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printEdge</span><span class="params">(TreeNode* root)</span></span>&#123;<span class="comment">//打印结点</span></span><br><span class="line">        TreeNode* tail=<span class="built_in">reverseEdge</span>(root);</span><br><span class="line">        TreeNode* cur=tail;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverseEdge</span>(tail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Morris_postOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        TreeNode* mostright=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            mostright=cur-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(mostright!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(mostright-&gt;right!=<span class="literal">NULL</span>&amp;&amp;mostright-&gt;right!=cur) mostright=mostright-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(mostright-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    mostright-&gt;right=cur;</span><br><span class="line">                    cur=cur-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    mostright-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">                    <span class="built_in">printEdge</span>(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printEdge</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    TreeNode* root=<span class="built_in">createTree</span>(nums,nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">    PostOrder ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res=ans.<span class="built_in">Morris_postOrder</span>(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:res) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fibnacci Sequence</title>
      <link href="/2020/07/22/Fibnacci-Sequence/"/>
      <url>/2020/07/22/Fibnacci-Sequence/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>学习动态规划的时候见到了一个词语 叫做记忆化搜索 用于递归的<code>剪枝</code> 用空间的增大来换取时间的压缩 </p><p>下面是关于斐波那契数列的代码例子 </p><span id="more"></span> <h3 id="传统递归"><a href="#传统递归" class="headerlink" title="传统递归"></a>传统递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">f</span>(n<span class="number">-1</span>)+<span class="built_in">f</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">f</span>(n);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统递归的弊端就是会重复计算 例如我要计算f(5)=f(4)+f(3) 计算f(4)的时候又要在计算一遍f(3) 因此采用记忆化搜索来防止这些重复计算来提高速度</p><h3 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">100</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(MAX,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[n]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[n];<span class="comment">//如果数组表内元素已经更新了 我们就不需要再次计算直接拿来用就可以</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    dp[n]=<span class="built_in">f</span>(n<span class="number">-1</span>)+<span class="built_in">f</span>(n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(n)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) cout&lt;&lt;<span class="string">&quot;dp[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]=&quot;</span>&lt;&lt;dp[i]&lt;&lt;endl;<span class="comment">//我使用Clion调试的不能显示全局变量的值 只能直接print出来观察</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试 例如输入f(44)计算的时候 记忆化搜索的速度明显比传统递归的速度要快的多</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>我在查阅资料的时候发现很多人说还能再提升速度 使用矩阵乘法的方式 有时间我会更新此篇文章 加上速度更快的方法</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基本语法</title>
      <link href="/2020/07/19/Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/07/19/Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go基本语法"><a href="#Go基本语法" class="headerlink" title="Go基本语法"></a>Go基本语法</h1><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><ol><li>必须是main包 <code>package main</code></li><li>必须是main方法 <code>func main()</code></li><li>文件名不一定是<code>main.go</code></li><li>文件夹名不一定是<code>main</code></li></ol><h2 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h2><p>Go语言的main函数不支持任何返回值 因此<code>return</code>是不可以使用的<br>通过使用<code>os.Exit()</code>来返回状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h2><p>Go语言的main函数不支持传入参数 在程序中直接通过<code>os.Args</code>获取命令行参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(as.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;It&#x27;s&quot;</span>, os.Args[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接声明</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Ruojhen&quot;</span></span><br><span class="line"><span class="keyword">var</span> id <span class="type">int</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;shaoyuanhang@outlook.com&quot;</span> <span class="comment">//不指定类型声明 靠编译器自动识别</span></span><br><span class="line"><span class="comment">/*但编译器自动识别会产生我们不需要的效果 例如: */</span></span><br><span class="line"><span class="keyword">var</span> decimal = <span class="number">0.06</span> <span class="comment">//因为右值带有小数点 所以在不指定类型的情况下 编译器将这个变量声明为float64 但很多时候我们不需要这么高的精度 因为高精度意味着占用内存空间就更大</span></span><br><span class="line"><span class="keyword">var</span> decimal <span class="type">float32</span> = <span class="number">0.03</span></span><br><span class="line"><span class="comment">/*以上声明方式可以不赋予变量值 这样变量就会被初始化为初值 string就是空字符串 int就是0 float32/float64就是0.0 bool就是false 指针就是nil*/</span></span><br></pre></td></tr></table></figure><span id="more"></span> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个变量一起声明 只能用于函数内部</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">id <span class="type">int</span> =<span class="number">132456</span></span><br><span class="line">name = <span class="string">&quot;syh&quot;</span></span><br><span class="line">gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">)</span><br><span class="line">    fmt.Print(id,name,gender)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//打印结果为 132456syh男</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速初始化变量</span></span><br><span class="line">name:=<span class="string">&quot;syh&quot;</span> <span class="comment">/*效果等价于*/</span>  <span class="keyword">var</span> name = <span class="string">&quot;syh&quot;</span> <span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;syh&quot;</span></span><br><span class="line"></span><br><span class="line">id,name:= <span class="number">123</span>,<span class="string">&quot;syh&quot;</span> <span class="comment">//相当于将123赋值给id &quot;syh&quot;赋值给name</span></span><br><span class="line"><span class="comment">/*这个方法还能用于交换两个数*/</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> =<span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> =<span class="number">200</span></span><br><span class="line">b,a=a,b</span><br><span class="line">fmt.Print(a,<span class="string">&quot; &quot;</span>,b)<span class="comment">//输出结果为 200 100</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明指针变量</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span> =<span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> address  =&amp;age</span><br><span class="line">fmt.Print(age,<span class="string">&quot; &quot;</span>,address)<span class="comment">//输出结果为 100 0xc00000a0c8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new函数声明匿名变量</span></span><br><span class="line">ptr:=<span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;ptr address&quot;</span>,ptr) <span class="comment">//ptr address 0xc0000a0090</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ptr value&quot;</span>,*ptr)  <span class="comment">//ptr value 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*所谓匿名变量 又称作占位符 空白标识符 在代码中我们使用下划线代替他 </span></span><br><span class="line"><span class="comment">表示一些我们在函数返回值中必须要接收 但以后却用不到的值  匿名变量优点</span></span><br><span class="line"><span class="comment">: Ⅰ不分配内存空间 Ⅱ不需要为命名无用的变量名纠结 Ⅲ多次声明不会有任何问题</span></span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>三个环境变量 GOROOT GOPATH GOBIN<br>    GOROOT Go语言的安装路径<br>    GOPATH 若干工作区目录的路径 是自己定义的工作空间<br>    GOBIN  Go程序生成的可执行文件的路径</p><p>其中 GOPATH的概念最多 GOPATH的意义也是被询问的最多的</p><p>回答是: 可以把GOPATH简单理解成Go语言的工作目录 GOPATH的值是一个目录的路径<br>每个目录都代表Go语言的一个工作区<br>利用工作区下的文件夹src去存放源码文件(<strong>.go)<br>pkg存放平台相关目录(linux_amd64)内存放归档文件(</strong>.a)<br>bin存可执行文件(**.exe)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">归档文件就是在linux下是.a的文件 是archive文件 是程序编译后生成的静态库文件</span><br><span class="line">与Java的jar包不同 jar属于动态链接库</span><br></pre></td></tr></table></figure><h3 id="Go命令"><a href="#Go命令" class="headerlink" title="Go命令"></a>Go命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build   <span class="comment">#编译程序并生成二进制可执行文件 但不会运行程序</span></span><br><span class="line">go run     <span class="comment">#编译并运行程序 但不会生成二进制可执行文件</span></span><br><span class="line">go install <span class="comment">#编译应用 生成二进制文件 并将其移动到$GOBIN目录中 也不会运行程序</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="fmt输出格式"><a href="#fmt输出格式" class="headerlink" title="fmt输出格式"></a>fmt输出格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%b    表示为二进制</span><br><span class="line">%c    该值对应的unicode码值</span><br><span class="line">%d    表示为十进制</span><br><span class="line">%o    表示为八进制</span><br><span class="line">%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</span><br><span class="line">%x    表示为十六进制，使用a-f</span><br><span class="line">%X    表示为十六进制，使用A-F</span><br><span class="line">%U    表示为Unicode格式：U+1234，等价于<span class="string">&quot;U+%04X&quot;</span></span><br><span class="line">%E    用科学计数法表示</span><br><span class="line">%f    用浮点数表示</span><br></pre></td></tr></table></figure><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p><code>int</code> <code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code> 有符号整型<br><code>uint</code> <code>uint8</code> <code>uint16</code> <code>uint32</code> <code>uint64</code> 无符号整型</p><h4 id="不同进制整型表示"><a href="#不同进制整型表示" class="headerlink" title="不同进制整型表示"></a>不同进制整型表示</h4><p>十进制 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>二进制 0b前缀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num01 <span class="type">int</span> = <span class="number">0</span>b1100</span><br></pre></td></tr></table></figure><p>八进制 0o前缀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num02 <span class="type">int</span> = <span class="number">0</span>o14</span><br></pre></td></tr></table></figure><p>十六进制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num03 <span class="type">int</span> <span class="number">0xC</span></span><br></pre></td></tr></table></figure><p>输出格式对比</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> num01 <span class="type">int</span> = <span class="number">0</span>b1100</span><br><span class="line">    <span class="keyword">var</span> num02 <span class="type">int</span> = <span class="number">0</span>o14</span><br><span class="line">    <span class="keyword">var</span> num03 <span class="type">int</span> = <span class="number">0xC</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;2进制数 %b 表示的是: %d \n&quot;</span>, num01, num01)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;8进制数 %o 表示的是: %d \n&quot;</span>, num02, num02)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;16进制数 %X 表示的是: %d \n&quot;</span>, num03, num03)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型表示有两种表示方法 以0.037为例 可以直接用<code>0.037</code> 亦或使用<code>3.7E-2</code>表示0.037 同理<code>3.7E+1 = 37</code><br>有时候浮点型类型值可以被简化 <code>37.0</code>可以简化为<code>37</code> <code>0.037</code>可以简化为<code>.037</code><br>浮点数的整数部分和小数部分只能由十进制表示 </p><p>Go提供了两种精度的浮点数<code>float32</code> <code>float64</code></p><p><code>float32</code> 单精度 存储占用4个字节 32位<br><code>float64</code> 双精度 存储占用8个字节 64位</p><h3 id="byte-rune"><a href="#byte-rune" class="headerlink" title="byte/rune"></a>byte/rune</h3><h4 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h4><p><code>byte</code> 占用一个字节 8个比特位 2^8=256 所以<code>byte</code>类型的范围是 0-255 和<code>uint8</code>本质上没有区别 <code>byte</code>表示的是ACSII表中的一个字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">byte</span> = <span class="number">65</span></span><br><span class="line">    <span class="comment">// 8进制写法: var a byte = &#x27;\101&#x27;     其中 \ 是固定前缀</span></span><br><span class="line">    <span class="comment">// 16进制写法: var a byte = &#x27;\x41&#x27;    其中 \x 是固定前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">66</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a 的值: %c \nb 的值: %c&quot;</span>, a, b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用 string 函数</span></span><br><span class="line">    <span class="comment">// fmt.Println(&quot;a 的值: &quot;, string(a),&quot; \nb 的值: &quot;, string(b))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 的值: A</span><br><span class="line">b 的值: B</span><br></pre></td></tr></table></figure><p>在 ASCII 表中，由于字母 A 的ASCII 的编号为 65 字母 B 的ASCII 编号为 66 所以上面的代码也可以写成这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">byte</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a 的值: %c \nb 的值: %c&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h4><p><code>rune</code> 占用四个字节 32个比特位 所以和<code>uint32</code>本质上没有区别 <code>rune</code>表示的是一个Unicode字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">byte</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">rune</span> = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a 占用 %d 个字节数\nb 占用 %d 个字节数&quot;</span>, unsafe.Sizeof(a), unsafe.Sizeof(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 占用 1 个字节数</span><br><span class="line">b 占用 4 个字节数</span><br></pre></td></tr></table></figure><p>表示中文字符要用rune类型 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">rune</span> = <span class="string">&#x27;简&#x27;</span></span><br></pre></td></tr></table></figure><p>既然 <code>byte</code> 和 <code>uint8</code> 没有区别 <code>rune</code> 和 <code>uint32</code> 没有区别 那为何还要多设置这两个类型呢 </p><p>因为<code>uint8</code> <code>uint32</code> 直观上让人理解为这是一个整型变量 是一个数值  但实际上它也可以表示一个字符 为了消除这个直观错觉<br>应运而生了<code>byte</code> <code>rune</code></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mystr <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>byte</code>和<code>rune</code>都是字符类型 多个字符放在一起就组成了字符串 即<code>string</code></p><p>hello在ASCII表中对应的数字分别是 104 101 108 108 111</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mystr01 <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">var</span> mystr02 [<span class="number">5</span>]<span class="type">byte</span> = [<span class="number">5</span>]<span class="type">byte</span>&#123;<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;mystr01: %s\n&quot;</span>, mystr01)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;mystr02: %s&quot;</span>, mystr02)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mystr01: hello</span><br><span class="line">mystr02: hello</span><br></pre></td></tr></table></figure><p>mystr01 mystr02输出内容一样 说明<code>string</code>的本质是<code>byte</code>数组</p><p>Go语言的<code>string</code>使用utf-8进行编码 英文字母占1个字节 中文汉字占3个字节</p><p>字符串不仅仅可以使用双引号来表示 还可以使用反引号 反引号通常应用于存在转移字符<code>\</code>的情况下 </p><p>被反引号包裹的字符串会被忽略掉其中的转义字符 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mystr01 <span class="type">string</span> = <span class="string">&quot;\\r\\n&quot;</span></span><br><span class="line"><span class="keyword">var</span> mystr02 <span class="type">string</span> = <span class="string">`\r\n`</span></span><br></pre></td></tr></table></figure><p>这两个字符串的打印结果都是<code>\r\n</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mystr01 <span class="type">string</span> = <span class="string">`\r\n`</span></span><br><span class="line">    fmt.Printf(<span class="string">`\r\n`</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;的解释型字符串是： %q&quot;</span>, mystr01)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\r\n的解释型字符串是： <span class="string">&quot;\\r\\n&quot;</span></span><br></pre></td></tr></table></figure><p>同时反引号可以不写换行符\n来表示一个多行的字符串 因为换行符会被忽略掉</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mystr01 <span class="type">string</span> = <span class="string">`Hello</span></span><br><span class="line"><span class="string">Shaoyuanhangyes Ruojhen`</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(mystr01)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">Shaoyuanhangyes Ruojhen</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>] = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br></pre></td></tr></table></figure><p>3表示数组元素个数 可以使用<code>...</code>来让系统自己根据实际情况来分配空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是 <code>[3]int</code> <code>[4]int</code>虽然都是数组 但类型却不同 使用fmt的<code>%T</code>来查得</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr01 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    arr02 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d 的类型是: %T\n&quot;</span>, arr01, arr01)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d 的类型是: %T&quot;</span>, arr02, arr02)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3] 的类型是: [3]int</span><br><span class="line">[1 2 3 4] 的类型是: [4]int</span><br></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>使用关键字<code>type</code>来起别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> arr3 [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    myarr := arr3&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d 的类型是: %T&quot;</span>, myarr, myarr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3] 的类型是: main.arr3</span><br></pre></td></tr></table></figure><h4 id="只初始化部分位置"><a href="#只初始化部分位置" class="headerlink" title="只初始化部分位置"></a>只初始化部分位置</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>:<span class="number">3</span>&#125; <span class="comment">//表示的数组内有4个元素 索引为2的位置的值为3 其余未指定初值的为0</span></span><br></pre></td></tr></table></figure><p>打印arr的结果为 [0 0 3 0]</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片是对数组的一个连续片段的引用 所以切片是一个引用类型 这个片段可以是整个数组 也可以是数组的子集 但这个片段是一个左闭右开的区间</p><p>即终止索引对应的项不在这个片段中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myarr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d 的类型是: %T&quot;</span>, myarr[<span class="number">0</span>:<span class="number">2</span>], myarr[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2] 的类型是: []int</span><br></pre></td></tr></table></figure><p>切片是引用类型 所以未给予初值的切片的默认值是nil</p><h4 id="切片构造方式"><a href="#切片构造方式" class="headerlink" title="切片构造方式"></a>切片构造方式</h4><h5 id="对数组进行片段截取"><a href="#对数组进行片段截取" class="headerlink" title="对数组进行片段截取"></a>对数组进行片段截取</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myarr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">mysli1 := myarr[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//表示从索引1-索引2的元素</span></span><br><span class="line"></span><br><span class="line">mysli2 := myarr[<span class="number">1</span>:<span class="number">3</span>:<span class="number">4</span>]<span class="comment">//表示从索引1-索引2的元素</span></span><br></pre></td></tr></table></figure><p>mysli1 mysli2打印结果一模一样 其中mysli2中的4是做什么的呢 </p><p>在切片时 若不指定第三个数 那么切片的终止索引会一直到原数组的最后一个数 若指定了第三个数 那么切片的终止索引就到这第三个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    myarr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;myarr 的长度为：%d，容量为：%d\n&quot;</span>, <span class="built_in">len</span>(myarr), <span class="built_in">cap</span>(myarr))</span><br><span class="line"></span><br><span class="line">    mysli1 := myarr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;mysli1 的长度为：%d，容量为：%d\n&quot;</span>, <span class="built_in">len</span>(mysli1), <span class="built_in">cap</span>(mysli1))</span><br><span class="line">    fmt.Println(mysli1)</span><br><span class="line"></span><br><span class="line">    mysli2 := myarr[<span class="number">1</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;mysli2 的长度为：%d，容量为：%d\n&quot;</span>, <span class="built_in">len</span>(mysli2), <span class="built_in">cap</span>(mysli2))</span><br><span class="line">    fmt.Println(mysli2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myarr 的长度为：5，容量为：5</span><br><span class="line">mysli1 的长度为：2，容量为：4</span><br><span class="line">[2 3]</span><br><span class="line">mysli2 的长度为：2，容量为：3</span><br><span class="line">[2 3]</span><br></pre></td></tr></table></figure><p>所以切片的第三个数只影响切片的容量 不影响切片的长度</p><h5 id="从头声明赋值"><a href="#从头声明赋值" class="headerlink" title="从头声明赋值"></a>从头声明赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strList[]<span class="type">string</span> <span class="comment">// 声明字符串切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numList[]<span class="type">int</span> <span class="comment">// 声明整型切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numListEmpty = []<span class="type">int</span>&#123;&#125; <span class="comment">// 声明一个空切片</span></span><br></pre></td></tr></table></figure><p>可以看到 声明切片类型和声明数组类型基本上是一模一样 除了不需要说明长度</p><h5 id="make函数构造切片"><a href="#make函数构造切片" class="headerlink" title="make函数构造切片"></a>make函数构造切片</h5><p><code>make([]Type,size,cap)</code> Type类型 size长度 cap容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"> b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"> fmt.Println(a, b)</span><br><span class="line"> fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b))</span><br><span class="line"> fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0 0] [0 0]</span><br><span class="line">2 2</span><br><span class="line">2 10</span><br></pre></td></tr></table></figure><p>因此使用make函数构造切片的时候不指定容量的时候 容量等于长度值</p><h5 id="只初始化部分位置-1"><a href="#只初始化部分位置-1" class="headerlink" title="只初始化部分位置"></a>只初始化部分位置</h5><p>和数组一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">4</span>:<span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0 0 0 0 2]</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h3><p>数组与切片都是可容纳若干类型相同元素的容器<br>不同点在于 数组容器大小固定 而切片本身是引用类型 可以append进行元素添加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myarr := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">// 追加一个元素</span></span><br><span class="line">    myarr = <span class="built_in">append</span>(myarr, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 追加多个元素</span></span><br><span class="line">    myarr = <span class="built_in">append</span>(myarr, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 追加一个切片, ... 表示解包，不能省略</span></span><br><span class="line">    myarr = <span class="built_in">append</span>(myarr, []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>&#125;...)</span><br><span class="line">    <span class="comment">// 在第一个位置插入元素</span></span><br><span class="line">    myarr = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;, myarr...)</span><br><span class="line">    <span class="comment">// 在中间插入一个切片(两个元素)</span></span><br><span class="line">    myarr = <span class="built_in">append</span>(myarr[:<span class="number">5</span>], <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">5</span>,<span class="number">6</span>&#125;, myarr[<span class="number">5</span>:]...)...)</span><br><span class="line">    <span class="comment">//先计算内层append 拼接完成后再计算外层append</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(myarr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2 3 4 5 6 7 8]</span><br></pre></td></tr></table></figure><p>可以如此理解数组与切片的区别<br>    切片是引用类型 数组是值类型<br>    数组长度固定 切片是动态的数组<br>    切片比数组多一个属性 容量cap<br>    切片的底层实现是数组<br>    切片不能进行等值判断 只能和nil判断</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典 Map 若干个<code>key:value</code>组建在一起的无序键值对<br>要求每一个key都是唯一的 可以使用<code>==</code> <code>!=</code>来进行判断 key不能是切片 不能是字典 不能是函数<br>map是一个集合 可以迭代它 不过map是无序的 无法决定他的返回顺序 因为map是使用hash表实现的<br>声明map时必须指定好key和value的类型</p><h4 id="声明初始化字典"><a href="#声明初始化字典" class="headerlink" title="声明初始化字典"></a>声明初始化字典</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">var</span> scores <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;English&quot;</span>:<span class="number">80</span>,<span class="string">&quot;Chinese&quot;</span>:<span class="number">90</span>&#125;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">scores := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;English&quot;</span>:<span class="number">80</span>,<span class="string">&quot;Chinese&quot;</span>:<span class="number">90</span>&#125;</span><br><span class="line"><span class="comment">//第三种方式 使用make函数</span></span><br><span class="line">scores := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">scores[<span class="string">&quot;English&quot;</span>] = <span class="number">80</span></span><br><span class="line">scores[<span class="string">&quot;Chinese&quot;</span>] = <span class="number">90</span></span><br></pre></td></tr></table></figure><p>需要注意的是 只声明不初始化的map类型的初值为nil 无法直接进行赋值 所以需要使用make函数先对其初始化 然后才能直接赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个名为 score 的字典</span></span><br><span class="line">    <span class="keyword">var</span> scores <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未初始化的 score 的零值为nil，无法直接进行赋值</span></span><br><span class="line">    <span class="keyword">if</span> scores == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 需要使用 make 函数先对其初始化</span></span><br><span class="line">        scores = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经过初始化后，就可以直接赋值</span></span><br><span class="line">    scores[<span class="string">&quot;chinese&quot;</span>] = <span class="number">90</span></span><br><span class="line">    fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为 <code>map[chinese:90]</code></p><h4 id="对字典的操作"><a href="#对字典的操作" class="headerlink" title="对字典的操作"></a>对字典的操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scores := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">//更新元素</span></span><br><span class="line">scores[<span class="string">&quot;math&quot;</span>] = <span class="number">150</span></span><br><span class="line"><span class="comment">//读取元素 若key不存在 也不会报错 而是返回value的零值</span></span><br><span class="line">fmt.Print(scores[<span class="string">&quot;math&quot;</span>])</span><br><span class="line"><span class="comment">//删除元素 若key不存在 也不会报错</span></span><br><span class="line"><span class="built_in">delete</span>(scores,<span class="string">&quot;math&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h4><p>因为有可能key对应的value恰好为零值 所以想要判断key是否存在不能够使用判断value零值的办法</p><p>字典的下标读取会返回两个值 可以使用第二个返回值来表示对应的key是否存在 若存在 ok则为true 若不存在 ok为false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scores := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> math, ok := scores[<span class="string">&quot;math&quot;</span>]; ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;math 的值是: %d&quot;</span>, math)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;math 不存在&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对字典进行循环"><a href="#对字典进行循环" class="headerlink" title="对字典进行循环"></a>对字典进行循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//获取key和value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scores := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> subject, score := <span class="keyword">range</span> scores &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key: %s, value: %d\n&quot;</span>, subject, score)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//只获取key 不需要占位符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scores := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> subject := <span class="keyword">range</span> scores &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key: %s\n&quot;</span>, subject)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//只获取value 需要使用占位符替代key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scores := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;english&quot;</span>: <span class="number">80</span>, <span class="string">&quot;chinese&quot;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, score := <span class="keyword">range</span> scores &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;value: %d\n&quot;</span>, score)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>与其他语言不同的一点 go的true不等于1 false不等于0 即 <code>bool</code>和<code>int</code>不能直接转换 需要自己实现转换函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bool转int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bool2int</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in转bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">int2bool</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="创建指针"><a href="#创建指针" class="headerlink" title="创建指针"></a>创建指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">aint :=<span class="number">1</span> <span class="comment">//定义普通变量</span></span><br><span class="line">ptr1 := &amp;aint <span class="comment">//定义指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">astr := <span class="built_in">new</span>(<span class="type">string</span>) <span class="comment">//创建指针</span></span><br><span class="line">*astr =<span class="string">&quot;Ruojhen&quot;</span> <span class="comment">//给指针赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">aint := <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> bint *<span class="type">int</span></span><br><span class="line">bint = &amp;aint</span><br></pre></td></tr></table></figure><p>以防混淆</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    aint := <span class="number">1</span>     <span class="comment">// 定义普通变量</span></span><br><span class="line">    ptr := &amp;aint  <span class="comment">// 定义指针变量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;普通变量存储的是：&quot;</span>, aint)</span><br><span class="line">    fmt.Println(<span class="string">&quot;普通变量存储的是：&quot;</span>, *ptr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;指针变量存储的是：&quot;</span>, &amp;aint)</span><br><span class="line">    fmt.Println(<span class="string">&quot;指针变量存储的是：&quot;</span>, ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">普通变量存储的是： 1</span><br><span class="line">普通变量存储的是： 1</span><br><span class="line">指针变量存储的是： 0xc0000100a0</span><br><span class="line">指针变量存储的是： 0xc0000100a0</span><br></pre></td></tr></table></figure><p>打印指针指向的内存地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p&quot;</span>, ptr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">fmt.Println(ptr)</span><br></pre></td></tr></table></figure><h4 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    astr := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    aint := <span class="number">1</span></span><br><span class="line">    abool := <span class="literal">false</span></span><br><span class="line">    arune := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    afloat := <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;astr 指针类型是：%T\n&quot;</span>, &amp;astr)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;aint 指针类型是：%T\n&quot;</span>, &amp;aint)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;abool 指针类型是：%T\n&quot;</span>, &amp;abool)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arune 指针类型是：%T\n&quot;</span>, &amp;arune)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;afloat 指针类型是：%T\n&quot;</span>, &amp;afloat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">astr 指针类型是：*<span class="type">string</span></span><br><span class="line">aint 指针类型是：*<span class="type">int</span></span><br><span class="line">abool 指针类型是：*<span class="type">bool</span></span><br><span class="line">arune 指针类型是：*<span class="type">int32</span></span><br><span class="line">afloat 指针类型是：*<span class="type">float64</span></span><br></pre></td></tr></table></figure><p>可以发现用 <code>*</code>+所指向变量值的数据类型就是对应的指针类型</p><h4 id="指针的初始值"><a href="#指针的初始值" class="headerlink" title="指针的初始值"></a>指针的初始值</h4><p>指针声明后不初始化赋值的话 指针的值就会是<code>nil</code></p><h4 id="切片与指针"><a href="#切片与指针" class="headerlink" title="切片与指针"></a>切片与指针</h4><p>指针和切片一样都是引用类型 </p><p>若想通过一个函数改变一个数组内的值 有两种方式</p><p>1.将数组的切片作为参数传给函数<br>2.将数组的指针作为参数传给函数</p><p>按照go的语言习惯 使用切片将会更加简洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="go指针限制"><a href="#go指针限制" class="headerlink" title="go指针限制"></a>go指针限制</h4><p>相较于cpp的指针 go指针有着许多限制 目的是避免指针操作的危险</p><p>限制一 指针不能参与数学运算</p><p>限制二 不同类型的指针不允许相互转换</p><p>限制三 不同类型的指针不能比较和相互赋值</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接一个表达式</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> a&lt;=<span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    a++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接三个表达式</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>;i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不接任何表达式 为无限循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ;; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h4><p>遍历一个可迭代的数据结构用for range语句实现 range后可接数组 切片 字符串等</p><p>按照以往的编程习惯 随便写一个循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector := [...]<span class="type">string</span>&#123;<span class="string">&quot;C++&quot;</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Git&quot;</span>,<span class="string">&quot;Redis&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> vector &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;I will learn &quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I will learn  0</span><br><span class="line">I will learn  1</span><br><span class="line">I will learn  2</span><br><span class="line">I will learn  3</span><br></pre></td></tr></table></figure><p>发现与我们期望的不符 做一些小更改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector := [...]<span class="type">string</span>&#123;<span class="string">&quot;C++&quot;</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Git&quot;</span>,<span class="string">&quot;Redis&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> vector &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;I will learn &quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I will learn  C++</span><br><span class="line">I will learn  Go</span><br><span class="line">I will learn  Git</span><br><span class="line">I will learn  Redis</span><br></pre></td></tr></table></figure><p>这是因为range返回两个值 第一个是索引 第二个是数据</p><h3 id="defer-延迟语句"><a href="#defer-延迟语句" class="headerlink" title="defer 延迟语句"></a>defer 延迟语句</h3><p><code>defer</code>后接函数名 就能实现将这个函数的调用延迟到当前函数执行完再调用</p><p>理解defer的使用效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syhprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> syhprint()</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>代码也可以简写为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defer的快照作用"><a href="#defer的快照作用" class="headerlink" title="defer的快照作用"></a>defer的快照作用</h4><p>使用defer只是延时调用了函数 此时已经传递给函数的变量 就像一个快照一样被保存了下来 不会受到后续程序执行的影响</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">language := <span class="string">&quot;C++&quot;</span> </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(language)</span><br><span class="line">language = <span class="string">&quot;Go&quot;</span></span><br><span class="line">fmt.Println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Go</span><br><span class="line">C++</span><br></pre></td></tr></table></figure><p>由此可见 在变量被修改前延时调用打印函数 即使变量值被修改了 最后延迟调用的函数的变量值依旧是修改前的值 就像是defer给这个函数的变量值做了一个快照</p><h4 id="多个defer调用的顺序"><a href="#多个defer调用的顺序" class="headerlink" title="多个defer调用的顺序"></a>多个defer调用的顺序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">language := <span class="string">&quot;C++&quot;</span> </span><br><span class="line"><span class="keyword">defer</span> fmt.Println(language)</span><br><span class="line">language = <span class="string">&quot;Go&quot;</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(language)</span><br><span class="line">language = <span class="string">&quot;Rust&quot;</span></span><br><span class="line">fmt.Println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rust</span><br><span class="line">Go</span><br><span class="line">C++</span><br></pre></td></tr></table></figure><p>由此可见 多个defer一起调用的时候 输出的结果是反序的 类似栈的后进先出</p><h4 id="defer-return"><a href="#defer-return" class="headerlink" title="defer/return"></a>defer/return</h4><p>defer和return同时存在的话 先调用谁呢 看下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rename</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">name = <span class="string">&quot;Go&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;rename函数内的name为&quot;</span>,name)</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">myname := rename()</span><br><span class="line">fmt.Println(<span class="string">&quot;main函数里的name为&quot;</span>,name)</span><br><span class="line">fmt.Println(<span class="string">&quot;main函数里的myname为&quot;</span>,myname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rename函数内的name为 C++</span><br><span class="line">main函数里的name为 Go</span><br><span class="line">main函数里的myname为 C++</span><br></pre></td></tr></table></figure><p>对代码进行剖析 理解为何是这个输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在main函数里初始化myname的时候 调用了rename函数 </span><br><span class="line">rename函数内输出了name值为全局变量的<span class="string">&quot;C++&quot;</span></span><br><span class="line">同时rename函数内延迟修改了全局变量name的值为<span class="string">&quot;Go&quot;</span></span><br><span class="line">main函数输出name值 为修改后的<span class="string">&quot;Go&quot;</span></span><br><span class="line">main函数输出myname值 为rename函数的返回值<span class="string">&quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line">因此我们发现在rename函数调用完毕后 才会延迟修改全局变量name的值</span><br><span class="line"></span><br><span class="line">所以<span class="built_in">return</span>回的值为修改前的<span class="string">&quot;C++&quot;</span> </span><br><span class="line">因此<span class="built_in">return</span>的调用在defer之前 </span><br><span class="line">毕竟要完成函数后才会继续延迟调用</span><br></pre></td></tr></table></figure><h4 id="为什么要有defer"><a href="#为什么要有defer" class="headerlink" title="为什么要有defer"></a>为什么要有defer</h4><p>能够缩减代码量 使代码不那么臃肿 下面是一段经典的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用defer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := getResource()  <span class="comment">//0，获取资源</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ... &#123;</span><br><span class="line">        r.release()  <span class="comment">//1，释放资源</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ... &#123;</span><br><span class="line">        r.release()  <span class="comment">//2，释放资源</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ... &#123;</span><br><span class="line">        r.release()  <span class="comment">//3，释放资源</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    r.release()     <span class="comment">//4，释放资源</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用defer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := getResource()  <span class="comment">//0，获取资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> r.release()  <span class="comment">//1，释放资源</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ... &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ... &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ... &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Go语言中 异常的抛出和捕获依赖两个内置函数</p><p>panic 抛出异常 使程序崩溃</p><p>recover 捕获异常 恢复程序<br>recover调用后 抛出的panic将会在此处终结 不会再向外抛出异常<br>并且recover必须在defer修饰下才能发挥作用</p><h4 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h4><p>手动抛出异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;程序出错了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出效果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">panic: 程序出错了</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">d:/Code/My Code/Golang/Hexomd/src/github.com/Ruojhen/hexomd01/test.go:8 +0x40</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><h4 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">data</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//制造数组越界 出发panic</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">arr[x] = <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data(<span class="number">20</span>) <span class="comment">//数组越界 抛出异常 程序应该终止</span></span><br><span class="line"><span class="comment">//若程序执行到这里i说明panic被捕获</span></span><br><span class="line">fmt.Println(<span class="string">&quot;It is fine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`     </span></span><br><span class="line"><span class="string">控制台输出结果为</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>bash</span><br><span class="line">runtime <span class="type">error</span>: index out of <span class="keyword">range</span> [<span class="number">20</span>] with length <span class="number">10</span></span><br><span class="line">It is fine</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2020/06/13/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/06/13/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">    Input:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">    Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span> <p>全部代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">createNodeList</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp; vec)</span></span>&#123;<span class="comment">//后插法创建链表</span></span><br><span class="line">    ListNode* prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>(vec[<span class="number">0</span>]);<span class="comment">//prev始终指向表尾指针</span></span><br><span class="line">    ListNode* prevHead = prev;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        ListNode* next_node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(vec[i]);</span><br><span class="line">        prev -&gt; next = next_node;</span><br><span class="line">        prev = next_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prevHead;<span class="comment">//prevHead始终指向第一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(ListNode *l)</span></span>&#123;<span class="comment">//遍历输出链表</span></span><br><span class="line">    ListNode *p=l;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* res=<span class="built_in">reverseList</span>(head-&gt;next);<span class="comment">//以&#123;1,2,3,4,5&#125;为例</span></span><br><span class="line">        head-&gt;next-&gt;next=head;<span class="comment">//reverse递归传参 到5返回5结点 res指向5 回到4这一层 head指向4 head-&gt;next-&gt;next=head是4-&gt;next-&gt;next</span></span><br><span class="line">        <span class="comment">//是4-&gt;next-&gt;next=4即5-&gt;next=4</span></span><br><span class="line">        head-&gt;next=<span class="literal">NULL</span>;<span class="comment">//然后4-&gt;next=NULL断链 再将5-4返回给上一层连上3 在连上2 1 反转成功</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    ListNode *l1=<span class="built_in">createNodeList</span>(m1);</span><br><span class="line">    Solution answer;</span><br><span class="line">    ListNode *l2=answer.<span class="built_in">reverseList</span>(l1);<span class="comment">//l2为l1元素翻转的链表</span></span><br><span class="line">    <span class="built_in">ShowList</span>(l2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表的前N个元素"><a href="#反转链表的前N个元素" class="headerlink" title="反转链表的前N个元素"></a>反转链表的前N个元素</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">    Input:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL N=3</span><br><span class="line"></span><br><span class="line">    Output: 3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数 <code>reverseN(ListNode* head,int n)</code> 的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListNode* last=<span class="literal">NULL</span>;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>||n==<span class="number">1</span>) &#123;</span><br><span class="line">        last=head-&gt;next; <span class="comment">//last: 4-&gt;5-&gt;NULL</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* res=<span class="built_in">reverseN</span>(head-&gt;next,n<span class="number">-1</span>);</span><br><span class="line">    head-&gt;next-&gt;next=head; </span><br><span class="line">    head-&gt;next=last;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表中m位置到n位置的元素"><a href="#反转链表中m位置到n位置的元素" class="headerlink" title="反转链表中m位置到n位置的元素"></a>反转链表中m位置到n位置的元素</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">    Input:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL M=2 N=4</span><br><span class="line"></span><br><span class="line">    Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数 <code>reverseBetween(ListNode* head,int m,int n)</code> 的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head,<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head,n);</span><br><span class="line">    head-&gt;next=<span class="built_in">reverseBetween</span>(head-&gt;next,m<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary-Tree</title>
      <link href="/2020/06/03/Binary-Tree/"/>
      <url>/2020/06/03/Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary-Tree"></a>Binary-Tree</h1><p>本篇文章为<a href="https://shaoyuanhangyes.github.io/2019/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91/#more"><code>shaoyuanhangyes.github.io/二叉树</code></a>的重置版本<br>更新了部分代码 更改了排版 舍弃了冗杂的赘述内容 利用STL容器进行了更新</p><span id="more"></span> <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><div>    ![二叉树example](B.png)</div><h3 id="二叉树结构体"><a href="#二叉树结构体" class="headerlink" title="二叉树结构体"></a>二叉树结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><p>采用的是更为直观的层序遍历的方式 将二叉树和对应数组序号的元素一一填入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以层序的方式创建二叉树 len为数组长度 index为元素位置序号</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> len,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    TreeNode *root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;len&amp;&amp;nums[index]!=<span class="number">-1</span>)&#123;<span class="comment">//值为null和位置不合法时直接返回空节点</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">        root-&gt;left = <span class="built_in">createTree</span>(nums,len,<span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">        root-&gt;right= <span class="built_in">createTree</span>(nums,len,<span class="number">2</span>*index+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历中 层序遍历属于广度优先(BFS) 前中后序遍历都属于深度优先(DFS)</p><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>利用队列进行迭代</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历 利用队列进行迭代 返回的是一个二维vector数组 因此需要一个函数来打印这个vector数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;TreeNode* &gt; Tree;</span><br><span class="line">    Tree.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!Tree.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> len=Tree.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">            TreeNode *pNode=Tree.<span class="built_in">front</span>();</span><br><span class="line">            Tree.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(pNode-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left) Tree.<span class="built_in">push</span>(pNode-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right) Tree.<span class="built_in">push</span>(pNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印二维数组的代码为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印二维数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMartrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>遍历顺序为 <code>根 左 右</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历递归算法 遍历到就直接cout输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>遍历顺序为 <code>左 根 右</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>遍历顺序为 <code>左 右 根</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以层序的方式创建二叉树 len为数组长度 index为元素位置序号</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> len,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    TreeNode *root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;len&amp;&amp;nums[index]!=<span class="number">-1</span>)&#123;<span class="comment">//值为null和位置不合法时直接返回空节点</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">        root-&gt;left = <span class="built_in">createTree</span>(nums,len,<span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">        root-&gt;right= <span class="built_in">createTree</span>(nums,len,<span class="number">2</span>*index+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印二维数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMartrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历 利用队列进行迭代</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;TreeNode* &gt; Tree;</span><br><span class="line">    Tree.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!Tree.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> len=Tree.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">            TreeNode *pNode=Tree.<span class="built_in">front</span>();</span><br><span class="line">            Tree.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(pNode-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left) Tree.<span class="built_in">push</span>(pNode-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right) Tree.<span class="built_in">push</span>(pNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">-1</span>,<span class="number">10</span>&#125;;<span class="comment">//示例 -1代表所在位置为空值</span></span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    TreeNode *root=<span class="built_in">createTree</span>(nums,len,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;层序遍历的二维数组序列为: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res=<span class="built_in">levelOrder</span>(root);</span><br><span class="line">    <span class="built_in">PrintMartrix</span>(res);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;先序遍历序列为: &quot;</span>;</span><br><span class="line">    <span class="built_in">preOrder</span>(root);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;中序遍历序列为: &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(root);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;后序遍历序列为: &quot;</span>;</span><br><span class="line">    <span class="built_in">postOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">层序遍历的二维数组序列为:</span><br><span class="line">[ 0 ]</span><br><span class="line">[ 1  2 ]</span><br><span class="line">[ 3  4  5  6 ]</span><br><span class="line">[ 7  8  10 ]</span><br><span class="line"></span><br><span class="line">先序遍历序列为: 0 1 3 7 8 4 10 2 5 6</span><br><span class="line">中序遍历序列为: 7 3 8 1 4 10 0 5 2 6</span><br><span class="line">后序遍历序列为: 7 8 3 10 4 1 5 6 2 0</span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树进阶"><a href="#二叉树进阶" class="headerlink" title="二叉树进阶"></a>二叉树进阶</h2><p>更多进阶的算法以及刷题解答见<a href="https://github.com/shaoyuanhangyes/LeetCode/tree/master/%E6%A0%91">shaoyuanhangyes/LeetCode/树</a></p><p>二叉树刷题C++模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*二叉树结构体*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h3><p>因为二叉树是非线性结构 不易于直接表示 因此采取顺序存储的思想 按照数组的序号对这个数组以层序遍历的方式创建二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">createTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> len,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    TreeNode *root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;len&amp;&amp;nums[index]!=<span class="number">-1</span>)&#123;<span class="comment">//值为null和位置不合法时直接返回空节点</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">        root-&gt;left = <span class="built_in">createTree</span>(nums,len,<span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">        root-&gt;right= <span class="built_in">createTree</span>(nums,len,<span class="number">2</span>*index+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">-1</span>,<span class="number">10</span>&#125;;<span class="comment">//示例 -1代表所在位置为空值</span></span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    TreeNode *root=<span class="built_in">createTree</span>(nums,len,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建后的二叉树为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        0</span><br><span class="line">      /   \</span><br><span class="line">    1       2</span><br><span class="line">   / \     / \</span><br><span class="line">  3   4   5   6</span><br><span class="line"> / \   \</span><br><span class="line">7   8   10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历们"><a href="#二叉树的遍历们" class="headerlink" title="二叉树的遍历们"></a>二叉树的遍历们</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历(先序遍历) 遍历的次序为 <code>根 左 右</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        0</span><br><span class="line">      /   \</span><br><span class="line">    1       2</span><br><span class="line">   / \     / \</span><br><span class="line">  3   4   5   6</span><br><span class="line"> / \   \</span><br><span class="line">7   8   10      为例子</span><br><span class="line"></span><br><span class="line">前序遍历的序列为 [0 1 3 7 8 4 10 2 5 6]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前序遍历序列的第一个节点一定是二叉树的根节点</p><h5 id="前序遍历递归代码"><a href="#前序遍历递归代码" class="headerlink" title="前序遍历递归代码"></a>前序遍历递归代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//必须是全局变量的数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">-1</span>,<span class="number">10</span>&#125;;<span class="comment">//示例 -1代表所在位置为空值</span></span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    TreeNode *root=<span class="built_in">createTree</span>(nums,len,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历的序列为:&quot;</span>&lt;&lt;endl</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preOrder=<span class="built_in">preOrderTraversal</span>(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:preOrder) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="前序遍历迭代代码"><a href="#前序遍历迭代代码" class="headerlink" title="前序遍历迭代代码"></a>前序遍历迭代代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">stack&lt;TreeNode* &gt; st;</span><br><span class="line">TreeNode* node=root;</span><br><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>()||node)&#123;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(node);</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        node=node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    node=st.<span class="built_in">top</span>();</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">    node=node-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">-1</span>,<span class="number">10</span>&#125;;<span class="comment">//示例 -1代表所在位置为空值</span></span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    TreeNode *root=<span class="built_in">createTree</span>(nums,len,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历的序列为:&quot;</span>&lt;&lt;endl</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preOrder=<span class="built_in">preOrderTraversal</span>(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:preOrder) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历 遍历的次序为 <code>左 根 右</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        0</span><br><span class="line">      /   \</span><br><span class="line">    1       2</span><br><span class="line">   / \     / \</span><br><span class="line">  3   4   5   6</span><br><span class="line"> / \   \</span><br><span class="line">7   8   10      为例子</span><br><span class="line"></span><br><span class="line">中序遍历的序列为 [7 3 8 1 4 10 0 5 2 6]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过前序遍历确定了二叉树的根节点后 在中序遍历序列中 根节点的左半部分都是根节点的左子树 根节点的右半部分都是根节点的右子树<br>BST 二叉搜索树 又名二叉排序树 二叉查找树 的中序序列一定是按从小到大的顺序排列的</p><h5 id="中序遍历递归代码"><a href="#中序遍历递归代码" class="headerlink" title="中序遍历递归代码"></a>中序遍历递归代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//必须是全局变量的数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下的主函数不赘述了*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="中序遍历迭代代码"><a href="#中序遍历迭代代码" class="headerlink" title="中序遍历迭代代码"></a>中序遍历迭代代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//迭代算法</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode *&gt; st;</span><br><span class="line">    TreeNode *node=root;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()||node)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(node);</span><br><span class="line">            node=node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node=st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        node=node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历 遍历的次序为 <code>左 右 根</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        0</span><br><span class="line">      /   \</span><br><span class="line">    1       2</span><br><span class="line">   / \     / \</span><br><span class="line">  3   4   5   6</span><br><span class="line"> / \   \</span><br><span class="line">7   8   10      为例子</span><br><span class="line"></span><br><span class="line">后序遍历的序列为 [7 8 3 10 4 1 5 6 2 0]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后序遍历序列的最后一个节点一定是根节点</p><h5 id="后序遍历递归代码"><a href="#后序遍历递归代码" class="headerlink" title="后序遍历递归代码"></a>后序遍历递归代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;right);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="后序遍历迭代代码"><a href="#后序遍历迭代代码" class="headerlink" title="后序遍历迭代代码"></a>后序遍历迭代代码</h5><p>第一种解法 标记位</p><p>prev记录已经输出到res数组中的上一个节点 防止出现某一节点有右孩子 右孩子输出后 根据栈回到右孩子的父节点 然后又判断是否有右孩子的死循环 当判断到node-&gt;right==prev成立 即父节点的右孩子上一次被访问过 就输出这个父节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode* &gt; st;</span><br><span class="line">    TreeNode* node=root;</span><br><span class="line">    TreeNode* prev=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()||node)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(node);</span><br><span class="line">            node=node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node=st.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right==<span class="literal">NULL</span>||node-&gt;right==prev)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            prev=node;</span><br><span class="line">            node=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> node=node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种解法 反转</p><p>根据前序遍历的思想 将遍历序列规则转换为 <code>根 右 左</code> 序列输出到数组后 将整个数组反转过来 就变成了<code>左 右 根</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">stack&lt;TreeNode* &gt; st;</span><br><span class="line">TreeNode* node=root;</span><br><span class="line"><span class="keyword">while</span>(!st.<span class="built_in">empty</span>()||node)&#123;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(node);</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//根</span></span><br><span class="line">        node=node-&gt;right;<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    node=st.<span class="built_in">top</span>();</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">    node=node-&gt;left;<span class="comment">//左</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());<span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>层序遍历 每一层元素 按从左到右的顺序逐层输出 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        0</span><br><span class="line">      /   \</span><br><span class="line">    1       2</span><br><span class="line">   / \     / \</span><br><span class="line">  3   4   5   6</span><br><span class="line"> / \   \</span><br><span class="line">7   8   10      为例子</span><br><span class="line"></span><br><span class="line">层序遍历的序列为 [0 1 2 3 4 5 6 7 8 10]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="层序遍历迭代算法"><a href="#层序遍历迭代算法" class="headerlink" title="层序遍历迭代算法"></a>层序遍历迭代算法</h5><p>利用队列进行迭代 返回二维数组 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;TreeNode* &gt; Tree;</span><br><span class="line">    Tree.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!Tree.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> len=Tree.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">            TreeNode *pNode=Tree.<span class="built_in">front</span>();</span><br><span class="line">            Tree.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(pNode-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left) Tree.<span class="built_in">push</span>(pNode-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right) Tree.<span class="built_in">push</span>(pNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印二维数组的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMartrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;res[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h2><p>二叉搜索树 又被翻译为二叉排序树 二叉查找树</p><p>特点具体为 每个节点的值 大于其任意左侧子节点的值 小于其任意右侧子节点的值</p><h3 id="BST插入"><a href="#BST插入" class="headerlink" title="BST插入"></a>BST插入</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值 将值插入二叉搜索树 返回插入后二叉搜索树的根节点  保证原始二叉搜索树中不存在新值 </p><p>注意 可能存在多种有效的插入方式 只要树在插入后仍保持为二叉搜索树即可  你可以返回任意有效的结果</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">例如, </span><br><span class="line"></span><br><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和 插入的值: 5</span><br><span class="line">你可以返回这个二叉搜索树:</span><br><span class="line"></span><br><span class="line">         4</span><br><span class="line">       /   \</span><br><span class="line">      2     7</span><br><span class="line">     / \   /</span><br><span class="line">    1   3 5</span><br><span class="line">或者这个树也是有效的:</span><br><span class="line"></span><br><span class="line">         5</span><br><span class="line">       /   \</span><br><span class="line">      2     7</span><br><span class="line">     / \   </span><br><span class="line">    1   3</span><br><span class="line">         \</span><br><span class="line">          4</span><br></pre></td></tr></table></figure><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(val&lt;root-&gt;val) root-&gt;left=<span class="built_in">insertIntoBST</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">if</span>(val&gt;root-&gt;val) root-&gt;right=<span class="built_in">insertIntoBST</span>(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol><li>时间复杂度: O(H) H为Tree的高度 平均情况<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline-block"><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></math> 最坏情况O(N)</li><li>空间复杂度: 平均情况下O(H) 最坏情况O(N) 是在递归过程中堆栈使用的空间</li></ol><p>复杂度中<code>最坏的情况</code>就是二叉树高度为二叉树节点数量的时候 即</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     /   </span><br><span class="line">   <span class="number"> 2 </span>    </span><br><span class="line">   /   </span><br><span class="line"> <span class="number"> 1 </span> </span><br><span class="line"> /</span><br><span class="line">4 </span><br></pre></td></tr></table></figure><p>要插入的元素需要遍历到最深才能插入</p><h4 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        TreeNode* node=root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val&gt;node-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    node-&gt;right=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> node=node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    node-&gt;left=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> node=node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol><li>时间复杂度: O(H) H为Tree的高度 平均情况<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline-block"><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></math> 最坏情况O(N)</li><li>空间复杂度: O(1)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll源码</title>
      <link href="/2020/05/25/epoll%E6%BA%90%E7%A0%81/"/>
      <url>/2020/05/25/epoll%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="epoll源码-注释版"><a href="#epoll源码-注释版" class="headerlink" title="epoll源码(注释版)"></a>epoll源码(注释版)</h2><span id="more"></span> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  fs/eventpoll.c (Efficient event retrieval implementation)</span></span><br><span class="line"><span class="comment"> *  Copyright (C) 2001,...,2009  Davide Libenzi</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> *  it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment"> *  (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Davide Libenzi &lt;davidel@xmailserver.org&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在深入了解epoll的实现之前, 先来了解内核的3个方面.</span></span><br><span class="line"><span class="comment"> * 1. 等待队列 waitqueue</span></span><br><span class="line"><span class="comment"> * 我们简单解释一下等待队列:</span></span><br><span class="line"><span class="comment"> * 队列头(wait_queue_head_t)往往是资源生产者,</span></span><br><span class="line"><span class="comment"> * 队列成员(wait_queue_t)往往是资源消费者,</span></span><br><span class="line"><span class="comment"> * 当头的资源ready后, 会逐个执行每个成员指定的回调函数,</span></span><br><span class="line"><span class="comment"> * 来通知它们资源已经ready了, 等待队列大致就这个意思.</span></span><br><span class="line"><span class="comment"> * 2. 内核的poll机制</span></span><br><span class="line"><span class="comment"> * 被Poll的fd, 必须在实现上支持内核的Poll技术,</span></span><br><span class="line"><span class="comment"> * 比如fd是某个字符设备,或者是个socket, 它必须实现</span></span><br><span class="line"><span class="comment"> * file_operations中的poll操作, 给自己分配有一个等待队列头.</span></span><br><span class="line"><span class="comment"> * 主动poll fd的某个进程必须分配一个等待队列成员, 添加到</span></span><br><span class="line"><span class="comment"> * fd的对待队列里面去, 并指定资源ready时的回调函数.</span></span><br><span class="line"><span class="comment"> * 用socket做例子, 它必须有实现一个poll操作, 这个Poll是</span></span><br><span class="line"><span class="comment"> * 发起轮询的代码必须主动调用的, 该函数中必须调用poll_wait(),</span></span><br><span class="line"><span class="comment"> * poll_wait会将发起者作为等待队列成员加入到socket的等待队列中去.</span></span><br><span class="line"><span class="comment"> * 这样socket发生状态变化时可以通过队列头逐个通知所有关心它的进程.</span></span><br><span class="line"><span class="comment"> * 这一点必须很清楚的理解, 否则会想不明白epoll是如何</span></span><br><span class="line"><span class="comment"> * 得知fd的状态发生变化的.</span></span><br><span class="line"><span class="comment"> * 3. epollfd本身也是个fd, 所以它本身也可以被epoll,</span></span><br><span class="line"><span class="comment"> * 可以猜测一下它是不是可以无限嵌套epoll下去...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * epoll基本上就是使用了上面的1,2点来完成.</span></span><br><span class="line"><span class="comment"> * 可见epoll本身并没有给内核引入什么特别复杂或者高深的技术,</span></span><br><span class="line"><span class="comment"> * 只不过是已有功能的重新组合, 达到了超过select的效果.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 相关的其它内核知识:</span></span><br><span class="line"><span class="comment"> * 1. fd我们知道是文件描述符, 在内核态, 与之对应的是struct file结构,</span></span><br><span class="line"><span class="comment"> * 可以看作是内核态的文件描述符.</span></span><br><span class="line"><span class="comment"> * 2. spinlock, 自旋锁, 必须要非常小心使用的锁,</span></span><br><span class="line"><span class="comment"> * 尤其是调用spin_lock_irqsave()的时候, 中断关闭, 不会发生进程调度,</span></span><br><span class="line"><span class="comment"> * 被保护的资源其它CPU也无法访问. 这个锁是很强力的, 所以只能锁一些</span></span><br><span class="line"><span class="comment"> * 非常轻量级的操作.</span></span><br><span class="line"><span class="comment"> * 3. 引用计数在内核中是非常重要的概念,</span></span><br><span class="line"><span class="comment"> * 内核代码里面经常有些release, free释放资源的函数几乎不加任何锁,</span></span><br><span class="line"><span class="comment"> * 这是因为这些函数往往是在对象的引用计数变成0时被调用,</span></span><br><span class="line"><span class="comment"> * 既然没有进程在使用在这些对象, 自然也不需要加锁.</span></span><br><span class="line"><span class="comment"> * struct file 是持有引用计数的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* --- epoll相关的数据结构 --- */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span></span><br><span class="line"><span class="comment"> * structure and rapresent the main data sructure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 每创建一个epollfd, 内核就会分配一个eventpoll与之对应, 可以说是</span></span><br><span class="line"><span class="comment"> * 内核态的epollfd. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> &#123;</span><br><span class="line">    <span class="comment">/* Protect the this structure access */</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">     * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">     * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">     * code and the ctl operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 添加, 修改或者删除监听fd的时候, 以及epoll_wait返回, 向用户空间</span></span><br><span class="line"><span class="comment">     * 传递数据时都会持有这个互斥锁, 所以在用户空间可以放心的在多个线程</span></span><br><span class="line"><span class="comment">     * 中同时执行epoll相关的操作, 内核级已经做了保护. */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mutex</span> mtx;</span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="comment">/* 调用epoll_wait()时, 我们就是&quot;睡&quot;在了这个等待队列上... */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wq;</span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="comment">/* 这个用于epollfd本事被poll的时候... */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="comment">/* 所有已经ready的epitem都在这个链表里面 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllist;</span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="comment">/* 所有要监听的epitem都在这里 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这是一个单链表链接着所有的struct epitem当event转移到用户空间时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">     * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *ovflist;</span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">    <span class="comment">/* 这里保存了一些用户变量, 比如fd监听数量的最大值等等 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* epitem 表示一个被监听的fd */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line">    <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">    <span class="comment">/* rb_node, 当使用epoll_ctl()将一批fds加入到某个epollfd时, 内核会分配</span></span><br><span class="line"><span class="comment">     * 一批的epitem与fds们对应, 而且它们以rb_tree的形式组织起来, tree的root</span></span><br><span class="line"><span class="comment">     * 保存在epollfd, 也就是struct eventpoll中.</span></span><br><span class="line"><span class="comment">     * 在这里使用rb_tree的原因我认为是提高查找,插入以及删除的速度.</span></span><br><span class="line"><span class="comment">     * rb_tree对以上3个操作都具有O(lgN)的时间复杂度 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;</span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="comment">/* 链表节点, 所有已经ready的epitem都会被链到eventpoll的rdllist中 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">     * single linked chain of items.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 这个在代码中再解释... */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *next;</span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="comment">/* epitem对应的fd和struct file */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;</span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">    <span class="type">int</span> nwait;</span><br><span class="line">    <span class="comment">/* List containing poll wait queues */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist;</span><br><span class="line">    <span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line">    <span class="comment">/* 当前epitem属于哪个eventpoll */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> fllink;</span><br><span class="line">    <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="comment">/* 当前的epitem关系哪些events, 这个数据是调用epoll_ctl时从用户态传递过来 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *file;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* poll所用到的钩子Wait structure used by the poll hooks */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eppoll_entry</span> &#123;</span><br><span class="line">    <span class="comment">/* List header used to link this structure to the &quot;struct epitem&quot; */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> llink;</span><br><span class="line">    <span class="comment">/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *base;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wait queue item that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">     * queue head.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">wait_queue_t</span> wait;</span><br><span class="line">    <span class="comment">/* The wait queue head that linked the &quot;wait&quot; wait queue item */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Wrapper struct used by poll queueing */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ep_pqueue</span> &#123;</span><br><span class="line">    poll_table pt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Used by the ep_send_events() function as callback private data */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ep_send_events_data</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxevents;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> __user *events;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* --- 代码注释 --- */</span></span><br><span class="line"><span class="comment">/* 你没看错, 这就是epoll_create()的真身, 基本啥也不干直接调用epoll_create1了,</span></span><br><span class="line"><span class="comment"> * 另外你也可以发现, size这个参数其实是没有任何用处的... */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE1</span>(epoll_create, <span class="type">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sys_epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这才是真正的epoll_create啊~~ */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE1</span>(epoll_create1, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep = <span class="literal">NULL</span>;<span class="comment">//主描述符</span></span><br><span class="line">    <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">    <span class="comment">/* 这句没啥用处... */</span></span><br><span class="line">    <span class="built_in">BUILD_BUG_ON</span>(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line">    <span class="comment">/* 对于epoll来讲, 目前唯一有效的FLAG就是CLOEXEC */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the internal data structure (&quot;struct eventpoll&quot;).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 分配一个struct eventpoll, 分配和初始化细节我们随后深聊~ */</span></span><br><span class="line">    error = <span class="built_in">ep_alloc</span>(&amp;ep);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Creates all the items needed to setup an eventpoll file. That is,</span></span><br><span class="line"><span class="comment">     * a file structure and a free file descriptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 这里是创建一个匿名fd, 说起来就话长了...长话短说:</span></span><br><span class="line"><span class="comment">     * epollfd本身并不存在一个真正的文件与之对应, 所以内核需要创建一个</span></span><br><span class="line"><span class="comment">     * &quot;虚拟&quot;的文件, 并为之分配真正的struct file结构, 而且有真正的fd.</span></span><br><span class="line"><span class="comment">     * 这里2个参数比较关键:</span></span><br><span class="line"><span class="comment">     * eventpoll_fops, fops就是file operations, 就是当你对这个文件(这里是虚拟的)进行操作(比如读)时,</span></span><br><span class="line"><span class="comment">     * fops里面的函数指针指向真正的操作实现, 类似C++里面虚函数和子类的概念.</span></span><br><span class="line"><span class="comment">     * epoll只实现了poll和release(就是close)操作, 其它文件系统操作都有VFS全权处理了.</span></span><br><span class="line"><span class="comment">     * ep, ep就是struct epollevent, 它会作为一个私有数据保存在struct file的private指针里面.</span></span><br><span class="line"><span class="comment">     * 其实说白了, 就是为了能通过fd找到struct file, 通过struct file能找到eventpoll结构.</span></span><br><span class="line"><span class="comment">     * 如果懂一点Linux下字符设备驱动开发, 这里应该是很好理解的,</span></span><br><span class="line"><span class="comment">     * 推荐阅读 &lt;Linux device driver 3rd&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = <span class="built_in">anon_inode_getfd</span>(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">ep_free</span>(ep);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建好epollfd后, 接下来我们要往里面添加fd咯</span></span><br><span class="line"><span class="comment">* 来看epoll_ctl</span></span><br><span class="line"><span class="comment">* epfd 就是epollfd</span></span><br><span class="line"><span class="comment">* op ADD,MOD,DEL</span></span><br><span class="line"><span class="comment">* fd 需要监听的描述符</span></span><br><span class="line"><span class="comment">* event 我们关心的events</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE4</span>(epoll_ctl, <span class="type">int</span>, epfd, <span class="type">int</span>, op, <span class="type">int</span>, fd,</span><br><span class="line">        <span class="keyword">struct</span> epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *file, *tfile;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epds;</span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 错误处理以及从用户空间将epoll_event结构copy到内核空间.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ep_op_has_event</span>(op) &amp;&amp;</span><br><span class="line">        <span class="built_in">copy_from_user</span>(&amp;epds, event, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span></span><br><span class="line">    <span class="comment">/* 取得struct file结构, epfd既然是真正的fd, 那么内核空间</span></span><br><span class="line"><span class="comment">     * 就会有与之对于的一个struct file结构</span></span><br><span class="line"><span class="comment">     * 这个结构在epoll_create1()中, 由函数anon_inode_getfd()分配 */</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = <span class="built_in">fget</span>(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the target file */</span></span><br><span class="line">    <span class="comment">/* 我们需要监听的fd, 它当然也有个struct file结构, 上下2个不要搞混了哦 */</span></span><br><span class="line">    tfile = <span class="built_in">fget</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> (!tfile)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line">    <span class="comment">/* The target file descriptor must support poll */</span></span><br><span class="line">    error = -EPERM;</span><br><span class="line">    <span class="comment">/* 如果监听的文件不支持poll, 那就没辙了.</span></span><br><span class="line"><span class="comment">     * 你知道什么情况下, 文件会不支持poll吗?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check that the file structure underneath the file descriptor</span></span><br><span class="line"><span class="comment">     * the user passed to us _is_ an eventpoll file. And also we do not permit</span></span><br><span class="line"><span class="comment">     * adding an epoll file descriptor inside itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="comment">/* epoll不能自己监听自己... */</span></span><br><span class="line">    <span class="keyword">if</span> (file == tfile || !<span class="built_in">is_file_epoll</span>(file))</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 取到我们的eventpoll结构, 来自与epoll_create1()中的分配 */</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    <span class="comment">/* 接下来的操作有可能修改数据结构内容, 锁之~ */</span></span><br><span class="line">    <span class="built_in">mutex_lock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to lookup the file inside our RB tree, Since we grabbed &quot;mtx&quot;</span></span><br><span class="line"><span class="comment">     * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="comment">     * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 对于每一个监听的fd, 内核都有分配一个epitem结构,</span></span><br><span class="line"><span class="comment">     * 而且我们也知道, epoll是不允许重复添加fd的,</span></span><br><span class="line"><span class="comment">     * 所以我们首先查找该fd是不是已经存在了.</span></span><br><span class="line"><span class="comment">     * ep_find()其实就是RBTREE查找, 跟C++STL的map差不多一回事, O(lgn)的时间复杂度.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    epi = <span class="built_in">ep_find</span>(ep, tfile, fd);</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="comment">/* 首先我们关心添加 */</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">            <span class="comment">/* 之前的find没有找到有效的epitem, 证明是第一次插入, 接受!</span></span><br><span class="line"><span class="comment">             * 这里我们可以知道, POLLERR和POLLHUP事件内核总是会关心的</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            <span class="comment">/* rbtree插入, 详情见ep_insert()的分析</span></span><br><span class="line"><span class="comment">             * 其实我觉得这里有insert的话, 之前的find应该</span></span><br><span class="line"><span class="comment">             * 是可以省掉的... */</span></span><br><span class="line">            error = <span class="built_in">ep_insert</span>(ep, &amp;epds, tfile, fd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* 找到了!? 重复添加! */</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 删除和修改操作都比较简单 */</span></span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="keyword">if</span> (epi)</span><br><span class="line">            error = <span class="built_in">ep_remove</span>(ep, epi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = <span class="built_in">ep_modify</span>(ep, epi, &amp;epds);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOENT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">error_tgt_fput:</span><br><span class="line">    <span class="built_in">fput</span>(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">    <span class="built_in">fput</span>(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 分配一个eventpoll结构 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_alloc</span><span class="params">(<span class="keyword">struct</span> eventpoll **pep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="comment">/* 获取当前用户的一些信息, 比如是不是root啦, 最大监听fd数目啦 */</span></span><br><span class="line">    user = <span class="built_in">get_current_user</span>();</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    ep = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*ep), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(!ep))</span><br><span class="line">        <span class="keyword">goto</span> free_uid;</span><br><span class="line">    <span class="comment">/* 这些都是初始化啦 */</span></span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;ep-&gt;lock);</span><br><span class="line">    <span class="built_in">mutex_init</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;ep-&gt;wq);<span class="comment">//初始化自己睡在的等待队列</span></span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;ep-&gt;poll_wait);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;ep-&gt;rdllist);<span class="comment">//初始化就绪链表</span></span><br><span class="line">    ep-&gt;rbr = RB_ROOT;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    ep-&gt;user = user;</span><br><span class="line">    *pep = ep;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">free_uid:</span><br><span class="line">    <span class="built_in">free_uid</span>(user);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ep_insert()在epoll_ctl()中被调用, 完成往epollfd里面添加一个监听fd的工作</span></span><br><span class="line"><span class="comment"> * tfile是fd在内核态的struct file结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_insert</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event *event,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">struct</span> file *tfile, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error, revents, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ep_pqueue</span> epq;</span><br><span class="line">    <span class="comment">/* 查看是否达到当前用户的最大监听数 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">atomic_read</span>(&amp;ep-&gt;user-&gt;epoll_watches) &gt;=</span><br><span class="line">             max_user_watches))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    <span class="comment">/* 从著名的slab中分配一个epitem */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_***_alloc(epi_***, GFP_KERNEL)))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">/* Item initialization follow here ... */</span></span><br><span class="line">    <span class="comment">/* 这些都是相关成员的初始化... */</span></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;epi-&gt;rdllink);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;epi-&gt;fllink);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    <span class="comment">/* 这里保存了我们需要监听的文件fd和它的file结构 */</span></span><br><span class="line">    <span class="built_in">ep_set_ffd</span>(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 这个指针的初值不是NULL哦... */</span></span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="comment">/* Initialize the poll table using the queue callback */</span></span><br><span class="line">    <span class="comment">/* 好, 我们终于要进入到poll的正题了 */</span></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    <span class="comment">/* 初始化一个poll_table</span></span><br><span class="line"><span class="comment">     * 其实就是指定调用poll_wait(注意不是epoll_wait!!!)时的回调函数,和我们关心哪些events,</span></span><br><span class="line"><span class="comment">     * ep_ptable_queue_proc()就是我们的回调啦, 初值是所有event都关心 */</span></span><br><span class="line">    <span class="built_in">init_poll_funcptr</span>(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attach the item to the poll hooks and get current event bits.</span></span><br><span class="line"><span class="comment">     * We can safely use the file* here because its usage count has</span></span><br><span class="line"><span class="comment">     * been increased by the caller of this function. Note that after</span></span><br><span class="line"><span class="comment">     * this operation completes, the poll callback can start hitting</span></span><br><span class="line"><span class="comment">     * the new item.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 这一部很关键, 也比较难懂, 完全是内核的poll机制导致的...</span></span><br><span class="line"><span class="comment">     * 首先, f_op-&gt;poll()一般来说只是个wrapper, 它会调用真正的poll实现,</span></span><br><span class="line"><span class="comment">     * 拿UDP的socket来举例, 这里就是这样的调用流程: f_op-&gt;poll(), sock_poll(),</span></span><br><span class="line"><span class="comment">     * udp_poll(), datagram_poll(), sock_poll_wait(), 最后调用到我们上面指定的</span></span><br><span class="line"><span class="comment">     * ep_ptable_queue_proc()这个回调函数...(好深的调用路径...).</span></span><br><span class="line"><span class="comment">     * 完成这一步, 我们的epitem就跟这个socket关联起来了, 当它有状态变化时,</span></span><br><span class="line"><span class="comment">     * 会通过ep_poll_callback()来通知.</span></span><br><span class="line"><span class="comment">     * 最后, 这个函数还会查询当前的fd是不是已经有啥event已经ready了, 有的话</span></span><br><span class="line"><span class="comment">     * 会将event返回. */</span></span><br><span class="line">    revents = tfile-&gt;f_op-&gt;<span class="built_in">poll</span>(tfile, &amp;epq.pt);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check if something went wrong during the poll wait queue</span></span><br><span class="line"><span class="comment">     * install process. Namely an allocation for a wait queue failed due</span></span><br><span class="line"><span class="comment">     * high memory pressure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> error_unregister;</span><br><span class="line">    <span class="comment">/* Add the current item to the list of active epoll hook for this file */</span></span><br><span class="line">    <span class="comment">/* 这个就是每个文件会将所有监听自己的epitem链起来 */</span></span><br><span class="line">    <span class="built_in">spin_lock</span>(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="built_in">list_add_tail</span>(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    <span class="built_in">spin_unlock</span>(&amp;tfile-&gt;f_lock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Add the current item to the RB tree. All RB tree operations are</span></span><br><span class="line"><span class="comment">     * protected by &quot;mtx&quot;, and ep_insert() is called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 都搞定后, 将epitem插入到对应的eventpoll中去 */</span></span><br><span class="line">    <span class="built_in">ep_rbtree_insert</span>(ep, epi);</span><br><span class="line">    <span class="comment">/* We have to drop the new item inside our item list to keep track of it */</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span></span><br><span class="line">    <span class="comment">/* 到达这里后, 如果我们监听的fd已经有事件发生, 那就要处理一下 */</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        <span class="comment">/* 将当前的epitem加入到ready list中去 */</span></span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        <span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">        <span class="comment">/* 谁在epoll_wait, 就唤醒它... */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">            <span class="built_in">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="comment">/* 谁在epoll当前的epollfd, 也唤醒它... */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="built_in">atomic_inc</span>(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error_unregister:</span><br><span class="line">    <span class="built_in">ep_unregister_pollwait</span>(ep, epi);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to do this because an event could have been arrived on some</span></span><br><span class="line"><span class="comment">     * allocated wait queue. Note that we don&#x27;t care about the ep-&gt;ovflist</span></span><br><span class="line"><span class="comment">     * list, since that is used/cleaned only inside a section bound by &quot;mtx&quot;.</span></span><br><span class="line"><span class="comment">     * And ep_insert() is called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink))</span><br><span class="line">        <span class="built_in">list_del_init</span>(&amp;epi-&gt;rdllink);</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    kmem_***_free(epi_***, epi);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="comment"> * target file wakeup lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该函数在调用f_op-&gt;poll()时会被调用.</span></span><br><span class="line"><span class="comment"> * 也就是epoll主动poll某个fd时, 用来将epitem与指定的fd关联起来的.</span></span><br><span class="line"><span class="comment"> * 关联的办法就是使用等待队列(waitqueue)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="params"><span class="function">                 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi = <span class="built_in">ep_item_from_epqueue</span>(pt);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eppoll_entry</span> *pwq;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_***_alloc(pwq_***, GFP_KERNEL))) &#123;</span><br><span class="line">        <span class="comment">/* 初始化等待队列, 指定ep_poll_callback为唤醒时的回调函数,</span></span><br><span class="line"><span class="comment">         * 当我们监听的fd发生状态改变时, 也就是队列头被唤醒时,</span></span><br><span class="line"><span class="comment">         * 指定的回调函数将会被调用. */</span></span><br><span class="line">        <span class="built_in">init_waitqueue_func_entry</span>(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        <span class="comment">/* 将刚分配的等待队列成员加入到头中, 头是由fd持有的 */</span></span><br><span class="line">        <span class="built_in">add_wait_queue</span>(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        <span class="comment">/* nwait记录了当前epitem加入到了多少个等待队列中,</span></span><br><span class="line"><span class="comment">         * 我认为这个值最大也只会是1... */</span></span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is passed to the wait queue wakeup</span></span><br><span class="line"><span class="comment"> * machanism. It is called by the stored file descriptors when they</span></span><br><span class="line"><span class="comment"> * have events to report.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个是关键性的回调函数, 当我们监听的fd发生状态改变时, 它会被调用.</span></span><br><span class="line"><span class="comment"> * 参数key被当作一个unsigned long整数使用, 携带的是events.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="type">wait_queue_t</span> *wait, <span class="type">unsigned</span> mode, <span class="type">int</span> sync, <span class="type">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi = <span class="built_in">ep_item_from_wait</span>(wait);<span class="comment">//从等待队列获取epitem.需要知道哪个进程挂载到这个设备</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep = epi-&gt;ep;<span class="comment">//获取</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If the event mask does not contain any poll(2) event, we consider the</span></span><br><span class="line"><span class="comment">     * descriptor to be disabled. This condition is likely the effect of the</span></span><br><span class="line"><span class="comment">     * EPOLLONESHOT bit that disables the descriptor when an event is received,</span></span><br><span class="line"><span class="comment">     * until the next EPOLL_CTL_MOD will be issued.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Check the events coming with the callback. At this stage, not</span></span><br><span class="line"><span class="comment">     * every device reports the events in the &quot;key&quot; parameter of the</span></span><br><span class="line"><span class="comment">     * callback. We need to be able to handle both cases here, hence the</span></span><br><span class="line"><span class="comment">     * test for &quot;key&quot; != NULL before the event match test.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 没有我们关心的event... */</span></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !((<span class="type">unsigned</span> <span class="type">long</span>) key &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we are trasfering events to userspace, we can hold no locks</span></span><br><span class="line"><span class="comment">     * (because we&#x27;re accessing user memory, and because of linux f_op-&gt;poll()</span></span><br><span class="line"><span class="comment">     * semantics). All the events that happens during that period of time are</span></span><br><span class="line"><span class="comment">     * chained in ep-&gt;ovflist and requeued later on.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里看起来可能有点费解, 其实干的事情比较简单:</span></span><br><span class="line"><span class="comment">     * 如果该callback被调用的同时, epoll_wait()已经返回了,</span></span><br><span class="line"><span class="comment">     * 也就是说, 此刻应用程序有可能已经在循环获取events,</span></span><br><span class="line"><span class="comment">     * 这种情况下, 内核将此刻发生event的epitem用一个单独的链表</span></span><br><span class="line"><span class="comment">     * 链起来, 不发给应用程序, 也不丢弃, 而是在下一次epoll_wait</span></span><br><span class="line"><span class="comment">     * 时返回给用户.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">            epi-&gt;next = ep-&gt;ovflist;</span><br><span class="line">            ep-&gt;ovflist = epi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If this file is already in the ready list we exit soon */</span></span><br><span class="line">    <span class="comment">/* 将当前的epitem放入ready list */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink))</span><br><span class="line">        <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="comment">     * wait list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 唤醒epoll_wait... */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">        <span class="built_in">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="comment">/* 如果epollfd也在被poll, 那就唤醒队列里面的所有成员. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line">out_unlock:</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Implement the event wait interface for the eventpoll file. It is the kernel</span></span><br><span class="line"><span class="comment"> * part of the user space epoll_wait(2).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE4</span>(epoll_wait, <span class="type">int</span>, epfd, <span class="keyword">struct</span> epoll_event __user *, events,</span><br><span class="line">        <span class="type">int</span>, maxevents, <span class="type">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *file;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line">    <span class="comment">/* The maximum number of event must be greater than zero */</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* Verify that the area passed by the user is writeable */</span></span><br><span class="line">    <span class="comment">/* 这个地方有必要说明一下:</span></span><br><span class="line"><span class="comment">     * 内核对应用程序采取的策略是&quot;绝对不信任&quot;,</span></span><br><span class="line"><span class="comment">     * 所以内核跟应用程序之间的数据交互大都是copy, 不允许(也时候也是不能...)指针引用.</span></span><br><span class="line"><span class="comment">     * epoll_wait()需要内核返回数据给用户空间, 内存由用户程序提供,</span></span><br><span class="line"><span class="comment">     * 所以内核会用一些手段来验证这一段内存空间是不是有效的.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access_ok</span>(VERIFY_WRITE, events, maxevents * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    <span class="comment">/* 获取epollfd的struct file, epollfd也是文件嘛 */</span></span><br><span class="line">    file = <span class="built_in">fget</span>(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check that the file structure underneath the fd</span></span><br><span class="line"><span class="comment">     * the user passed to us _is_ an eventpoll file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="comment">/* 检查一下它是不是一个真正的epollfd... */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_file_epoll</span>(file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 获取eventpoll结构 */</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line">    <span class="comment">/* Time to fish for events ... */</span></span><br><span class="line">    <span class="comment">/* OK, 睡觉, 等待事件到来~~ */</span></span><br><span class="line">    error = <span class="built_in">ep_poll</span>(ep, events, maxevents, timeout);</span><br><span class="line">error_fput:</span><br><span class="line">    <span class="built_in">fput</span>(file);</span><br><span class="line">error_return:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个函数真正将执行epoll_wait的进程带入睡眠状态... */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_poll</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event __user *events,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span> maxevents, <span class="type">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res, eavail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">long</span> jtimeout;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait;<span class="comment">//等待队列</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Calculate the timeout by checking for the &quot;infinite&quot; value (-1)</span></span><br><span class="line"><span class="comment">     * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment">     * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 计算睡觉时间, 毫秒要转换为HZ */</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line">retry:</span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 如果ready list不为空, 就不睡了, 直接干活... */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We don&#x27;t have any available event to return to the caller.</span></span><br><span class="line"><span class="comment">         * We need to sleep here, and we will be wake up by</span></span><br><span class="line"><span class="comment">         * ep_poll_callback() when events will become available.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* OK, 初始化一个等待队列, 准备直接把自己挂起,</span></span><br><span class="line"><span class="comment">         * 注意current是一个宏, 代表当前进程 */</span></span><br><span class="line">        <span class="built_in">init_waitqueue_entry</span>(&amp;wait, current);<span class="comment">//初始化等待队列,wait表示当前进程</span></span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);<span class="comment">//挂载到ep结构的等待队列</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We don&#x27;t want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">             * a wakeup in between. That&#x27;s why we set the task state</span></span><br><span class="line"><span class="comment">             * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">/* 将当前进程设置位睡眠, 但是可以被信号唤醒的状态,</span></span><br><span class="line"><span class="comment">             * 注意这个设置是&quot;将来时&quot;, 我们此刻还没睡! */</span></span><br><span class="line">            <span class="built_in">set_current_state</span>(TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="comment">/* 如果这个时候, ready list里面有成员了,</span></span><br><span class="line"><span class="comment">             * 或者睡眠时间已经过了, 就直接不睡了... */</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* 如果有信号产生, 也起床... */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">signal_pending</span>(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 啥事都没有,解锁, 睡觉... */</span></span><br><span class="line">            <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/* jtimeout这个时间后, 会被唤醒,</span></span><br><span class="line"><span class="comment">             * ep_poll_callback()如果此时被调用,</span></span><br><span class="line"><span class="comment">             * 那么我们就会直接被唤醒, 不用等时间了...</span></span><br><span class="line"><span class="comment">             * 再次强调一下ep_poll_callback()的调用时机是由被监听的fd</span></span><br><span class="line"><span class="comment">             * 的具体实现, 比如socket或者某个设备驱动来决定的,</span></span><br><span class="line"><span class="comment">             * 因为等待队列头是他们持有的, epoll和当前进程</span></span><br><span class="line"><span class="comment">             * 只是单纯的等待...</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">            jtimeout = <span class="built_in">schedule_timeout</span>(jtimeout);<span class="comment">//睡觉</span></span><br><span class="line">            <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        <span class="comment">/* OK 我们醒来了... */</span></span><br><span class="line">        <span class="built_in">set_current_state</span>(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Is it worth to try to dig for events ? */</span></span><br><span class="line">    eavail = !<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="comment">     * there&#x27;s still timeout left over, we go trying again in search of</span></span><br><span class="line"><span class="comment">     * more luck.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 如果一切正常, 有event发生, 就开始准备数据copy给用户空间了... */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = <span class="built_in">ep_send_events</span>(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个简单, 我们直奔下一个... */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_send_events</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">struct</span> epoll_event __user *events, <span class="type">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ep_send_events_data</span> esed;</span><br><span class="line">    esed.maxevents = maxevents;</span><br><span class="line">    esed.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ep_scan_ready_list</span>(ep, ep_send_events_proc, &amp;esed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for</span></span><br><span class="line"><span class="comment"> *                      the scan code, to call f_op-&gt;poll(). Also allows for</span></span><br><span class="line"><span class="comment"> *                      O(NumReady) performance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @ep: Pointer to the epoll private data structure.</span></span><br><span class="line"><span class="comment"> * @sproc: Pointer to the scan callback.</span></span><br><span class="line"><span class="comment"> * @priv: Private opaque data passed to the @sproc callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: The same integer error code returned by the @sproc callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> (*sproc)(<span class="keyword">struct</span> eventpoll *,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">struct</span> list_head *, <span class="type">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi, *nepi;</span><br><span class="line">    <span class="built_in">LIST_HEAD</span>(txlist);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">     * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">mutex_lock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Steal the ready list, and re-init the original one to the</span></span><br><span class="line"><span class="comment">     * empty list. Also, set ep-&gt;ovflist to NULL so that events</span></span><br><span class="line"><span class="comment">     * happening while looping w/out locks, are not lost. We cannot</span></span><br><span class="line"><span class="comment">     * have the poll callback to queue directly on ep-&gt;rdllist,</span></span><br><span class="line"><span class="comment">     * because we want the &quot;sproc&quot; callback to be able to do it</span></span><br><span class="line"><span class="comment">     * in a lockless way.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* 这一步要注意, 首先, 所有监听到events的epitem都链到rdllist上了,</span></span><br><span class="line"><span class="comment">     * 但是这一步之后, 所有的epitem都转移到了txlist上, 而rdllist被清空了,</span></span><br><span class="line"><span class="comment">     * 要注意哦, rdllist已经被清空了! */</span></span><br><span class="line">    <span class="built_in">list_splice_init</span>(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">    <span class="comment">/* ovflist, 在ep_poll_callback()里面我解释过, 此时此刻我们不希望</span></span><br><span class="line"><span class="comment">     * 有新的event加入到ready list中了, 保存后下次再处理... */</span></span><br><span class="line">    ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now call the callback function.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 在这个回调函数里面处理每个epitem</span></span><br><span class="line"><span class="comment">     * sproc 就是 ep_send_events_proc, 下面会注释到. */</span></span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * During the time we spent inside the &quot;sproc&quot; callback, some</span></span><br><span class="line"><span class="comment">     * other events might have been queued by the poll callback.</span></span><br><span class="line"><span class="comment">     * We re-insert them inside the main ready-list here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 现在我们来处理ovflist, 这些epitem都是我们在传递数据给用户空间时</span></span><br><span class="line"><span class="comment">     * 监听到了事件. */</span></span><br><span class="line">    <span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We need to check if the item is already in the list.</span></span><br><span class="line"><span class="comment">         * During the &quot;sproc&quot; callback execution time, items are</span></span><br><span class="line"><span class="comment">         * queued into -&gt;ovflist but the &quot;txlist&quot; might already</span></span><br><span class="line"><span class="comment">         * contain them, and the list_splice() below takes care of them.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* 将这些直接放入readylist */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ep_is_linked</span>(&amp;epi-&gt;rdllink))</span><br><span class="line">            <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span></span><br><span class="line"><span class="comment">     * releasing the lock, events will be queued in the normal way inside</span></span><br><span class="line"><span class="comment">     * ep-&gt;rdllist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Quickly re-inject items left on &quot;txlist&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 上一次没有处理完的epitem, 重新插入到ready list */</span></span><br><span class="line">    <span class="built_in">list_splice</span>(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line">    <span class="comment">/* ready list不为空, 直接唤醒... */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">list_empty</span>(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="comment">         * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;wq))</span><br><span class="line">            <span class="built_in">wake_up_locked</span>(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 该函数作为callbakc在ep_scan_ready_list()中被调用</span></span><br><span class="line"><span class="comment"> * head是一个链表, 包含了已经ready的epitem,</span></span><br><span class="line"><span class="comment"> * 这个不是eventpoll里面的ready list, 而是上面函数中的txlist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ep_send_events_proc</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ep_send_events_data</span> *esed = priv;</span><br><span class="line">    <span class="type">int</span> eventcnt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> revents;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> __user *uevent;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We can loop without lock because we are passed a task private list.</span></span><br><span class="line"><span class="comment">     * Items cannot vanish during the loop because ep_scan_ready_list() is</span></span><br><span class="line"><span class="comment">     * holding &quot;mtx&quot; during this call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 扫描整个链表... */</span></span><br><span class="line">    <span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">         !<span class="built_in">list_empty</span>(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;</span><br><span class="line">        <span class="comment">/* 取出第一个成员 */</span></span><br><span class="line">        epi = <span class="built_in">list_first_entry</span>(head, <span class="keyword">struct</span> epitem, rdllink);</span><br><span class="line">        <span class="comment">/* 然后从链表里面移除 */</span></span><br><span class="line">        <span class="built_in">list_del_init</span>(&amp;epi-&gt;rdllink);</span><br><span class="line">        <span class="comment">/* 读取events,</span></span><br><span class="line"><span class="comment">         * 注意events我们ep_poll_callback()里面已经取过一次了, 为啥还要再取?</span></span><br><span class="line"><span class="comment">         * 1. 我们当然希望能拿到此刻的最新数据, events是会变的~</span></span><br><span class="line"><span class="comment">         * 2. 不是所有的poll实现, 都通过等待队列传递了events, 有可能某些驱动压根没传</span></span><br><span class="line"><span class="comment">         * 必须主动去读取. */</span></span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;<span class="built_in">poll</span>(epi-&gt;ffd.file, <span class="literal">NULL</span>) &amp;</span><br><span class="line">            epi-&gt;event.events;</span><br><span class="line">        <span class="keyword">if</span> (revents) &#123;</span><br><span class="line">            <span class="comment">/* 将当前的事件和用户传入的数据都copy给用户空间,</span></span><br><span class="line"><span class="comment">             * 就是epoll_wait()后应用程序能读到的那一堆数据. */</span></span><br><span class="line">            <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">                <span class="built_in">list_add</span>(&amp;epi-&gt;rdllink, head);</span><br><span class="line">                <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            eventcnt++;</span><br><span class="line">            uevent++;</span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">                <span class="comment">/* 嘿嘿, EPOLLET和非ET的区别就在这一步之差呀~</span></span><br><span class="line"><span class="comment">                 * 如果是ET, epitem是不会再进入到readly list,</span></span><br><span class="line"><span class="comment">                 * 除非fd再次发生了状态改变, ep_poll_callback被调用.</span></span><br><span class="line"><span class="comment">                 * 如果是非ET, 不管你还有没有有效的事件或者数据,</span></span><br><span class="line"><span class="comment">                 * 都会被重新插入到ready list, 再下一次epoll_wait</span></span><br><span class="line"><span class="comment">                 * 时, 会立即返回, 并通知给用户空间. 当然如果这个</span></span><br><span class="line"><span class="comment">                 * 被监听的fds确实没事件也没数据了, epoll_wait会返回一个0,</span></span><br><span class="line"><span class="comment">                 * 空转一次.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">list_add_tail</span>(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eventcnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ep_free在epollfd被close时调用,</span></span><br><span class="line"><span class="comment"> * 释放一些资源而已, 比较简单 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ep_free</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span> *rbp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epitem</span> *epi;</span><br><span class="line">    <span class="comment">/* We need to release all tasks waiting for these file */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitqueue_active</span>(&amp;ep-&gt;poll_wait))</span><br><span class="line">        <span class="built_in">ep_poll_safewake</span>(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">     * eventpoll_release_file() while we&#x27;re freeing the &quot;struct eventpoll&quot;.</span></span><br><span class="line"><span class="comment">     * We do not need to hold &quot;ep-&gt;mtx&quot; here because the epoll file</span></span><br><span class="line"><span class="comment">     * is on the way to be removed and no one has references to it</span></span><br><span class="line"><span class="comment">     * anymore. The only hit might come from eventpoll_release_file() but</span></span><br><span class="line"><span class="comment">     * holding &quot;epmutex&quot; is sufficent here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">mutex_lock</span>(&amp;epmutex);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walks through the whole tree by unregistering poll callbacks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (rbp = <span class="built_in">rb_first</span>(&amp;ep-&gt;rbr); rbp; rbp = <span class="built_in">rb_next</span>(rbp)) &#123;</span><br><span class="line">        epi = <span class="built_in">rb_entry</span>(rbp, <span class="keyword">struct</span> epitem, rbn);</span><br><span class="line">        <span class="built_in">ep_unregister_pollwait</span>(ep, epi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walks through the whole tree by freeing each &quot;struct epitem&quot;. At this</span></span><br><span class="line"><span class="comment">     * point we are sure no poll callbacks will be lingering around, and also by</span></span><br><span class="line"><span class="comment">     * holding &quot;epmutex&quot; we can be sure that no file cleanup code will hit</span></span><br><span class="line"><span class="comment">     * us during this operation. So we can avoid the lock on &quot;ep-&gt;lock&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 之所以在关闭epollfd之前不需要调用epoll_ctl移除已经添加的fd,</span></span><br><span class="line"><span class="comment">     * 是因为这里已经做了... */</span></span><br><span class="line">    <span class="keyword">while</span> ((rbp = <span class="built_in">rb_first</span>(&amp;ep-&gt;rbr)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        epi = <span class="built_in">rb_entry</span>(rbp, <span class="keyword">struct</span> epitem, rbn);</span><br><span class="line">        <span class="built_in">ep_remove</span>(ep, epi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mutex_unlock</span>(&amp;epmutex);</span><br><span class="line">    <span class="built_in">mutex_destroy</span>(&amp;ep-&gt;mtx);</span><br><span class="line">    <span class="built_in">free_uid</span>(ep-&gt;user);</span><br><span class="line">    <span class="built_in">kfree</span>(ep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* File callbacks that implement the eventpoll file behaviour */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> eventpoll_fops = &#123;</span><br><span class="line">    .release    = ep_eventpoll_release,</span><br><span class="line">    .poll       = ep_eventpoll_poll</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Fast test to see if the file is an evenpoll file */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">is_file_epoll</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f-&gt;f_op == &amp;eventpoll_fops;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* OK, eventpoll我认为比较重要的函数都注释完了... */</span></span><br></pre></td></tr></table></figure><h3 id="epoll介绍"><a href="#epoll介绍" class="headerlink" title="epoll介绍"></a>epoll介绍</h3><p>epoll是一种I/O事件通知机制 是linux内核实现I/O多路复用的一个实现<br>I/O多路复用是指在一个操作里同时监听多个输入输出源 在其中一个或多个输入输出源可用的时候返回 然后对其进行读写操作<br>简言之 epoll是一种当文件描述符的内核缓冲区非空的时候发出可读信号来通知 当写缓冲区不满的时候发出可写的信号通知的一种机制</p><h4 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h4><h5 id="int-epoll-create-int-size"><a href="#int-epoll-create-int-size" class="headerlink" title="int epoll_create(int size)"></a>int epoll_create(int size)</h5><p>内核产生一个epoll实例数据结构并返回一个文件描述符(fd) 这个描述符就是epoll实例的句柄 后面的两个接口都以它为中心(形参epfd)<br>size表示所要监视文件描述符的最大值 不过后来的linux版本中已经被弃用 同时size不能传0 会抛出 invalid argument的error</p><h5 id="int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)"></a>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</h5><p>将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span>&#123;</span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">//指向用户自定义数据</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">//注册的文件描述符</span></span><br><span class="line">    <span class="type">unint32_t</span> u32; <span class="comment">//32bit integer</span></span><br><span class="line">    <span class="type">uint64_t</span> u64; <span class="comment">//64bit integer</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epolll_event</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">//描述epoll事件</span></span><br><span class="line">    <span class="comment">//events域描述一组epoll事件 在epoll_ctl调用中解释为描述符所期望的epoll事件 可多选</span></span><br><span class="line"></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">//上面的union </span></span><br><span class="line">    <span class="comment">//data域是唯一能给出描述符信息的字段 所以在调用epoll_ctl加入一个需要检测的描述符时</span></span><br><span class="line">    <span class="comment">//一定要在data域写入描述符相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于需要监听的文件描述符的集合 epoll_ctl对红黑树进行管理 红黑树中的每个成员由描述符的值和所要监控的文件描述符指向的文件表项的引用等组成</p><p>op参数的操作类型有:<br>    1. epoll_ctl_add 向interest list添加一个需要监视的描述符<br>    2. epoll_ctl_del 从interest list中删除一个描述符<br>    3. epoll_ctl_mod 修改interest list中的一个描述符</p><p>struct epoll_event结构描述一个文件描述符的epoll行为 在使用epoll_wait()返回处于ready状态的描述符列表</p><p>常用epoll事件描述:<br>     epollin 描述符处于可读状态<br>     epollout 描述符处于可写状态<br>     epollpri 由带外数据触发 表示描述符有紧急的数据可读<br>     epollet 将epoll event通知模式设置为edge triggered 设置为边缘触发<br>     epolloneshot 第一次进行通知 之后不再监测 如果还想继续监测 就需要再次把这个socket加入到epoll队列中<br>     epollhup 本端描述符产生一个挂断事件 默认监测事件<br>     epollrdhup 对端描述符产生一个挂断事件<br>     epollerr 描述符产生错误时触发 默认监测事件</p><h5 id="int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)"></a>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</h5><p>阻塞等待注册的事件发生 返回事件的数目 并将触发的事件写入events数组中<br>epoll_wait返回值number是不会大于maxevents的 返回的是活跃客户端的数量 并且将这些活跃的客户端信息加入到events<br>events:用来记录被触发的events 大小和maxevents一致<br>maxevents:返回events的最大个数</p><p>处于ready状态的那些文件描述符会被复制进ready list中 epoll_wait()用于向用户进程返回ready list<br>events和maxevents两个参数描述一个由用户分配的struct epoll event数组 调用返回时 内核将ready list复制到这个数组中 并将实际复制的个数作为返回值<br>如果ready list比maxevents长就只能复制maxevents个成员</p><p>timeout:描述函数调用中阻塞时间上限 单位ms<br>    1. timeout = -1 表示调用将一直阻塞 直到有文件描述符进入ready状态或者捕捉到信号才返回<br>    2. timeout = 0  用于非阻塞检测是否有描述符处于ready状态 不管结果如何 调用都立即返回<br>    3. timeout &gt; 0  表示调用将最多持续timeout时间 如果期间有检测对象变为ready状态或捕捉到信号则返回 否则直到超时</p><h4 id="epoll的两种触发方式"><a href="#epoll的两种触发方式" class="headerlink" title="epoll的两种触发方式"></a>epoll的两种触发方式</h4><p>epoll监控多个文件描述符的I/O事件 epoll支持边缘触发(edge trigger ET)和水平触发(level trigger LT) 通过epoll_wait()等待I/O事件<br>如果当前没有可用事件就阻塞调用线程</p><p>select和poll只支持LT工作模式 epoll的默认工作模式是LT模式</p><h5 id="LT水平触发的时机"><a href="#LT水平触发的时机" class="headerlink" title="LT水平触发的时机"></a>LT水平触发的时机</h5><p>对于读操作 只要缓冲区不为空 LT模式返回读就绪<br>对于写操作 只要缓冲区还没满 LT模式返回写就绪<br>当被监控的文件描述符上有可读写事件发生时 epoll_wait()会通知处理程序去读写 如果这次没有把数据一次性全读完(读写缓冲区太小)<br>那么下次调用epoll_wait()时 它还会通知你在上次没读写完的文件描述符上继续读写 若你一直不去读写 它会一直通知你<br>若系统中有大量你不需要读写的文件描述符 而他们每次都返回 会大大降低处理程序检索自己关心的文件描述符的效率</p><h5 id="ET边缘触发的时机"><a href="#ET边缘触发的时机" class="headerlink" title="ET边缘触发的时机"></a>ET边缘触发的时机</h5><p>对于读操作<br>    1. 当缓冲区由不可读变为可读的时候(缓冲区由空变为不空的时候)<br>    2. 当有新数据到达的时候(缓冲区中的待读数据变多的时候)<br>    3. 当缓冲区内有数据可读 且应用程序对相应的文件描述符进行epoll_ctl_mod修改epollin事件时</p><p>对于写操作<br>    1. 当缓冲区由不可写变为可写时<br>    2. 当有旧数据被发送走 即缓冲区种数据变少的时候<br>    3. 当缓冲区有空间可写 且应用进程对相应的文件描述符进行epoll_ctl_mod修改epollout事件时</p><p>当被监控的文件描述符上有可读写事件发生时 epoll_wait()会通知处理程序去读写 如果这次没有把数据一次性全读完(读写缓冲区太小)<br>那么下次调用epoll_wait()时 那么下次调用epoll_wait()时 也就是它只会通知你一次 直到该文件描述符上出现第二次可读写事件才会通知你<br>这种模式比水平触发效率高 系统不会充斥大量你不关心的就绪文件描述符</p><p>在边缘触发的模式下 缓冲区从不可读变成可读 会唤醒应用进程 缓冲区数据变少的情况下不会再唤醒应用进程</p><p>For instance 1):<br>    1. 读缓冲区刚开始是空的<br>    2. 读缓冲区写入2KB数据<br>    3. 水平触发和边缘触发此时都会发出可读信号<br>    4. 收到信号通知后读取了1kb的数据 缓冲区还剩1kb<br>    5. 水平触发会再通知你继续读写 边缘触发不会再通知你</p><p>For instance 2):<br>    水平触发:0表示缓冲区无数据 1表示缓冲区有数据 缓冲区有数据则一直为1 就一直触发<br>    边缘触发:0表示缓冲区无数据 1表示缓冲区有数据 只有在0变为1的时候才触发</p><h4 id="epoll-select-poll比较"><a href="#epoll-select-poll比较" class="headerlink" title="epoll select poll比较"></a>epoll select poll比较</h4><h5 id="用户态将文件描述符传入内核的方式"><a href="#用户态将文件描述符传入内核的方式" class="headerlink" title="用户态将文件描述符传入内核的方式"></a>用户态将文件描述符传入内核的方式</h5><p>select: 创建3个文件描述符并拷贝到内核中 分别监听读/写/异常 这里单个进程可以打开的文件描述符fd数量默认限制为1024<br>poll: 将传入的struct pollfd结构体数组拷贝到内核中进行监听<br>epoll: 执行epoll_create会在内核的高速cache区域中建立一棵红黑树以及就绪链表(该链表存储已经就绪的文件描述符) 用户执行的epoll_ctl()添加文件描述符会在红黑树上增加相应的结点</p><h5 id="内核态检测文件描述符读写状态的方式"><a href="#内核态检测文件描述符读写状态的方式" class="headerlink" title="内核态检测文件描述符读写状态的方式"></a>内核态检测文件描述符读写状态的方式</h5><p>select: 采用轮询方式 遍历所有fd 最后返回一个描述符读写操作是否就绪的mask掩码 根据这个掩码给fd_set赋值<br>poll: 采用轮询方式 查询每个fd的状态 若就绪则在等待队列中加入一项并继续遍历<br>epoll: 采用回调机制 执行epoll_ctl的add操作时 不仅将文件描述符放进红黑树中 而且也注册了回调函数 内核在检测到某文件描述符可读/可写的时候会调用回调函数 该回调函数将fd放在就绪链表中</p><h5 id="找到就绪的文件描述符并传递给用户态的方式"><a href="#找到就绪的文件描述符并传递给用户态的方式" class="headerlink" title="找到就绪的文件描述符并传递给用户态的方式"></a>找到就绪的文件描述符并传递给用户态的方式</h5><p>select: 将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数 用户态并不知道是哪些文件描述符处于就绪态 需要遍历来判断<br>poll: 将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数 用户态并不知道是哪些文件描述符处于就绪态 需要遍历来判断<br>epoll: epoll_wait()只用观察就绪链表中有无数据就行 最后将链表的数据返回给数组并返回就绪的数量 内核将就绪的文件描述符放在传入的数组中 所以只用遍历依次处理即可 这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现的 减少了不必要的拷贝</p><h5 id="重复监听的处理方式"><a href="#重复监听的处理方式" class="headerlink" title="重复监听的处理方式"></a>重复监听的处理方式</h5><p>select: 将新的监听文件描述符集合拷贝传入内核中 继续以上步骤<br>poll: 将新的struct pollfd结构体数组拷贝传入内核中 继续以上步骤<br>epoll: 无需重新构建红黑树 直接沿用已存在的即可</p><h4 id="epoll比select-poll更高效的原因"><a href="#epoll比select-poll更高效的原因" class="headerlink" title="epoll比select/poll更高效的原因"></a>epoll比select/poll更高效的原因</h4><p>1.select采用fd标注位来存放 poll采用链表来进行文件描述符的存储 所以select会受到最大连接数的限制 poll就不会<br>2.select poll epoll虽然都会返回就绪的文件描述符数量 但select/poll并不会明确指出哪些fd处于就绪状态 epoll可以 系统调用返回后 调用select/poll的程序需要遍历监听的整个fd来找到谁处于就绪 epoll可以直接处理<br>3.select/poll都需要将有关文件描述符的数据结构拷贝进内核 最后再拷贝出来 而epoll创建的有关文件描述符的数据结构本身就存在内核态中 epoll使用mmap()减少复制开销<br>4.select/poll采用轮询方式来检查fd是否处于就绪态 epoll采用回调机制 随着fd的增加 select/poll的效率线性降低 epoll不会受到太大影响 除非活跃的socket太多<br>5.epoll的边缘触发机制效率高 系统不会充斥大量的不关心的就绪文件描述符<br>假如连接数少并且连接都十分活跃情况下 select/poll性能比epoll好 因为epoll的通知机制需要很多函数回调 </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 面试题集合</title>
      <link href="/2020/05/22/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/"/>
      <url>/2020/05/22/C-%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="std-function可以封装哪些实体-可以封装函数对象么"><a href="#std-function可以封装哪些实体-可以封装函数对象么" class="headerlink" title="std::function可以封装哪些实体 可以封装函数对象么"></a>std::function可以封装哪些实体 可以封装函数对象么</h2><p>std::function介绍<br>类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）<br>通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象；让我们不再纠结那么多的可调用实体。一切变的简单粗暴</p><span id="more"></span> <h2 id="为什么需要this指针"><a href="#为什么需要this指针" class="headerlink" title="为什么需要this指针"></a>为什么需要this指针</h2><p>this指针的作用是指向成员函数所作用的对象 所以非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针</p><h2 id="static和全局变量有什么区别"><a href="#static和全局变量有什么区别" class="headerlink" title="static和全局变量有什么区别"></a>static和全局变量有什么区别</h2><p>static变量和全局变量都是静态存储方式 static修饰的全局变量只在这个文件中有效 </p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        static int a=0;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">a&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>无法输出a 因为a是局部的静态变量</p><h2 id="左值引用-右值引用"><a href="#左值引用-右值引用" class="headerlink" title="左值引用 右值引用"></a>左值引用 右值引用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int &amp;b=a;//左值引用</span><br><span class="line">int &amp;var=10; 错误 无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中</span><br><span class="line">const int &amp;var=10; 可以</span><br><span class="line">int &amp;&amp;c=10;//右值引用 </span><br><span class="line">int &amp;&amp;c=a;  不可用 表达式错误 表达式a是左值</span><br></pre></td></tr></table></figure><p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。</p><h2 id="static-cast与强制类型转换的区别"><a href="#static-cast与强制类型转换的区别" class="headerlink" title="static_cast与强制类型转换的区别"></a>static_cast与强制类型转换的区别</h2><p>static_cast在编译时会进行类型检查，而强制转换不会。<br>并且 消除const属性用const_cast  基本类型转换用static_cast  多态类之间的类型转换用dynamic_cast 不同类型的指针类型转换有那个reinterpreter_cast</p><h2 id="用户态切换到内核态的方式"><a href="#用户态切换到内核态的方式" class="headerlink" title="用户态切换到内核态的方式"></a>用户态切换到内核态的方式</h2><p>1.系统调用<br>2.异常<br>3.外围设备终端</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Red-Blcak Tree</title>
      <link href="/2020/05/17/Red-Blcak-Tree/"/>
      <url>/2020/05/17/Red-Blcak-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一个能实现自平衡的二叉查找树<br>为何要引入红黑树:<br>首先来考虑一下二叉查找树 二叉查找树使用了二分查找的思想 查找所需的最大次数等同于二叉查找树的高度<br>但如果向二叉查找树一直插入一直比树结点更大或更小的值(例如结点由7 8 9  一直插入6 5 4 3 2 1) 二叉查找树就会失去平衡(1 2 3 4 5 6都是7的左孩子) 因此为了解决二叉查找树多次插入新结点导致的不平衡就需要引入红黑树</p><span id="more"></span> <div>    <button onclick="window.location.href='https://shaoyuanhangyes.github.io/2019/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91/'" style="border-color: #000;font-weight: 300;color: #f2f2f2;background: #000;">预备知识</button></div><h2 id="红黑树特点-规则"><a href="#红黑树特点-规则" class="headerlink" title="红黑树特点/规则"></a>红黑树特点/规则</h2><p>结点是红色或黑色<br>根结点一定是黑色的<br>每一个叶子结点(NIL)都是黑色<br>每个红色结点的两个子结点都是黑色<br>没有两个相邻的红色结点(红色结点不能有红色父结点和红色子结点 并没有说不能有两个连续的黑结点)<br>任意一个结点到其每个叶子结点(NIL)的路径都包含相同数目的黑色结点 简称为黑高</p><p>根据以上的几个规则作为限制 即可避免二叉查找树退化成单链表</p><h2 id="对红黑树进行操作要面临的五种局面"><a href="#对红黑树进行操作要面临的五种局面" class="headerlink" title="对红黑树进行操作要面临的五种局面"></a>对红黑树进行操作要面临的五种局面</h2><p>当插入或删除结点的时候 红黑树原有构造的规则会被打破 因此需要对红黑树做一些调整 从而继续维持红黑树的规则</p><p><img src="/2020/05/17/Red-Blcak-Tree/%E7%BA%A2%E9%BB%91%E6%A0%911.png" alt="红黑树例子"></p><p>向红黑树插入14结点  由于父结点15 是黑色结点 这种情况没有破坏红黑树规则 无需做任何调整</p><p><img src="/2020/05/17/Red-Blcak-Tree/%E7%BA%A2%E9%BB%91%E6%A0%912.png" alt="红黑树例子"></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Server_CPP notes</title>
      <link href="/2020/05/13/Server-CPP-notes/"/>
      <url>/2020/05/13/Server-CPP-notes/</url>
      
        <content type="html"><![CDATA[<p>项目地址 <code>https://github.com/shaoyuanhangyes/Server</code></p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><span id="more"></span> <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>#include&lt;unistd.h&gt;<br>pid_t pid 声明进程标识符pid</p><h3 id="进程复制函数-fork"><a href="#进程复制函数-fork" class="headerlink" title="进程复制函数 fork()"></a>进程复制函数 fork()</h3><p>fork函数只能被调用一次 却能返回两次 有三种不同的返回值<br>在父进程中fork返回新创建的子进程的id<br>在子进程中fork返回0<br>出现错误 返回-1 并设置errno<br>fork函数复制当前进程 在内核进程表中创建一个新的进程表项 新的进程表项有很多属性与原进程相同 比如堆栈的指针 标志寄存器的值 但也有属性变化<br>比如进程的ppid被设置为父进程的pid 信号位图被清楚 原进程设置的信号处理函数不再对子进程起作用<br>子进程代码与父进程代码完全相同 还复制了父进程的数据 但数据的复制只有在任意进程无论父子进程对数据进行了写操作的时候才会发送复制</p><h3 id="exec系列函数-替换系统映像"><a href="#exec系列函数-替换系统映像" class="headerlink" title="exec系列函数 替换系统映像"></a>exec系列函数 替换系统映像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path,const char *arg,...)/*path参数指定可执行文件的完整路径*/</span><br><span class="line">int execlp(const char *file,const char *arg,...)/*file参数指定可以接受文件名*/</span><br><span class="line">int execle(const char *path,const char *arg,...,char * const envp[])/*arg接受可变参数 argv接受参数数组*/</span><br><span class="line">int execv(const char *file,char *const argv[])</span><br><span class="line">int execve(const char *path,char *const argv[],char * const envp[])</span><br></pre></td></tr></table></figure><p>这些参数都会被传递给新程序的main函数中 envp参数用于设置新程序的环境变量<br>exec函数一般不返回值 除非出错误时返回-1并设置errno</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>对于多进程程序来说 父进程一般需要跟踪子进程的退出状态 因此 当子进程结束运行时 内核不会立即释放该进程的进程表项 这样来满足<br>父进程后续对该子进程退出信息的查询 在子进程结束运行后并且其父进程读取其退出状态前我们称之为子进程处于僵尸态<br>另外一种子进程进入僵尸态的情况是 父进程结束或者异常终止 但子进程却继续运行 此时子进程的ppid被系统设置为1 即init进程<br>init进程接管了该子进程 并等待他结束 在父进程退出后子进程退出前该子进程是处于僵尸态<br>所以僵尸态就是父进程没有正确处理子进程返回的信息并且子进程依旧占据着内核资源</p><h3 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h3><p>管道是进程内部通信的方式 管道也是父进程和子进程间通信的常用手段 利用的是fork调用后两个管道文件描述符(fd[0] fd[1])都保持打开<br>一堆这样的文件描述符只能保证父子进程间一个方向的数据传输 父进程和子进程必须有一个关闭fd[0] 另一个关闭fd[1]<br>显然 要实现父子进程间的双向数据传输就必须使用两个管道</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>#include&lt;sys/sem.h&gt;<br>信号量也是进程间通信的方式 确保某一时刻只有一个进程能进入关键代码段 linux的信号量的API都定义在sys/sem.h中<br>主要包含三个系统调用 semget semop semctl被设计为操作一组信号量集<br>semget(key_t key,int num_sems,int sem_flags)<br>key是一个键值<br>num_sems参数指定信号量集中信号量的数目 创建信号量则该值必须被指定 如果是获取已经存在的信号量 则可以吧它设置为0<br>sem_flags参数指定一组标志 </p><p>semop系统调用改变信号量的值 就是执行PV操作<br>semop(int sem_id,struct sembuf *sem_ops,size_t num_sem_ops)<br>sem_id是semget调用返回的信号量集标识符 用以指定被操作的目标信号量集 sem_ops指向一个sembuf结构体类型的数组 </p><p>semctl(int sem_id,int sem)num,int command</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>#include&lt;sys/shm.h&gt;<br>共享内存是最高效的IPC机制 因为它不涉及进程之间的任何数据传输<br>这种高效率的问题是我们必须用其他的辅助手段来同步进程对共享内存的访问<br>4个系统调用 shmget shmat shmdt shmctl<br>int shmget(key_t key,size_t size,int shmflg)<br>shmget系统调用创建一段新的共享内存 或者获取一段已经存在的共享内存<br>key来标识一段全局唯一的共享内存 size指定共享内存的字节 获取存在的共享内存时size设置为0<br>共享内存被创建/获取之后不能立即访问它 而是需要先将它关联到进程的地址空间中 使用完共享内存后我们需要将它从进程地址空间中分离<br>关联用void *shamt(int shm_id,const void *shm_addr,int shmflg) shm_id是由shmget调用返回的共享内存标识符 shm_addr参数指定将共享内存关联到进程的哪块地址空间 shm_addr推荐设置为NULL 由操作系统选择<br>分离用shmdt(const void *shm_addr)</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>#include&lt;sys/msg.h&gt;<br>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式 每个数据块都有特定的类型 接收方根据类型来有选择的接收数据 而不一定像管道和命名管道那样必须以先进先出的方式接收数据<br>int msgget(key_t key,int msgflg) 创建消息队列<br>int msgsnd(int msgid,const void *msg_ptr,size_t msg_sz,int msgflg) msgsnd把一条消息添加到消息队列中 msg_ptr指向一个准备发送的消息<br>要发送的消息是一个结构体 struct msgbuf 里包含消息类型mtype 消息数据 mtext[512]数组 msgflg控制msgsnd的行为 支持以非阻塞的方式发送消息 如果发送消息的时候消息队列满了 msgsnd就阻塞</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>#include&lt;pthread.h&gt;<br>创建线程pthread_create();<br>int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(<em>start_routine),(void</em>) arg);<br>attr用于设置线程的属性 设置为NULL表示使用默认线程属性 start_routine指向线程将要运行的函数 arg为其参数<br>start_routine指向的要运行的函数在类里必须是静态static 返回值必须是void *<br>create成功返回0 失败返回错误码<br>线程一旦创建好 内核就可以调度内核线程来执行start_routine函数指针所指向的函数<br>结束线程 void pthread_exit(void *retval) 通过retval参数向线程的回收者传递其退出信息 执行完不会返回到调用者 而且永远不会失败<br>linux线程有两种状态 joinable/unjoinable 线程是joinable状态时 线程函数自己返回退出时或pthread_exit时都不会释放线程所占用的资源 只有调用了pthread_join()后才会释放 若是unjoinable状态的线程在线程函数退出或pthread_exit时会被自动释放 unjoinable属性可以在pthread_create时设置 </p><p>pthread_join(pthread_t thread, void** retval) 一个进程中的所有线程都可以调用pthread_join()来回收其他可回收的线程<br>thread为要回收的目标线程标识符<br>retval参数是目标线程返回的退出信息 成功返回0 失败返回错误码<br>EDEADLK:可能引起死锁 比如两个线程相互针对对方调用pthread_join 或者线程对自身调用pthread_join<br>EINVAL: 目标线程不可回收 或已经有其他线程正在回收目标线程<br>ESRCH: 目标线程不存在</p><p>pthread_cancel(pthread_t pthread) 异常终止一个线程 即取消线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *<span class="function"><span class="title">syh</span></span>()&#123;</span><br><span class="line">  cout&lt;<span class="string">&quot;多线程&quot;</span>&lt;&lt;<span class="string">endl</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">pthread_t tids;</span></span><br><span class="line"><span class="string">int ret=pthread_create(&amp;tids,NULL,syh,NULL);</span></span><br></pre></td></tr></table></figure><p>用户创建的线程总数不能超过threads_max内核参数定义的值<br>int pthread_detach (pthread_t __th)</p><h3 id="在多线程中调用fork函数"><a href="#在多线程中调用fork函数" class="headerlink" title="在多线程中调用fork函数"></a>在多线程中调用fork函数</h3><p>若一个多线程程序的某个线程调用了fork函数 那么新的进程是否将自动创建和父进程相同数量的线程呢<br>答:否 新创建的子进程只拥有一个执行线程 就是调用fork的那个线程的复制 并且子进程将自动继承父进程中互斥锁的状态<br>即 父进程中被加锁的互斥锁在子进程中也是被锁住的<br>那么问题来了: 子进程不清楚从父进程继承来的互斥锁的状态 这个互斥锁可能加锁了 但不是由调用fork函数的那个线程锁住的 而是由其他线程锁住<br>若这种情况下 子进程再次对该互斥锁执行加锁操作就会导致死锁<br>函数pthread_atfork(void *(prepare)(void),void *parent,void *child) 会确保调用后父进程和子进程都有一个清楚的锁状态<br>prepare句柄将在fork调用创建出子进程之前被执行 它可以用来锁住所有父进程中的互斥锁 parent句柄则是fork调用创建出子进程之后 fork返回之前 在子进程中执行 child句柄用于释放所有在prepare句柄中被锁住的互斥锁 函数成功返回0 失败返回错误码</p><h3 id="多线程下的信号"><a href="#多线程下的信号" class="headerlink" title="多线程下的信号"></a>多线程下的信号</h3><p>#include&lt;pthread.h&gt;<br>#include&lt;signal.h&gt;<br>int pthread_sigmask(int how, const sigset_t *newmask,sigset_t *oldmask);<br>由于进程中的所有线程共享该进程的信号 所以线程库将根据线程掩码决定把信号发送给哪个具体的线程 因此 若在每个子线程中都单独设置信号掩码 就容易产生逻辑错误 此外 所有线程共享信号处理函数 也就是说一个线程中设置了某个信号的信号处理函数 它将覆盖其他线程为同一个信号设置的信号处理函数 所以我们应该定义一个专门的线程来处理所有的信号<br>第一步 在主线程创建出其他线程之前就调用pthread_sigmask来设置好信号掩码 所有新创建的子线程都将自动继承这个信号掩码 这样之后所有线程都不会响应被屏蔽的信号了<br>第二步 在某个线程中调用int sigwait(const sigset_t *set, int *sig)<br>set参数指定需要等待信号的集合 即第一步创建的信号掩码 表示该线程中等待所有被屏蔽的信号 参数sig指向的整数用于存储该函数返回的信号值 sigwait成功时返回0 失败返回错误码 一旦sigwait正确返回我们就可以对接收到的信号做处理了 如果我们用了sigwait 就不应该在为信号设置信号处理函数了<br>pthread_kill(pthread_t thread,int sig) 将一个信号发送给指定的目标线程thread sig指定待发送的信号 sig=0时 则pthread_kill不发送信号 但仍会执行错误检查 我们可以用这种方式来检测目标线程是否存在 pthread_kill成功时返回0 失败返回错误码</p><h2 id="locker-h"><a href="#locker-h" class="headerlink" title="locker.h"></a>locker.h</h2><h3 id="信号量-class-sem"><a href="#信号量-class-sem" class="headerlink" title="信号量 class sem"></a>信号量 class sem</h3><p>#include&lt;semaphore.h&gt;<br>创建信号量sem_t sem<br>sem_t是一个union<br>源代码原型为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef union</span><br><span class="line">&#123;</span><br><span class="line">  char __size[__SIZEOF_SEM_T];//<span class="comment"># define __SIZEOF_SEM_T32</span></span><br><span class="line">  long int __align;</span><br><span class="line">&#125; sem_t;</span><br></pre></td></tr></table></figure><h4 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init()"></a>sem_init()</h4><p>函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sem_init (sem_t *__sem, int __pshared, unsigned int __value);</span><br></pre></td></tr></table></figure><p>用于初始化一个信号量sem 并给他一个初始整数值value pshared控制信号量的类型 pshared=0表示该信号量sem用于多线程的同步 pshared&gt;0表示可以共享 用于多个进程间的同步(参数 pshared &gt; 0 时指定了 sem 处于共享内存区域，所以可以在进程间共享该变量)</p><h4 id="sem-destroy"><a href="#sem-destroy" class="headerlink" title="sem_destroy()"></a>sem_destroy()</h4><p>函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sem_destroy(sem_t *__sem);</span><br></pre></td></tr></table></figure><p>用于销毁信号量sem</p><h4 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait()"></a>sem_wait()</h4><p>函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sem_wait (sem_t *__sem);</span><br></pre></td></tr></table></figure><p>sem_wait()是一个阻塞的函数 操作是原子操作 若sem的value&gt;0 则value-1 并立即返回 若value=0 就一直阻塞到value&gt;0<br>有个功能相近的函数 sem_trywait()是非阻塞的函数 会尝试获取sem的value值 如果sem的value=0 不阻塞 立即返回一个错误 值为EAGAIN</p><h4 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post()"></a>sem_post()</h4><p>函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sem_post (sem_t *__sem);</span><br></pre></td></tr></table></figure><p>操作是原子操作 把sem的value+1 并唤醒正在等待该信号量的任意线程</p><h4 id="sem-getvalue"><a href="#sem-getvalue" class="headerlink" title="sem_getvalue()"></a>sem_getvalue()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval);</span><br></pre></td></tr></table></figure><p>获取信号量的当前值 并将值保存在sbal中 若有一个或多个线程正在调用sem_wait()阻塞在此信号量上 该函数返回阻塞的进程/线程个数</p><h3 id="互斥锁-class-locker"><a href="#互斥锁-class-locker" class="headerlink" title="互斥锁 class locker"></a>互斥锁 class locker</h3><p>互斥锁是信号量的一个特殊情况(n=1)<br>#include&lt;pthread.h&gt;<br>创建互斥锁pthread_mutex_t mutex;<br>互斥锁的类型：<br>1.普通锁 pthread_mutex_timed mutex加锁后其余请求的线程按照申请时间的顺序形成一个等待队列<br>也就是第一次上锁成功 第二次上锁会阻塞<br>2.嵌套锁 pthread_mutex_recursive 也是递归锁<br>允许同一个线程对同一个锁获得多次 并可以解锁多次 如果是不同线程请求 就在加锁线程解锁时重新竞争<br>也就是第一次上锁成功 第二次上锁也成功<br>3.检错锁 pthread_mutex_errorcheck 如果线程在不解锁的状态下尝试重新上锁 会返回错误<br>也就是第一次上锁成功 第二次上锁失败</p><h4 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init()"></a>pthread_mutex_init()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_init (pthread_mutex_t *__mutex,const pthread_mutexattr_t *__mutexattr);</span><br></pre></td></tr></table></figure><p>用于动态初始化互斥锁 参数attr指定了互斥锁的属性 若attr为NULL 则互斥锁属性为默认的快速互斥锁 不同属性的锁类型在试图对一个已经被锁定的互斥锁加锁表现不同 初始化成功后返回0 并把互斥锁mutex初始化为未被锁住的状态<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER 用于静态初始化互斥锁</p><h4 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy()"></a>pthread_mutex_destroy()</h4><p>函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_destroy (pthread_mutex_t *__mutex);</span><br></pre></td></tr></table></figure><p>用于注销一个互斥锁mutex 释放mutex占用的资源 要求锁当前处于未被锁住的状态</p><h4 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock()"></a>pthread_mutex_lock()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_lock (pthread_mutex_t *__mutex)</span><br></pre></td></tr></table></figure><p>上锁 执行成功返回0<br>若mutex已被锁住 调用这个函数的线程进入阻塞态 直到mutex可用为止<br>pthread_mutex_trylock()也可以用来上锁 不同在于 如果mutex已被其他线程占据锁住的时候并不挂起等待 而是返回EBUSY</p><h4 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock()"></a>pthread_mutex_unlock()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_unlock (pthread_mutex_t *__mutex)</span><br></pre></td></tr></table></figure><p>解锁</p><h4 id="pthread"><a href="#pthread" class="headerlink" title="pthread_"></a>pthread_</h4><h3 id="条件变量-class-cond"><a href="#条件变量-class-cond" class="headerlink" title="条件变量 class cond"></a>条件变量 class cond</h3><p>若形容互斥锁是用于同步线程对共享数据的访问的话 那么条件变量则是用于在线程之间同步共享数据的值 条件变量提供了一种线程间的通知机制:当某个共享数据达到某个值的时候就唤醒等待这个共享数据的线程<br>#include&lt;pthread.h&gt;<br>pthread_cond_t cond 条件变量cond</p><h4 id="pthread-cond-init"><a href="#pthread-cond-init" class="headerlink" title="pthread_cond_init()"></a>pthread_cond_init()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_init (pthread_cond_t *__restrict __cond,const pthread_condattr_t *__restrict __cond_attr)</span><br></pre></td></tr></table></figure><p>初始化一个条件变量cond 参数attr是一个指针 指向类型为union的pthread_condattr_t 参数为空指针NULL时 表示函数创建的是默认的条件变量<br>函数执行成功返回0</p><h4 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy()"></a>pthread_cond_destroy()</h4><p>销毁一个条件变量cond</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_destroy (pthread_cond_t *__cond)</span><br></pre></td></tr></table></figure><h4 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait()"></a>pthread_cond_wait()</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait (pthread_cond_t *__restrict __cond,pthread_mutex_t *__restrict __mutex)</span><br></pre></td></tr></table></figure><p>用于等待目标条件变量 mutex是用于保护条件变量的互斥锁 确保wait操作的原子性<br>调用pthread_cond_wait()前必须保证mutex已经加锁 执行时 首先把调用线程放入条件变量的等待队列中 然后将mutex解锁(这样pthread_cond_signal/broadcast不会修改条件变量) wait函数成功返回时 mutex会再被锁上</p><h4 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast()"></a>pthread_cond_broadcast()</h4><p>以广播形式唤醒所有等待目标条件变量cond的线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_broadcast (pthread_cond_t *__cond);</span><br></pre></td></tr></table></figure><h4 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal()"></a>pthread_cond_signal()</h4><p>唤醒一个等待目标条件变量的线程 至于唤醒哪一个线程 取决于线程的优先级和调度策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_signal (pthread_cond_t *__cond)</span><br></pre></td></tr></table></figure><p>如何唤醒一个指定的线程(系统并未提供方法):定义一个能够唯一表示目标线程的全局变量 在唤醒等待条件变量的线程前先设置该变量为目标线程<br>然后采用广播的方式唤醒所有等待条件变量的线程 这些线程被唤醒后都检查该变量以判断被唤醒的是否是自己 如果是就开始执行后续代码 不是就返回继续等待</p><h3 id="线程池-threadpool-h"><a href="#线程池-threadpool-h" class="headerlink" title="线程池 threadpool.h"></a>线程池 threadpool.h</h3><h3 id="http-conn-h"><a href="#http-conn-h" class="headerlink" title="http_conn.h"></a>http_conn.h</h3><h4 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h4><p>HTTP有两种报文<br>请求报文:客户向服务器发送请求报文<br>响应报文:服务器应答客户的报文<br>请求报文和响应报文都是由三个部分组成 区别是开始行不同</p><h5 id="开始行"><a href="#开始行" class="headerlink" title="开始行"></a>开始行</h5><p>用于区分请求报文和响应报文 请求报文中的开始行叫请求行 响应报文中的开始行叫状态行<br>HTTP请求报文由请求行 请求头部 空行 请求数据 四个部分组成<br>HTTP响应报文由状态行 消息报头 空行 相应正文 四个部分组成<br>请求行包含了请求方法+空格+URL+空格+HTTP版本+CRLF(回车换行)<br>状态行包含了HTTP版本+空格+状态码+短语+CRLF</p><h5 id="GET请求报文"><a href="#GET请求报文" class="headerlink" title="GET请求报文"></a>GET请求报文</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1   <span class="comment">#请求行</span></span><br><span class="line">Host:img.mukewang.com                        <span class="comment">#空行前都是请求头部</span></span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) <span class="comment">#HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等</span></span><br><span class="line">AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept:image/webp,image/*,*/*;q=0.8 <span class="comment">#说明用户代理可处理的媒体类型。</span></span><br><span class="line">Referer:http://www.imooc.com/</span><br><span class="line">Accept-Encoding:gzip, deflate, sdch          <span class="comment">#说明用户代理可处理的媒体类型。</span></span><br><span class="line">Accept-Language:zh-CN,zh;q=0.8               <span class="comment">#说明用户代理能够处理的自然语言集。</span></span><br><span class="line">空行</span><br><span class="line">请求数据为空  <span class="comment">#请求数据也叫主体</span></span><br></pre></td></tr></table></figure><h5 id="POST请求报文"><a href="#POST请求报文" class="headerlink" title="POST请求报文"></a>POST请求报文</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1 <span class="comment">#请求行</span></span><br><span class="line">Host:www.wrox.com  <span class="comment">#空行前是请求头部</span></span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">空行</span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley <span class="comment">#请求数据</span></span><br></pre></td></tr></table></figure><h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK    <span class="comment">#状态行 由HTTP版本号 状态码 状态消息 组成</span></span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT  <span class="comment">#二三行为消息报头 说明客户端要使用的信息</span></span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">空行</span><br><span class="line">&lt;html&gt; <span class="comment">#响应正文</span></span><br><span class="line">&lt;<span class="built_in">head</span>&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--body goes here--&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="http报文处理流程"><a href="#http报文处理流程" class="headerlink" title="http报文处理流程"></a>http报文处理流程</h4><p>浏览器端发出http连接请求 主线程创建http对象接收请求 并将所有数据读入对应buffer中(read_once函数) 将该对象插入任务队列 工作线程从任务队列中取出一个任务进行处理<br>工作线程取出任务后 调用process_read() 通过主/从状态机对请求报文进行解析<br>解析完成后 跳转到do_request()生成响应报文 并通过process_write()写入buffer 返回给浏览器端 </p><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>主状态机对每一行数据进行解析 内状态机负责读取报文的每一行</p><h5 id="从状态机-parse-line"><a href="#从状态机-parse-line" class="headerlink" title="从状态机 parse_line()"></a>从状态机 parse_line()</h5><p>process_read()驱动parse_line()检查报文语法 如果语法错误 返回Line_Bad 报文结束的最后有\r\n字符 检测到报文有\r\n就返回Line_Ok表示接收完毕<br>然后通过循环来不停的返回状态 驱动主状态机解析报文request headers content</p><h5 id="主状态机"><a href="#主状态机" class="headerlink" title="主状态机"></a>主状态机</h5><p>parse_request_line(char *text) 解析http报文的请求行 获得请求方法，目标url及http版本号 各个部分通过空格或\t隔开 解析完将m_check_state转移到分析http头部信息<br>parse_headers(char *text) 解析http请求报文的头部 包括Connection keep-live Content-length Host<br>parse_content(char *text) 解析http主体消息 因为get请求报文消息体是空的 所以解析消息体一定是post请求<br>解析完消息体就会跳转到do_request()报文响应 来进行检测登录和注册检测 标志位 *(p+1)<br>*(p+1)=3就跳转到注册页面log.html 先检测数据库中是否有重名 如果没有就增加数据 如果重名就跳转到registerError.html页面提示重复注册<br>*(p+1)=2就是登录 若浏览器端输入的用户名和密码能被查询到 就返回1 跳转到welcome页面 查询不到返回0调转到logError.html页面</p><h5 id="响应报文处理"><a href="#响应报文处理" class="headerlink" title="响应报文处理"></a>响应报文处理</h5><p>无论是从状态机给出Bad_Request还是解析完报文进入do_request() 服务器子线程最后都会进入process_write() process_write包括add_status_line(状态行) add_headers(消息报头) add_blank_line(空行) m_file_adress(响应正文) 响应报文写入iovec[] 主线程通过write()返回响应报文发送到浏览器端</p><h3 id="lst-timer-h-定时器"><a href="#lst-timer-h-定时器" class="headerlink" title="lst_timer.h 定时器"></a>lst_timer.h 定时器</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>设计模式是一套被反复使用的 经过分类的 代码设计经验的总结 为了重用代码 使代码更易被他人理解 </p><span id="more"></span> <p>根据设计模式参考书 <code>Design Patterns - Elements of Reusable Object-Oriented Software</code><br>一共介绍了23中设计模式 这些模式可以分为三大类<br>创建型模式(Creational Patterns) 结构型模式(Structural Patterns) 行为型模式(Behavioral Patterns)</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式(Singleton Pattern) 单例类只能有一个对象被创建 同时必须自己创建自己的唯一对象 </p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式(Factory Pattern)</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System</title>
      <link href="/2020/05/04/Operating-System/"/>
      <url>/2020/05/04/Operating-System/</url>
      
        <content type="html"><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程Process"><a href="#进程Process" class="headerlink" title="进程Process"></a>进程Process</h3><p>进程是资源分配的基本单位<br>进程控制块(Process Control Block)PCB描述进程的基本信息和运行状态 进程是抢占式抢夺CPU</p><span id="more"></span><h3 id="线程Thread"><a href="#线程Thread" class="headerlink" title="线程Thread"></a>线程Thread</h3><p>线程是资源调度的基本单位<br>一个进程中可以有多个线程 它们共享进程资源 共享进程的内存地址空间</p><h3 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h3><ol><li>进程是资源分配的基本单位 但是线程不拥有资源 线程可以访问进程的资源</li><li>线程是独立调度的基本单位 在同一进程中的线程切换不会引起进程切换 从一个进程中的线程切换到另一个进程的线程时会引起进程切换</li><li>创建或撤销进程时系统需要分配和回收资源 开销比创建撤销线程要大 进程的切换需要涉及当前执行进程CPU环境的保存以及新调度进程的设置 而线程切换时只需要保存和设置少量寄存器内容 开销小</li><li>线程间可以通过直接读写同一进程中的数据进行通信 但进程通信需要借助IPC</li></ol><h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><div style="width: 600px;height: 550px;">    ![进程状态](进程状态.png)</div><p>就绪状态:等待被调度<br>阻塞状态:等待资源分配</p><p>就绪状态和运行状态可以互相转化 就绪状态的进程通过进程调度算法获得CPU时间转为运行状态<br>运行状态的进程在分配给它的CPU时间片用完之后就会转为就绪状态 等待下一次调度<br>阻塞状态是缺少需要的资源从而由运行状态转换而来 资源不包括CPU时间 缺少CPU时间会从运行状态变为就绪状态</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><h5 id="先来先服务first-come-first-serverd（FCFS）"><a href="#先来先服务first-come-first-serverd（FCFS）" class="headerlink" title="先来先服务first-come first-serverd（FCFS）"></a>先来先服务first-come first-serverd（FCFS）</h5><p>按照请求的顺序进行调度<br>不利于短作业 因为短作业必须一直等待前面的长作业执行完毕才能执行 短作业等待时间过长</p><h5 id="短作业优先shortest-job-first（SJF）"><a href="#短作业优先shortest-job-first（SJF）" class="headerlink" title="短作业优先shortest job first（SJF）"></a>短作业优先shortest job first（SJF）</h5><p>按估计运行时间最短的顺序进行调度<br>不利于长作业 长作业处于抑制等待短作业执行完毕 如果一直有短作业到来 长作业永远等不到调度</p><h5 id="最短剩余时间优先shortest-remaining-time-next（SRTN"><a href="#最短剩余时间优先shortest-remaining-time-next（SRTN" class="headerlink" title="最短剩余时间优先shortest remaining time next（SRTN)"></a>最短剩余时间优先shortest remaining time next（SRTN)</h5><p>短作业优先的抢占式调度算法 按剩余的运行时间的长短顺序进行调度 当一个新作业到达时 将其整个运行时间与当前进程的剩余时间进行比较 如果新的进程需要时间更少 就挂起当前进程运行新的进程 否则新的进程等待</p><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><h5 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h5><p>将所有就绪进程按照先来先服务的顺序排成一个队列 每次调度时把CPU时间分配给队首进程 时间片用完后计时器发出时钟中断 调度程序停止该进程的执行 并将运行进程送到就绪队列的尾部 同时把CPU时间分配给下一个队首进程<br>时间片轮转算法的效率和时间片的大小有关系<br>时间片过小 会导致进程切换频繁 在进程切换上耗费太多时间 时间片过长 实时性无法得到保证</p><h5 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h5><p>为每一个进程设置优先级 按优先级进行调度顺序<br>防止低优先级进程永远得不到调度 可设置随时间增加提升进程的优先级</p><h5 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h5><p>每一个时间片轮转的队列设置不同的时间片 越向下一级时间片越长 每个队列的优先权也不同 最上面的队列优先权最高<br>可看做时间片轮转调度和优先级调度算法的结合</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>对临界资源进行访问的那段代码为临界区</p><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>多个进程在同一时刻只有一个近程能进入临界区</p><h4 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore)"></a>信号量(Semaphore)</h4><p>信号量由一个值和一个指针组成 指针指向等待该信号量的进程 信号量的值表示相应资源的使用情况<br>用来保证临界区代码不被并发调用 在进入临界区前 线程必须获取一个信号量 离开临界区线程必须释放信号量</p><h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><p>信号量S&gt;=0 S表示可用资源的数量 执行一次P操作=请求分配一个资源 S的值减一<br>信号量S&lt;0 表示没有可用资源 S的绝对值表示当前等待该资源的进程数 请求者必须等待其他进程释放该类资源才能继续运行<br>执行一个V操作=释放一个资源 S的值加一<br>信号量的值只能通过pv操作来改变</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><h5 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h5><h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><h5 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h5><h4 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h4><h5 id="基本分页"><a href="#基本分页" class="headerlink" title="基本分页"></a>基本分页</h5><h5 id="基本分段"><a href="#基本分段" class="headerlink" title="基本分段"></a>基本分段</h5><h5 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h5><h3 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h3><p>采用 覆盖/交换 技术</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>主要内容集中在网络层之上的协议知识</p><span id="more"></span> <h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><table><thead><tr><th align="center">五层模型</th></tr></thead><tbody><tr><td align="center">应用层</td></tr><tr><td align="center">传输层</td></tr><tr><td align="center">网络层</td></tr><tr><td align="center">数据链路层</td></tr><tr><td align="center">物理层</td></tr></tbody></table><h2 id="数据链路层你"><a href="#数据链路层你" class="headerlink" title="数据链路层你"></a>数据链路层你</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>地址解析协议 将ip地址转换成mac地址</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>网际控制报文协议<br>确认ip包是否正确到达目标地址<br>通知在发送过程中ip包被丢弃的原因<br>ICMP基于IP协议工作 ICMP只能搭配IPv4 如果是IPv6则需要用ICMPv6<br>ICMP报文包含在IP数据报中 IP报头在ICMP报文的最前面 一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）</p><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h3><p>互联网组管理协议<br>IP组播(多播)通信的特点是报文从一个源发出 被转发到一组特定的接收者 但在组播通信模型中 发送者不关注接收者的位置信息 只是将数据发送到约定的目的组播地址<br>要使组播报文最终能够到达接收者 需要某种机制使连接接收者网段的组播路由器能够了解到该网段存在哪些组播接收者 同时保证接收者可以加入相应的组播组中<br>IGMP就是用来在接收者主机和与其所在网段直接相邻的组播路由器之间建立、维护组播组成员关系的协议</p><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><h4 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h4><p>路由信息协议</p><h4 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h4><p>开放式最短路径优先</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>用户数据报协议<br>UDP在传送数据之前不需要先建立连接 接收数据的主机在收到UDP报文后不需要给出确认 因此UDP提供不可靠交付 但在某些情况下使用UDP很有效<br>并且UDP支持一对一 一对多 多对一 多对多的交互通信</p><h4 id="使用UDP的协议"><a href="#使用UDP的协议" class="headerlink" title="使用UDP的协议"></a>使用UDP的协议</h4><table><thead><tr><th align="center">应用</th><th align="center">名字</th><th align="center">端口号</th></tr></thead><tbody><tr><td align="center">域名解析</td><td align="center">DNS</td><td align="center">53</td></tr><tr><td align="center">简单文件传送</td><td align="center">TFTP</td><td align="center">69</td></tr><tr><td align="center">路由选择协议</td><td align="center">RIP</td><td align="center"></td></tr><tr><td align="center">IP地址管理</td><td align="center">DHCP</td><td align="center"></td></tr><tr><td align="center">简单网络管理</td><td align="center">SNMP</td><td align="center">161</td></tr><tr><td align="center">远程文件服务器</td><td align="center">NFS</td><td align="center"></td></tr><tr><td align="center">IP电话/多媒体通信</td><td align="center">专用协议</td><td align="center"></td></tr></tbody></table><h4 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h4><p>UDP数据报分为UDP首部和UDP数据部<br>UDP首部包括源端口 目的端口 长度 校验和(检测传输中是否出错 出错直接丢弃) 共8字节 每个部分2字节<br>运输层从网络层收到UDP数据报时 根据首部中的目的端口将UDP数据报发送到相应端口 最终上交到应用进程 若接收方发现UDP数据报中目的端口不正确(不存在对应端口号的进程) 就丢弃该报文 并通过ICMP发送端口不可达的差错报文给发送方<br>虽然UDP在通信的时候需要用到端口号 但UDP通信是无连接的 因此不需要使用套接字(TCP之间的通信必须要在两个套接字之间建立连接)</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP传输控制协议<br>TCP提供面向连接服务 即在传送数据之前必须要先建立连接 数据传送结束后需要释放连接<br>TCP不提供广播多播服务 因为TCP提供可靠面向连接的服务 因此增加了许多无法避免的开销 如 确认 流量控制 计时器 连接管理等 使协议数据单元的首部增大了许多<br>TCP连接是一对一的 并且TCP提供全双工通信 即通信双方的应用进程在任何时候都能发送数据</p><h4 id="使用TCP的协议"><a href="#使用TCP的协议" class="headerlink" title="使用TCP的协议"></a>使用TCP的协议</h4><table><thead><tr><th align="center">应用</th><th align="center">名字</th><th align="center">端口号</th></tr></thead><tbody><tr><td align="center">组播</td><td align="center">IGMP</td><td align="center"></td></tr><tr><td align="center">Email</td><td align="center">SMTP</td><td align="center">25</td></tr><tr><td align="center">远程终端</td><td align="center">TELNET</td><td align="center">23</td></tr><tr><td align="center">超文本传输协议</td><td align="center">HTTP</td><td align="center">80</td></tr><tr><td align="center">文件传送</td><td align="center">FTP</td><td align="center">21</td></tr></tbody></table><h4 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h4><p>TCP连接的端点是套接字(Socket) 即端口号拼接IP地址就构成了套接字 例如(127.0.0.1:80)就是一个套接字<br>同一个IP地址可以有多个不同的TCP连接 同一个端口号也可以出现在多个不同的TCP连接中<br>套接字Socket与网络编程的socketAPI不是一个东西</p><h4 id="TCP可靠传输的工作原理"><a href="#TCP可靠传输的工作原理" class="headerlink" title="TCP可靠传输的工作原理"></a>TCP可靠传输的工作原理</h4><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><p>使用了停止等待协议:每发送完一个分组就停止发送 等待对方的确认到达后再发送下一个分组<br>超时重传:发送方发送完数据后超过一段时间仍没有收到确认 就认为刚才发送的分组丢失了 因而重新传送前面发送过的分组 关键在于发送完设置一个超时计时器 超过了预定时间没有收到回来的确认就再次发送 发送方发送分组后必须暂时保留已发送分组的副本 直到收到相应的确认才能清除副本 其次 分组和确认分组必须设置编号 最后 超时计时器设置的重传时间必须比数据在分组传输的平均往返时间更长 但如果这个重传时间设置非常长 通信的效率就会很低 重传时间设置太短就会产生不必要的重传<br>确认丢失:接收方收到了发送方的分组 但返回给发送方的确认在传输过程中丢失了 发送方超时重传了一份重复的分组 接收方又收到了重传的分组 需要丢弃这个重复的分组 并向发送方再次发送确认<br>确认迟到:接收方收到了发送方的分组 但返回给发送方的确认在传输过程中某种原因迟到了 因此发送方又发送了一份重复的分组 接收方又收到了重传的分组 需要丢弃这个重复的分组 并向发送方再次发送确认 发送方收到了重复的确认 也丢弃这个重复的确认<br>通过以上的确认和重传机制我们可以在不可靠的传输网络上实现可靠的通信</p><p>上述机制被整合为 <code>自动重传请求ARQ</code>意思是重传的请求自动进行 接收方不需要请求发送方重传某个出错的分组<br>但停止等待协议的信道利用率非常低 所以我们采用流水线传输:发送方连续发送多个分组 使信道上一直有数据不间断的传送 流水线传输需要使用 <code>连续ARQ协议</code> <code>滑动窗口协议</code></p><h5 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h5><p>连续ARQ协议规定 发送方每收到一个确认 就把发送窗口向前滑动一个分组的位置 接收方一般采用累积确认的方式 意思是接收方不需要对每个收到的分组逐个发送确认 而是收到几个分组后对按序到达的最后一个分组发送确认 表示所有分组都已经正确收到了<br>累计确认优点是容易实现 就算确认丢失也不需要重传 缺点是不能向发送方反映出接收方已经正确收到分组的信息 例如发送方发送前5个分组 中间第3个分组丢失了 接收方只能对前两个分组发送确认 发送方只能将后三个分组都重传一次 因此通信质量不好的时候连续ARQ会带来负面影响</p><h5 id="TCP报文首部格式"><a href="#TCP报文首部格式" class="headerlink" title="TCP报文首部格式"></a>TCP报文首部格式</h5><p>一个TCP报文段分为首部和数据两部分 TCP报文段首部前20个字节是固定的 还有4n(n是整数)个字节根据需要而增加 因此TCP首部最小长度20字节<br>首部字段包含:<br>1.源端口和目的端口 各占2字节<br>2.序号 占4字节 指本报文段所发送的数据的第一个字节的序号 也称为报文段序号<br>3.确认号 占4字节=32位 可对4GB的数据进行编号 可保证序号重复使用 旧序号的数据早已送到终点了  是期望收到对方下一个报文段的第一个数据字节的序号<br>4.数据偏移 占4位 指出TCP报文段的数据起始处距离TCP报文段的起始处有多远 数据偏移的最大值是60字节<br>5.保留 6字节</p><p>6.控制位 6字节 用来说明本报文段的性质<br>    6.1 紧急URG URG=1时说明紧急指针字段有效 通知系统此报文存在紧急数据 应优先传送 发送方TCP就把紧急数据插入到本报文段数据的最前面 例如ctrl+C<br>    6.2 确认ACK ACK=1时确认号字段才有效 ACK=0时确认号无效 TCP规定 在连接建立后所有传送的报文段都必须把ACK置1<br>    6.3 推送PSH 当两个进程进行交互通信时 有时在一端的进程希望在键入一个命令后立即就能收到对方的相应 TCP就可以使用推送 发送方TCP把PSH置1 并立即创建一个报文段发送出去 接收方TCP收到PSH=1的报文段 就立即交付接收进程 而不用等缓存都满了再向上交付<br>    6.4复位RST RST=1时 表面TCP连接中出现严重错误 必须释放连接 然后再重新建立运输连接<br>    RST=1还可以用来拒绝一个非法的报文段或拒绝打开一个连接<br>    6.5同步SYN 在连接建立时用来同步序号 当SYN=1且ACK=0 表明这是一个连接请求报文 对方若同意建立连接 就在响应的报文段中让SYN=1且ACK=1 因此 SYN=1就表明这是一个请求连接或请求接受的报文<br>    6.6终止FIN 用来释放连接 FIN=1时 表明此报文段的发送方的数据全部发送完毕 请求释放连接<br>7.窗口 2字节 窗口值是接收方告诉发送方设置发送窗口的大小 窗口值经常动态变化着<br>8.校验和 2字节<br>9.紧急指针 2字节 紧急指针仅在URG=1的时候才有意义 指出本报文段紧急数据的字节数 窗口为0时也可以发送紧急数据<br>10.选项 长度可变 最长40字节 长度为0时TCP首部长度为20字节</p><p>随着互联网的发展还增加了许多功能</p><h5 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h5><p>运输连接一共三个阶段:连接建立 数据传送 连接释放</p><h6 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h6><p>TCP建立连接的过程叫握手<br>A为TCP客户端  B为TCP服务端</p><p>A向B发出连接请求报文段 这时TCP首部中的SYN=1 同时选择一个初始序号seq=x A进入同步已发送状态<br>(TCP规定SYN报文段不能携带数据 但要消耗掉一个序号)</p><p>B收到连接请求的报文后 若同意建立连接 就向A发送确认报文 在确认报文段中 SYN=1 ACK=1 确认号ack=x+1 同时也为自己选择一个初始序号seq=y 这个报文段也不能携带数据 同样也要消耗掉一个序号  B进入同步收到状态</p><p>A收到B给出的确认报文后 还要再向B发送确认 确认报文ACK=1 确认号ack=y+1 而自己的序号seq=x+1 (ACK报文段可携带数据 若不携带数据就不消耗序号 这种情况下 下一个数据报的序号仍是seq=x+1) 至此 TCP连接已建立 A进入已建立连接状态<br>B收到A确认后也进入已建立状态 </p><p><code>A最后还要发送一次确认的原因:</code> 防止已失效的连接请求报文段因为网络堵塞的原因突然又传送到B从而发生错误   若B收到已失效的连接请求报文后 会向A发送确认报文 A收到后不会向B发送确认 B由于收不到确认就知道A没有要求建立连接</p><h6 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h6><p>数据传输结束后 AB都处于已建立连接状态 A把连接释放报文段首部的FIN=1 序号seq=u(u=前面已传送过的数据的最后一个字节序号+1) A进入FIN-Wait-1状态等待B的确认(FIN报文段即使不携带数据 也消耗掉一个序号)</p><p>B收到连接释放报文段后发出确认 确认号ack=u+1 而这个报文段自己的确认号是v(等于B前面传送过的数据的最后一个字节的序号+1) 然后B就进入关闭等待阶段 此时TCP处于半关闭阶段:A没有数据发送给B B仍能给A发送数据A仍能接收 A收到来自B的确认后 进入FIN-Wait-2状态 等待B发出的连接释放报文段</p><p>若B已经没有向A发送的数据 B向A发出连接释放报文段中FIN=1 假定B的序号是w (半关闭的状态下B可能又向A发送过一些数据) B还必须重复上次已发送过的确认号ack=u+1 此时B进入最后确认状态 等待A的确认</p><p>A收到B的连接释放报文段后 对B发出确认 确认报文段中ACK=1 确认序列号ack=w+1 自己的序号是seq=u+1 然后进入Time-wait状态 经过时间等待计时器设置的时间后(2个最长报文段寿命) A才进入关闭状态 B收到A发来的确认后直接进入关闭状态 因此B结束TCP连接的时间比A要早</p><p><code>A需要等待2个最长报文段寿命的原因:</code> 1.为了保证A发送的最后一个ACK确认报文能够到达B 如果这个报文段丢失 B无法收到A的确认报文 B就会重传给A FIN=1和ack的连接释放报文 A在这段时间内就能收到这个重传的FIN+ACK报文 接着A就会重传一个确认 报文准确送达后 A等待一段时间后和B都能进入关闭状态    2.防止已失效的连接请求报文段出现在此连接中</p><p><code>A与B建立连接后 A出现故障:</code> TCP设置了一个keepalive timer(保活计时器) A故障后B无法收到A发来的数据 因此应有措施使服务器不白白等待下去 服务器B每一次收到A的数据时都会重新设置保活计时器 超过时间间隔都没收到A发来的数据时 B发送一个探测报文段 每隔75s发送一次 发送10个探测报文后仍无客户响应 B就认为A出了故障 就关闭连接</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>通过域名服务器程序将域名解析成ip地址 过程如下:某一个应用进程需要把主机名解析成ip地址时 该应用进程调用解析程序 成为DNS的一个客户 将待解析的域名放在DNS请求报文中 以UDP形式发送给本地域名服务器 使用UDP是为了减少开销 本地域名服务器在查找域名后把对应的ip地址在回答报文中返回 应用进程获得目的主机ip地址后开始通信</p><h3 id="万维网www"><a href="#万维网www" class="headerlink" title="万维网www"></a>万维网www</h3><h4 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h4><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><h4 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h4><p>HTTP默认端口号80 HTTP是一个面向事务的应用层协议 是能在万维网上可靠的交换文件的重要基础<br>HTTP虽然使用了面向连接的TCP作为运输层协议 但HTTP本身是无连接的 即通信的双方交换HTTP报文之前不需要先建立HTTP连接<br>HTTP协议是无状态的 即同一个客户第二次访问同一个服务器上的页面时 服务器的响应与第一次被访问时的相同 因为服务器并不记得曾经访问过的这个客户 也不记得为这个客户曾经服务过多少次 HTTP的无状态特性简化了服务器的设计 使服务器更容易支持大量并发的HTTP请求</p><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>为了保留HTTP无状态的特点 又要让服务器记住之前的客户 引入了cookie技术/http1.1的持久连接 即中间不停的发送确认应答<br>在没有cookie信息的状态下的请求时 服务器在响应中添加cookie后返回客户 客户端保存cookie<br>在下一次有cookie信息的请求中 自动在请求中添加cookie发送 服务器端检查cookie的sid后相应</p><p>如果客户端禁用了cookie sid字段客户端用的方法是URL重写 即在URL里加上sid字段 这样sid就不用回传给客户端 只在每次页面跳转的时候把sid写进URL</p><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><ol><li>cookie把用户数据存到本地 session把用户数据存在服务器</li><li>单个cookie大小不超过4kb 单个session大小与服务器内存有关</li><li>cookie不安全 可以分析cookie进行cookie欺骗 session能更安全</li><li>cookie在没禁用的情况下会成为sid值的容器 可以把重要信息放在session中 其他信息放在cookie中<h4 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h4>HTTP有两种报文<br>请求报文:客户向服务器发送请求报文<br>响应报文:服务器应答客户的报文<br>请求报文和响应报文都是由三个部分组成 区别是开始行不同<h5 id="开始行"><a href="#开始行" class="headerlink" title="开始行"></a>开始行</h5>用于区分请求报文和响应报文 请求报文中的开始行叫请求行 响应报文中的开始行叫状态行<br>HTTP请求报文由请求行 请求头部 空行 请求数据 四个部分组成<br>HTTP响应报文由状态行 消息报头 空行 相应正文 四个部分组成<br>请求行包含了请求方法+空格+URL+空格+HTTP版本+CRLF(回车换行)<br>状态行包含了HTTP版本+空格+状态码+短语+CRLF<h5 id="GET请求报文"><a href="#GET请求报文" class="headerlink" title="GET请求报文"></a>GET请求报文</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="number">562f</span>25980001b1b106000338.jpg HTTP/<span class="number">1.1</span>   #请求行</span><br><span class="line">Host:img.mukewang.com                        #空行前都是请求头部</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64) #HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等</span><br><span class="line">AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">51.0</span><span class="number">.2704</span><span class="number">.106</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept:image/webp,image<span class="comment">/*,*/</span>*;q=<span class="number">0.8</span> #说明用户代理可处理的媒体类型。</span><br><span class="line">Referer:http:<span class="comment">//www.imooc.com/</span></span><br><span class="line">Accept-Encoding:gzip, deflate, sdch          #说明用户代理可处理的媒体类型。</span><br><span class="line">Accept-Language:zh-CN,zh;q=<span class="number">0.8</span>               #说明用户代理能够处理的自然语言集。</span><br><span class="line">空行</span><br><span class="line">请求数据为空  #请求数据也叫主体</span><br></pre></td></tr></table></figure><h5 id="POST请求报文"><a href="#POST请求报文" class="headerlink" title="POST请求报文"></a>POST请求报文</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1<span class="number">.1</span> #请求行</span><br><span class="line">Host:www.wrox.com  #空行前是请求头部</span><br><span class="line">User-Agent:Mozilla/<span class="number">4.0</span> (compatible; MSIE <span class="number">6.0</span>; Windows NT <span class="number">5.1</span>; SV1; .NET CLR <span class="number">2.0</span><span class="number">.50727</span>; .NET CLR <span class="number">3.0</span><span class="number">.04506</span><span class="number">.648</span>; .NET CLR <span class="number">3.5</span><span class="number">.21022</span>)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:<span class="number">40</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">空行</span><br><span class="line">name=Professional%<span class="number">20</span>Ajax&amp;publisher=Wiley #请求数据</span><br></pre></td></tr></table></figure><h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK    #状态行 由HTTP版本号 状态码 状态消息 组成</span><br><span class="line">Date: Fri, <span class="number">22</span> May <span class="number">2009</span> <span class="number">06</span>:<span class="number">07</span>:<span class="number">21</span> GMT  #二三行为消息报头 说明客户端要使用的信息</span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span></span><br><span class="line">空行</span><br><span class="line">&lt;html&gt; #响应正文</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--body goes here--&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h6 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h6></li></ol><table><thead><tr><th align="center">方法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">请求读取由URL标志的信息</td></tr><tr><td align="center">POST</td><td align="center">给服务器添加信息</td></tr><tr><td align="center">OPTION</td><td align="center">询问支持的方法有哪些</td></tr><tr><td align="center">HEAD</td><td align="center">请求读取由URL所标志的信息的首部</td></tr><tr><td align="center">PUT</td><td align="center">在指明的URL下存储一个文档(传输文件)</td></tr><tr><td align="center">DELETE</td><td align="center">删除指明的URL所标志的资源(删文件)</td></tr><tr><td align="center">TRACE</td><td align="center">用来进行环回测试的请求报文</td></tr><tr><td align="center">CONNECT</td><td align="center">用于代理服务器</td></tr></tbody></table><h6 id="GET-POST区别"><a href="#GET-POST区别" class="headerlink" title="GET/POST区别"></a>GET/POST区别</h6><p>get是从服务器上获取数据 post是向服务器传送数据<br>get后退按钮/刷新无害 post数据会被重新提交(浏览器会弹窗告知用户数据会被重新提交)<br>get书签可收藏 post为书签不可收藏<br>get能被缓存 post不能 除非人工修改设置<br>get编码类型为URL post支持多重编码方式<br>get对数据长度有限制 URL最大长度2048个字符 post无限制<br>get安全性较差 发送信息都显示在URL上 post的数据不会显示在URL中<br>get传递的参数都是ASCII字符 post没有限制<br>get产生一个tcp数据报 post产生两个tcp数据报<br>get请求时 浏览器会把http的header和data一起发送出去 服务器响应200(返回数据)<br>post请求时 浏览器先发送header 服务器响应100(continue) 浏览器在发送data 服务器响应200 但Firefox的post就只发送一次</p><h6 id="状态码种类"><a href="#状态码种类" class="headerlink" title="状态码种类"></a>状态码种类</h6><p>1xx:表示通知信息 比如请求收到或正在处理<br>2xx:表示成功 202接受<br>3xx:表示重定向<br>4xx:表示客户的差错 400错误请求 403拒绝执行 404不可用<br>5xx:表示服务器的差错 502网关无响应 503服务不可用 504网关超时 505HTTP版本不支持</p><h5 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h5><p>用来说明浏览器 服务器 报文主体的一些信息 首部行可以有好几行 也可以不使用 每一个首部行都包含首都字段名和它的值 每一行结束都有CRLF 首部行结束后还要隔一个空行与后面的实体主体分开</p><h5 id="实体主体-entity-body"><a href="#实体主体-entity-body" class="headerlink" title="实体主体(entity body)"></a>实体主体(entity body)</h5><p>请求报文中一般都不用这个字段 有些响应报文中也可能不用</p><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS是对HTTP的一个延展 在TLS(Transport Layer Security)或SSL(Secure Socket Layer)之上 常用端口443<br>HTTPS加密所有数据 包括报文头部请求/响应报文</p><h5 id="HTTPS通信原理"><a href="#HTTPS通信原理" class="headerlink" title="HTTPS通信原理"></a>HTTPS通信原理</h5><ol><li>客户使用https的URL访问web服务器 要求与服务器建立ssl连接</li><li>服务器收到请求后 将网站的证书信息(包含公钥)返回给客户端</li><li>客户端的浏览器与web服务器协商ssl连接安全等级 </li><li>客户端浏览器协商完毕 建立会话密钥 然后利用网站给的公钥将会话密钥加密冰川送给服务器</li><li>服务器利用自己的私钥解谜出会话密钥</li><li>服务器利用会话密钥加密与客户端的通信</li></ol><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><h4 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p>domain代表底层协议簇 type参数指定服务类型 服务类型有流服务(Sock_Stream) 数据报服务(Sock_Ugram) 对于TCP/IP协议簇来说 流服务指TCP协议 数据包服务指UDP协议 Linux2.6.17后 服务类型新增了 Sock_Nonblock(创建的socket为非阻塞的) Sock_Cloexec(用fork调用创建子进程时在子进程中关闭该socket)<br>protocol参数指在前两个参数构成的协议集合下选择一个具体的协议 一般所有情况下都把它设置为0表示使用默认协议<br>socket()调用成功返回一个socket文件描述符 失败返回-1 并设置errno</p><h4 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h4><p>将一个socket与socket地址绑定成为命名socket 服务器程序需要命名socket 只有命名后客户端才知道如何连接它 客户端则通常不需要命名socket采用匿名方式(使用系统自动分配的socket地址)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>bind()将my_addr所指的socket地址分配给未命名的sockfd文件描述符 addrlen指出socket地址的长度<br>bind()成功返回0 失败返回-1 并设置errno 两种常见的errno为 EACCES(被绑定的地址是受保护的 只有root能访问) EADDRINUSE(被绑定的地址正在使用 比如将socket绑定到一个处于TIME_WAIT状态的socket地址)</p><h4 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h4><p>socket命名后需要系统调用创建一个监听队列来存放待处理的客户连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>sockfd指定被监听的socket backlog提示内核监听队列的最大长度 若超过最大长度 服务器不受理新的客户连接 客户端也将受到ECONNREFUSED错误信息 Linux2.2之后 backlog指标是处于完全连接状态(ESTABLISHED)的socket的上限 处于半连接状态(SYN_RCVD)的socket上限由<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>定义 backlog一般是5<br>listen()成功返回0 失败返回-1 并设置errno</p><h4 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>sockfd是listen后的监听socket addr获取被接受连接的远端socket地址 长度为addrlen<br>accpet成功返回一个新的连接socket 该socket唯一的标识了被接受的这个连接 服务器可通过读写该socket来与被接受连接对应的客户端通信<br>accept失败返回-1 并设置errno<br>accept()对于客户端网络断开毫不知情 accept只是从监听队列中取连接 不管连接处于何种状态 也不关心网络变化</p><h4 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h4><p>客户端通过connect来主动与服务器建立连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>sockfd参数由socket系统调用返回一个socket serv_addr是服务器监听的socket地址 长度为addrlen<br>connect成功返回0 一旦成功连接 sockfd唯一标识这个连接 客户端可以通过读写sockfd来与服务器通信<br>connect失败返回-1并设置errno 常见的errno ECONNREFUSED(目标端口不存在 连接被拒绝) ETIMEDOUT(连接超时)</p><h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span></span><br></pre></td></tr></table></figure><p>fd是待关闭的socket close并非总是关闭一个连接 只是将fd的引用计数-1 只有当fd=0的时候才真正关闭连接 多进程程序中 一次fork()默认将父进程中打开的socket引用计数+1 因此我们必须在父进程和子进程中都对该socket执行close才能关闭连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">int</span> howto)</span></span><br></pre></td></tr></table></figure><p>sockfd指待关闭的socket howto决定如何关闭 取值有SHUT_RD(关闭sockfd上读的这部分 若应用程序不再针对socket文件描述符进行读操作 就丢弃) SHUT_WR(关闭sockfd上写的这部分 sockfd的发送缓冲区中的数据会在真正关闭连接前全部发送出去 应用程序不可再对该socket文件描述符执行写操作 这时的情况下连接处于半关闭状态) SHUT_RDWR(同时关闭sockfd上的读和写)<br>shutdown()能分别关闭或者都关闭读和写 close只能将读写同时关闭<br>shutdown成功返回0 失败返回-1 并设置errno</p><h4 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h4><h5 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure><p>recv读取sockfd上的数据 buf和len指定读缓冲区的位置和大小 flag通常设置为0<br>recv成功返回读取到的数据长度 可能小于我们期望的长度 因此我们可能需要多次调用recv才能读取到完整的数据<br>recv返回0的时候一位置对方关闭连接 recv出错返回-1 并设置errno</p><p>send往sockfd上写入数据 buf和len指定写缓冲区的位置和大小 send成功时返回实际写入的数据的长度<br>send失败返回=1 并设置errno</p><h5 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span><br></pre></td></tr></table></figure><p>recvfrom读取sockfd上的数据 buf和len指定读缓冲区的位置和大小 因为UDP通信没有连接的概念 所以每次读取数据都要获取发送端的socket地址 即src_addr 地址的长度为addrlen<br>sendto往sockfd上写入数据 buf和len指定写缓冲区的位置和大小 dest_addr指定接收端的socket地址 地址的长度为addrlen</p><p>recvfrom和sendto也可以用于TCP连接 只需要把最后两个参数设置为NULL 因为TCP是面向连接的 已经连接了就知道对方的socket地址了</p><h5 id="通用读写函数"><a href="#通用读写函数" class="headerlink" title="通用读写函数"></a>通用读写函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>sockfd指定被操作的目标socket msg是msghdr结构体的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> *msg_name; <span class="comment">//socket地址 TCP中被设置为NULL</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_namelen; <span class="comment">//socket地址长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span> <span class="comment">//分散内存块</span></span><br><span class="line">    <span class="type">int</span> msg_iovlen;  <span class="comment">//分散内存块数量</span></span><br><span class="line">    <span class="type">void</span> *msg_control; <span class="comment">//指向辅助数据的起始位置</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_controllen; <span class="comment">//辅助数据大小</span></span><br><span class="line">    <span class="type">int</span> msg_flags; <span class="comment">//复制函数中的flags参数 在调用中更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span><span class="comment">//分散内存块</span></span><br><span class="line">    <span class="type">void</span> *iov_base;<span class="comment">//内存起始位置</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;<span class="comment">//内存的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h4><p>就是紧急数据需要接受 内核通知应用程序由带外数据到达的两种常见方式 I/O复用产生的异常事件和SIGURG信号<br>应用程序收到了需要接受带外数据的通知 还要知道带外数据在数据流的具体位置才能准确接收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockatmark</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br></pre></td></tr></table></figure><p>sockatmark判断sockfd下一个读取到的数据是否是带外数据 是就返回1 利用带MSG_OOB标志的recv调用来接收带外数据 不是就返回0</p><h4 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *address, <span class="type">socklen_t</span> *address_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *address, <span class="type">socklen_t</span> *address_len)</span>;</span><br></pre></td></tr></table></figure><p>getsockname获取sockfd对应的本端socket地址 并存入address指向的内存中 长度为address_len<br>若实际的socket地址长度大于address指向的内存大小 socket地址会被截断<br>getsockname成功返回0 失败返回-1 并设置errno<br>getpeername获取sockfd对应的远端socket地址 参数以及返回值与getsockname相同</p><h4 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h4><p>专门用来读取和设置socket文件描述符属性的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span> *option_value, <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span> *option_value, <span class="type">socklen_t</span> option_len)</span>;</span><br></pre></td></tr></table></figure><p>level指定操作协议的属性(IPV4 IPV6 TCP….) option_name指定选项的名字option_value option_len指定被操作的值和长度</p><p><img src="/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/socket%E9%80%89%E9%A1%B9.png" alt="socket选项"></p><p>getsockopt/setsockopt成功返回0 失败返回-1 并设置errno<br>对于服务器而言 有部分socket选项只能在调用listen前针对socket设置才有效 因为socket只能由accept调用返回 而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤(监听队列中的连接至少已经进入了SYN_RCVD状态) 说明服务器已经往被接受连接上发送了TCP同步报文段<br>可是有的socket选项应该在TCP同步报文段中设置 例如TCP最大报文段选项 对这种情况 Linux给出的解决方案是:对监听socket设置这些socket选项 那么accept发挥的连接socket将自动继承这些选项 对客户端而言 这些socket选项应该在调用connect之前设置 因为connect调用返回后说明TCP三次握手已经完成</p><p>下面我们详细讨论部分重要的socket选项</p><h5 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h5><p>设置socket选项SO_REUSEADDR来强制使用处于TIME_WAIT连接占用的socket地址<br>经过setsockopt设置选项为SO_REUSEADDR后 即使sock处于TIME_WAIT状态 与之绑定的socket地址也可以立即被重用 此外我们可通过修改内核参数<code>/proc/sys/net/ipv4/tcp_tw_recycle</code>来快速回收被关闭的socket 从而使TCP连接根本不进入TIME_WAIT状态</p><h5 id="SO-RCVBUF-SO-SNDBUF"><a href="#SO-RCVBUF-SO-SNDBUF" class="headerlink" title="SO_RCVBUF/SO_SNDBUF"></a>SO_RCVBUF/SO_SNDBUF</h5><p>SO_RCVBUF/SO_SNDBUF 分别表示TCP接收缓冲区和TCP发送缓冲区的大小 我们setsockopt设置大小值后 系统会将其加倍 使其不小于某个最小值 例如TCP接收缓冲区最小值256字节 发送缓冲区最小值2048字节 系统如此做是为了确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞(快速重传就期望TCP接收缓冲区至少能容纳4个大小为SMSS的TCP报文段)<br>修改TCP发送接收缓冲区大小的值文件在<code>proc/sys/net/ipv4/tcp_rmem tcp_wmem</code></p><h5 id="SO-RCVLOWAT-SO-SNDLOWAT"><a href="#SO-RCVLOWAT-SO-SNDLOWAT" class="headerlink" title="SO_RCVLOWAT/SO_SNDLOWAT"></a>SO_RCVLOWAT/SO_SNDLOWAT</h5><p>SO_RCVLOWAT/SO_SNDLOWAT分别表示TCP接收缓冲区和发送缓冲区的低水位标记 一般被I/O复用系统调用来判断socket是否可读或可写<br>当TCP接收缓冲区中可读数据的总数大于其低水位标记时候 I/O复用系统调用将通知应用程序可以从对应的socket上读取数据<br>当TCP接收缓冲区中可写数据的总数大于其低水位标记时候 I/O复用系统调用将通知应用程序可以从对应的socket上写入数据<br>默认情况下的低水位标记为1字节</p><h5 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h5><p>用于控制close关闭TCP连接时候的行为 </p><h4 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h4><p>socket地址两个要素 IP地址 端口号 都用数值表示 因此我们用主机名表示IP 服务名表示端口号</p><h5 id="gethostbyname-gethostbyaddr"><a href="#gethostbyname-gethostbyaddr" class="headerlink" title="gethostbyname/gethostbyaddr"></a>gethostbyname/gethostbyaddr</h5><p>gethostbyname函数根据主机名称获取主机完整信息gethostbyname先在etc/hosts文件中查找主机 找不到去访问DNS gethostbyaddr根据IP地址获取主机完整信息 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span></span><br></pre></td></tr></table></figure><p>name主机名 addr主机IP地址 len指定addr长度 type指定ip地址类型<br>两个函数返回值都是hostent结构体类型的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *h_name; <span class="comment">/*主机名*/</span></span><br><span class="line">    <span class="type">char</span> **h_aliases;<span class="comment">/*主机别名 可能有多个*/</span></span><br><span class="line">    <span class="type">int</span> h_addrtype; <span class="comment">/*地址类型*/</span></span><br><span class="line">    <span class="type">int</span> h_length;  <span class="comment">/*地址长度*/</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list; <span class="comment">/*按网络字节序列出的主机IP地址列表*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="getservbyname-getservbyport"><a href="#getservbyname-getservbyport" class="headerlink" title="getservbyname/getservbyport"></a>getservbyname/getservbyport</h5><p>getservbyname获取某个服务完整信息 getservbyport根据端口号获取服务完整信息 都是读取/etc/services文件的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure><p>name服务名称 port对应端口号 proto指定服务类型(tcp udp null全部)<br>返回值为servent结构体类型的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *s_name;<span class="comment">/*服务名称*/</span></span><br><span class="line">    <span class="type">char</span> **s_aliases;<span class="comment">/*服务别名*/</span></span><br><span class="line">    <span class="type">int</span> s_port;<span class="comment">/*端口号*/</span></span><br><span class="line">    <span class="type">char</span> *s_proto;<span class="comment">/*服务类型*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result)</span>;</span><br></pre></td></tr></table></figure><p>hostname主机名 service服务名 hints可设置NULL result指向一个链表存储getaddrinfo反馈结果</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2020/04/22/STL/"/>
      <url>/2020/04/22/STL/</url>
      
        <content type="html"><![CDATA[<h2 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h2><p>STL是Standard Template Library 是一种泛型编程<br>STL从广义上分为 容器(container) 算法(algorithm) 迭代器(iterator)<br>目前广泛认为STL有六大组件</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>可以说容器就是将一些常用的数据结构用模版实现出来<br>容器中包括的常用数据结构有: <code>字符串(string)</code> <code>定长数组(array)</code> <code>动态数组(vector)</code> <code>链表(list)</code> <code>栈(stack)</code> <code>队列(queue)</code> <code>双端队列(deque)</code> <code>树(tree)</code> <code>集合(set)</code> <code>映射(map)</code><br>根据数据在容器中的排列特性 这些数据分为序列式容器和关联式容器两种<br>序列式容器强调值的排序 序列式容器中的每个元素均有固定的位置 除非用删除或插入的操作改变这个位置 Vector容器 Deque容器 List容器等<br>关联式容器是非线性的树结构 更准确的说是二叉树结构 各元素之间没有严格的物理上的顺序关系 也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序 关联式容器另一个显著特点是：在值中选择一个值作为关键字key 这个关键字对值起到索引的作用 方便查找 Set/multiset容器 Map/multimap容器</p><span id="more"></span> <h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><h5 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------class string-----------//</span></span><br><span class="line"><span class="built_in">string</span>();<span class="comment">//无参数构造函数</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string &amp;str);<span class="comment">//使用对象str复制构造函数</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *s);<span class="comment">//一个参数的复制构造函数 使用字符串s来初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n,<span class="type">char</span> c);<span class="comment">//多参数构造函数 使用n个字符c初始化</span></span><br><span class="line"><span class="comment">//--------------main()-----------------//</span></span><br><span class="line">string s1;<span class="comment">//使用无参数构造函数初始化</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;syh&quot;</span>)</span></span>;<span class="comment">//使用一个参数的构造函数</span></span><br><span class="line">string s3=<span class="string">&quot;syh02&quot;</span>;<span class="comment">//使用一个参数的复制构造函数</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;k&#x27;</span>)</span></span>;<span class="comment">//是用哪个多参数构造函数 初始化为10个k</span></span><br><span class="line">string s5=s2;<span class="comment">//用s2初始化s5 使用复制构造函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="string重载运算符的基本赋值操作"><a href="#string重载运算符的基本赋值操作" class="headerlink" title="string重载运算符的基本赋值操作"></a>string重载运算符的基本赋值操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *s);<span class="comment">//string s1;s1=&quot;syh&quot;;</span></span><br><span class="line">string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//string s1,s2;s1=s2;</span></span><br><span class="line">string &amp;<span class="keyword">operator</span>=(<span class="type">char</span> c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------assign()方法-----------------//</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> start, <span class="type">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符串</span></span><br><span class="line"><span class="comment">//调用方式 string s1,s2;s1.assign(s2) s1.assign(s2,1,2);#将s2从索引为1的位置(也就是第二位开始)2个字符赋值给s1</span></span><br></pre></td></tr></table></figure><h5 id="string获取相应位数的字符操作"><a href="#string获取相应位数的字符操作" class="headerlink" title="string获取相应位数的字符操作"></a>string获取相应位数的字符操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> n);</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//eg: string s1=&quot;abcdefg&quot;;cout&lt;&lt;s1.operator[](3); #结果为d</span></span><br><span class="line"><span class="comment">//eg: string s1=&quot;abcdefg&quot;;cout&lt;&lt;s1.at(3);</span></span><br></pre></td></tr></table></figure><h5 id="string字符串的拼接-在结尾处添加"><a href="#string字符串的拼接-在结尾处添加" class="headerlink" title="string字符串的拼接(在结尾处添加)"></a>string字符串的拼接(在结尾处添加)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> string &amp;str);<span class="comment">//重载+=运算符 string s1,s2;s1+=s2;</span></span><br><span class="line">string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> *str);<span class="comment">//string s1;s1+=&quot;syh&quot;;</span></span><br><span class="line">string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);</span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//string s1;s1.append(&quot;syh&quot;);#把&quot;syh&quot;拼接在s1后面</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> n)</span></span>;string s1;s1.<span class="built_in">append</span>(<span class="string">&quot;syh&quot;</span>,<span class="number">2</span>);#把<span class="string">&quot;syh&quot;</span>的前<span class="number">2</span>位拼接在s1后面</span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//string s1,s2;s1.append(s2);#把s2拼接在s1后面</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n位的字符c</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;<span class="comment">//string s1,s2;s1.append(s2,1,2);#将s2从索引为1的位置开始2个字符拼接在s1的后面</span></span><br></pre></td></tr></table></figure><h5 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------查找----------------//</span></span><br><span class="line"><span class="comment">//查找成功返回索引序号 查找失败返回string::npos=18446744073709551615 即2^(64)-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="comment">//-----------------反向查找 查找最后出现的位置------------------//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rfind()的返回值我和给定的pos值我还未完全掌握</span></span><br><span class="line">eg:s1=<span class="string">&quot;abcdefgabcdfe&quot;</span>; <span class="type">int</span> i=s1.<span class="built_in">rfind</span>(<span class="string">&quot;a&quot;</span>,<span class="number">12</span>); <span class="meta">#i=7</span></span><br><span class="line"><span class="comment">//-------------------替换------------------//</span></span><br><span class="line"><span class="function">string &amp;<span class="title">replace</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> n,<span class="type">const</span> string &amp;str)</span></span>;</span><br><span class="line"><span class="function">string &amp;<span class="title">replace</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> n,<span class="type">const</span> string *s)</span></span>;</span><br><span class="line"><span class="comment">//eg:string s1=&quot;abcdefg&quot;;string s2=&quot;syh&quot;;s1=s1.replace(1,2,s2);#将s1的从索引为1位置起的2个字符替换为s2 结果为s1=asyhdefg</span></span><br></pre></td></tr></table></figure><h5 id="string比较大小"><a href="#string比较大小" class="headerlink" title="string比较大小"></a>string比较大小</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大写字母比小写字母小 根据ascii码字典排名越靠后越大 大于时返回1 小于时返回-1 相等时返回0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"><span class="comment">//eg: string s1=&quot;abc&quot;;string s2=&quot;syh&quot;;#s1.compare(s2)=-1 因为abc比syh小</span></span><br></pre></td></tr></table></figure><h5 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos=<span class="number">0</span>,<span class="type">int</span> n=npos)</span> <span class="type">const</span></span>;<span class="comment">//截取从pos位置开始n位</span></span><br><span class="line"><span class="comment">//eg:string s1=&quot;abcdefg&quot;;s1.substr(1,2)=&quot;bc&quot;</span></span><br></pre></td></tr></table></figure><h5 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">int</span> pos,<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">int</span> pos,<span class="type">const</span> string &amp;str)</span></span>;</span><br><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> n,<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="comment">//在pos位置出插入字符串</span></span><br><span class="line"><span class="comment">//eg: string s1=&quot;abcdefg&quot;;s1.insert(2,&quot;syh&quot;)=&quot;absyhcdefg&quot;</span></span><br><span class="line"><span class="function">string &amp;<span class="title">erase</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> n=npos)</span></span>;<span class="comment">//删除从pos位置起的n个字符</span></span><br><span class="line"><span class="comment">//eg: string s1=&quot;abcdefg&quot;;s1.erase(2,3)=&quot;abfg&quot;</span></span><br></pre></td></tr></table></figure><h5 id="c-string和C-type字符串互相转化"><a href="#c-string和C-type字符串互相转化" class="headerlink" title="c++ string和C-type字符串互相转化"></a>c++ string和C-type字符串互相转化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string转char *</span></span><br><span class="line">string str=<span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr=str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">//char *转string</span></span><br><span class="line"><span class="type">char</span> *s=<span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="comment">//c++中存在一个从`const char *`到`string`的隐式转换 不存在string到c风格的自动类型转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector起到了动态数组的作用 加入新元素内部会自动扩容 vector支持随机存取<br>所以vector提供的是随机访问迭代器(Random Access Iterators)</p><h5 id="vector常用方法"><a href="#vector常用方法" class="headerlink" title="vector常用方法"></a>vector常用方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);<span class="comment">//在v后面增加数据i</span></span><br><span class="line">v.<span class="built_in">capacity</span>();<span class="comment">//返回vector的容量 我们会发现vector数组的长度和容量不是一样的 往往容量比长度要大一点</span></span><br></pre></td></tr></table></figure><p>因为vector采取的是线性连续空间 它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围 并以迭代器_Myend指向整块连续内存空间的尾端 意思就是_Myfirst指向数组的头部 _Mylast指向数组的尾部 _Myend指向数组大小空间真正的最后一块</p><h5 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v;<span class="comment">//采用模版类实现 默认构造函数</span></span><br><span class="line"><span class="function">vector <span class="title">v1</span><span class="params">(n,elem)</span></span>;<span class="comment">//构造函数将n个elem赋值给本身=v1=&#123;elem....&#125;</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v1</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v1</span><span class="params">(v)</span></span>;<span class="comment">//拷贝构造函数 vector(const vector &amp;vec);</span></span><br><span class="line">vector&lt;T&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h5 id="vector赋值"><a href="#vector赋值" class="headerlink" title="vector赋值"></a>vector赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(begin,end);<span class="comment">//vector&lt;T&gt; v1,v2;v2.assign(v1.begin(),v1.end())</span></span><br><span class="line"><span class="built_in">assign</span>(n,elem);<span class="comment">//vector&lt;T&gt; v1;v1.assign(4,5);#将4个5赋值给v1</span></span><br><span class="line">vector &amp;<span class="keyword">operator</span>=(<span class="type">const</span> vector &amp;vec);<span class="comment">//vec重载运算符= vector&lt;T&gt; v1,v2;v2=v1;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(&amp;vec);<span class="comment">//交换两个vector数组的内容 </span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v1=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;vector&lt;<span class="type">int</span>&gt; v2=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"> v1.<span class="built_in">swap</span>(v2); v1与v2数组的内容互换了 v1是<span class="number">246810</span> v2是<span class="number">13579</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="vector长度空间操作"><a href="#vector长度空间操作" class="headerlink" title="vector长度空间操作"></a>vector长度空间操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回vector数组内元素的个数 v.size();</span></span><br><span class="line"><span class="built_in">empty</span>(); <span class="comment">//判断数组是否为空 空返回1 非空返回0</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> n);<span class="comment">//重新指定数组长度 如果比原来的长 填充默认值进去 如果比原来的短 就把超出的数据删除</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> n,elem);<span class="comment">//重新指定数组长度 如果比原来的长 就填充那些数量的elem</span></span><br><span class="line">v.<span class="built_in">capacity</span>();<span class="comment">//返回vector的容量 我们会发现vector数组的长度和容量不是一样的 往往容量比长度要大一点</span></span><br><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len);<span class="comment">//预留len个元素长度 预留的位置不可初始化 也不能被访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vector容器如果空间不足 将会重新申请一块更大的空间然后将元素都复制过去 再释放旧有的空间 </p><h5 id="用swap缩短内存空间"><a href="#用swap缩短内存空间" class="headerlink" title="用swap缩短内存空间"></a>用swap缩短内存空间</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">//capacity:131072</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//size:100000</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">100</span>);<span class="comment">//改变容量</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">//capacity:131072</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//size:100</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (v).<span class="built_in">swap</span>(v);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">//capacity:100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//size:100</span></span><br></pre></td></tr></table></figure><h5 id="vector取数据"><a href="#vector取数据" class="headerlink" title="vector取数据"></a>vector取数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> n);<span class="comment">//返回索引为n的数据 如果越界 抛出异常 out_of_range</span></span><br><span class="line"><span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//返回索引为n的数据 如果越界 抛出异常 out_of_range</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回vector数组第一个数据</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回vector数组最后一个数据</span></span><br></pre></td></tr></table></figure><h5 id="vector插入删除"><a href="#vector插入删除" class="headerlink" title="vector插入删除"></a>vector插入删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(ele);<span class="comment">//在数组尾部插入ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一位数据</span></span><br><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//在pos迭代器指向的位置插入count个ele</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器start到end范围内的数据</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器pos指向的数据</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除vector数组中全部的数据</span></span><br></pre></td></tr></table></figure><p>vector在尾部插入数据 也可以在头部插入数据 但是效率很低很低 因此引入deque容器概念</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque可以高效率的对头端进行元素的插入和删除 并且没有容量的概念 因为deque逻辑上是由动态的以分段连续空间组合而成 随时可以增加一段新空间连接起来<br>实际上deque是由一段一段的定量的连续空间构成 一旦有必要在deque前端或者尾端增加新的空间 便配置一段连续定量的空间 串接在deque的头端或者尾端<br>Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象 并提供随机存取的接口 避开了重新配置空间 复制 释放的轮回 代价就是复杂的迭代器架构<br>deque的迭代器非常复杂 所以除非有必要 应该尽可能的先使用vector 对deque的排序操作 可以通过先将deque的元素复制到vector中 排序后再复制回deque中来提高效率</p><p>deque采取了一块连续的内存空间作为主控 其中每一个元素都是一个指针 指向另一段连续的存储空间(缓冲区) 这些存储空间存储了deque的元素</p><h5 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;T&gt; D;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="function">deque&lt;T&gt; <span class="title">D</span><span class="params">(D1.begin(),D1.end())</span></span>;<span class="comment">//构造函数将begin-end的范围内的元素拷贝给自身</span></span><br><span class="line"><span class="function">deque&lt;T&gt; <span class="title">D</span><span class="params">(n,elem)</span></span>;<span class="comment">//构造函数将n个elem初始化给D </span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h5 id="deque赋值"><a href="#deque赋值" class="headerlink" title="deque赋值"></a>deque赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());<span class="comment">//deque&lt;T&gt; d1,d2;d1.assign(d2.begin(),d2.end());</span></span><br><span class="line"><span class="built_in">assign</span>(n,elem);<span class="comment">//将n个elem赋值给D deque&lt;T&gt; D; D.assign(3,5);</span></span><br><span class="line">deque &amp;<span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq);<span class="comment">//重载运算符 d1=d2;</span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// d1.swap(d2); d1与d2互换</span></span><br></pre></td></tr></table></figure><h5 id="deque长度空间操作"><a href="#deque长度空间操作" class="headerlink" title="deque长度空间操作"></a>deque长度空间操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回deque中元素个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断deque是否为空 空返回1 非空返回0</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> n);<span class="comment">//重新指定数组长度 如果比原来的长 填充默认值进去 如果比原来的短 就把超出的数据删除</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> n,elem);<span class="comment">//重新指定数组长度 如果比原来的长 就填充那些数量的elem</span></span><br></pre></td></tr></table></figure><h5 id="deque双端插入删除"><a href="#deque双端插入删除" class="headerlink" title="deque双端插入删除"></a>deque双端插入删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在deque尾部添加一个elem</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在deque首部添加一个elem</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除deque最后一个元素</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除deque第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//在pos迭代器指向的位置插入count个ele</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器start到end范围内的数据</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器pos指向的数据 返回下一个数据的位置</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除deque中全部的数据</span></span><br></pre></td></tr></table></figure><h5 id="deque取数据"><a href="#deque取数据" class="headerlink" title="deque取数据"></a>deque取数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> n);<span class="comment">//返回索引为n的数据 如果越界 抛出异常 out_of_range</span></span><br><span class="line"><span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//返回索引为n的数据 如果越界 抛出异常 out_of_range</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回deque第一个数据</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回deque数组最后一个数据</span></span><br></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>stack栈是一个先进后出的数据结构 stack容器允许新增/移除元素 取栈顶元素 stack容器不允许遍历元素 stack没有迭代器</p><h5 id="stack构造函数"><a href="#stack构造函数" class="headerlink" title="stack构造函数"></a>stack构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;T&gt; stk;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h5 id="stack赋值"><a href="#stack赋值" class="headerlink" title="stack赋值"></a>stack赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//运算符=重载</span></span><br></pre></td></tr></table></figure><h5 id="stack存取"><a href="#stack存取" class="headerlink" title="stack存取"></a>stack存取</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//栈顶添加elem</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//出栈</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure><h5 id="stack空间"><a href="#stack空间" class="headerlink" title="stack空间"></a>stack空间</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断deque是否为空 空返回1 非空返回0</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回栈元素的个数</span></span><br></pre></td></tr></table></figure><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>队列是一种先进先出的数据结构 队头出 队头进</p><h5 id="queue构造函数"><a href="#queue构造函数" class="headerlink" title="queue构造函数"></a>queue构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;T&gt; q;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="type">const</span> queue &amp;q);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h5 id="queue赋值"><a href="#queue赋值" class="headerlink" title="queue赋值"></a>queue赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue &amp;<span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;q);<span class="comment">//重载运算符=</span></span><br></pre></td></tr></table></figure><h5 id="queue存取"><a href="#queue存取" class="headerlink" title="queue存取"></a>queue存取</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//队尾增加elem</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//队头移除一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure><h5 id="queue空间"><a href="#queue空间" class="headerlink" title="queue空间"></a>queue空间</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回队列大小</span></span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list容器是一个循环的双向链表<br>list对元素的插入和删除效率都非常高<br>list容器不能像vector一样用普通的指针作为迭代器 因为它的节点不能保证在同一块连续的内存空间上 list容器提供的迭代器是Bidirectional Iterators</p><h5 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; l;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">list</span>(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>());<span class="comment">//构造函数将begin到end区间内的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">list</span>(n,elem)<span class="comment">//构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;l);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h5 id="list赋值"><a href="#list赋值" class="headerlink" title="list赋值"></a>list赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assign</span>(begin,end);<span class="comment">//list&lt;T&gt; l1,l2;l2.assign(l1.begin(),l2.begin())</span></span><br><span class="line"><span class="built_in">assign</span>(n,elem);</span><br><span class="line">list &amp;<span class="keyword">operator</span>=(<span class="type">const</span> list &amp;l);<span class="comment">//重载运算符=</span></span><br><span class="line"><span class="built_in">swap</span>(l);<span class="comment">//交换两个链表的内容 l1.swap(l2)</span></span><br></pre></td></tr></table></figure><h5 id="list空间"><a href="#list空间" class="headerlink" title="list空间"></a>list空间</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回链表内元素个数</span></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//判断数组是否为空 空返回1 非空返回0</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> n);<span class="comment">//重新指定链表长度 如果比原来的长 填充默认值进去 如果比原来的短 就把超出的数据删除</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> n,elem);<span class="comment">//重新指定链表长度 如果比原来的长 就填充那些数量的elem</span></span><br></pre></td></tr></table></figure><h5 id="list存取数据"><a href="#list存取数据" class="headerlink" title="list存取数据"></a>list存取数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br></pre></td></tr></table></figure><h5 id="list插入删除"><a href="#list插入删除" class="headerlink" title="list插入删除"></a>list插入删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在链表尾部插入一个元素elem</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除链表最后一个元素</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在链表头部插入一个元素elem</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除链表的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//在pos迭代器指向的位置插入count个ele</span></span><br><span class="line"><span class="built_in">insert</span>(pos,<span class="built_in">begin</span>(),<span class="built_in">end</span>());<span class="comment">//在pos位置插入begin到end区间的元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入elem 返回新数据的位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(begin,end);<span class="comment">//删除begin到end区间的元素 返回下一个数据的位置</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的元素 返回下一个数据的位置</span></span><br><span class="line"><span class="built_in">clean</span>();<span class="comment">//清除所有数据</span></span><br><span class="line"><span class="built_in">remove</span>(elem);<span class="comment">//删除list中与elem匹配的元素</span></span><br></pre></td></tr></table></figure><h5 id="list排序"><a href="#list排序" class="headerlink" title="list排序"></a>list排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>();<span class="comment">//翻转链表</span></span><br><span class="line"><span class="built_in">sort</span>();</span><br></pre></td></tr></table></figure><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h4><p>set是一个关联容器 不需要做内存拷贝和内存移动 set用来存储同一数据类型的容器<br>在set容器中 每个元素的值都是唯一的 并且系统根据元素的值进行自动排序<br>multiset特性与用法和set完全相同 唯一的区别是multiset允许元素的值重复<br>C++ STL中标准关联容器<code>set</code> <code>multiset</code> <code>map</code> <code>multimap</code>内部采用的就是一种非常高效的平衡检索二叉树：红黑树 也称为RB树(Red-Black Tree) RB树的统计性能要好于一般平衡二叉树<br>set中元素的值不能被直接改变 因为set元素值就是它的key值 关系到set元素的排序规则<br>简言之set容器的迭代器是const_iterator</p><h5 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; st;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set &amp;st);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h5 id="set赋值"><a href="#set赋值" class="headerlink" title="set赋值"></a>set赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set &amp;<span class="keyword">operator</span>=(<span class="type">const</span> set &amp;s);<span class="comment">//运算符重载</span></span><br><span class="line"><span class="built_in">swap</span>(s);<span class="comment">//交换两个集合容器的值</span></span><br></pre></td></tr></table></figure><h5 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找key值是否存在 若存在就返回该键元素的迭代器 若不存在 返回set.end()</span></span><br><span class="line"><span class="built_in">count</span>(key);<span class="comment">//查找键key的元素个数 在set容器中就变成了查询某个key值是否存在过了</span></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个值大于keyElem的迭代器</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回最后一个值大于keyElem的迭代器</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回值是一个pair类型</span></span><br></pre></td></tr></table></figure><h5 id="set插入删除"><a href="#set插入删除" class="headerlink" title="set插入删除"></a>set插入删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器声明 set&lt;int&gt;::iterator first;first是你声明的迭代器名字</span></span><br><span class="line"><span class="built_in">insert</span>(elem);<span class="comment">//插入elem</span></span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除迭代器pos指向的元素 返回下一个元素的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(begin,end);<span class="comment">//删除begin到end区间的所有元素 返回下一个元素的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(elem);<span class="comment">//删除容器中值为elem的元素</span></span><br></pre></td></tr></table></figure><h5 id="用迭代器遍历输出set内数据"><a href="#用迭代器遍历输出set内数据" class="headerlink" title="用迭代器遍历输出set内数据"></a>用迭代器遍历输出set内数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//---------main()------------//</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator x;</span><br><span class="line">    <span class="keyword">for</span>(x=s.<span class="built_in">begin</span>();x!=s.<span class="built_in">end</span>();++x)&#123;</span><br><span class="line">        cout&lt;&lt;*x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><p>pair容器的类型定义需要引入头文件<code>#include&lt;utility&gt;</code><br>pair存有两个值 这一对值可以有不同的数据类型 两个值分别可以用first和second访问</p><h5 id="pair构造函数"><a href="#pair构造函数" class="headerlink" title="pair构造函数"></a>pair构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1,T2&gt; p1;<span class="comment">//T1 T2是两个类型 默认构造函数</span></span><br><span class="line"><span class="function">pair&lt;T1,T2&gt; <span class="title">p1</span><span class="params">(v1,v2)</span></span>;<span class="comment">//创建一个pair对象 first成员初始化为v1 second成员初始化v2</span></span><br><span class="line">pair&lt;T1,T2&gt; p1= <span class="built_in">make_pair</span>(v1,v2);<span class="comment">//以v1 v2的值创建一个新的对象p1</span></span><br><span class="line">pair&lt;T1,T2&gt; p1=p2;<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h4><p>map容器中存放的元素都是pair类型的 这一对值中第一个被视为键(key) 第二个被视为值(value) map不允许两个元素有相同的key map有助于处理一对一映射数据<br>map容器中所有元素会根据元素的key自动排序 不能通过map的迭代器改变map的值 因为map的key关系到map元素的排列规则 若想要修改map的value是可以的<br>与set容器相同 multimap的键值可以重复</p><h5 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1,T2&gt; mapt;<span class="comment">//map默认构造函数</span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mapt);<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">map</span>(iterator begin,iterator end);<span class="comment">//区间构造函数</span></span><br></pre></td></tr></table></figure><h5 id="map赋值"><a href="#map赋值" class="headerlink" title="map赋值"></a>map赋值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map &amp;<span class="keyword">operator</span>=(<span class="type">const</span> map &amp;mapt);<span class="comment">//重载运算符=</span></span><br><span class="line"><span class="built_in">swap</span>(mp);<span class="comment">//交换</span></span><br></pre></td></tr></table></figure><h5 id="map空间操作"><a href="#map空间操作" class="headerlink" title="map空间操作"></a>map空间操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">empty</span>();</span><br><span class="line"><span class="built_in">max_size</span>();</span><br></pre></td></tr></table></figure><h5 id="map插入删除"><a href="#map插入删除" class="headerlink" title="map插入删除"></a>map插入删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------四种插入方式演示----------------//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; student;<span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//第一种初始化 使用value_type</span></span><br><span class="line">    student.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">100</span>,<span class="string">&quot;syh&quot;</span>));</span><br><span class="line">    <span class="comment">//第二种初始化 使用pair</span></span><br><span class="line">    student.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">200</span>,<span class="string">&quot;sc&quot;</span>));</span><br><span class="line">    <span class="comment">//第三种初始化 使用make_pair</span></span><br><span class="line">    student.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">300</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">    <span class="comment">//第四种初始化 使用数组初始化 数组的序号为first 数组的赋值为second</span></span><br><span class="line">    student[<span class="number">3</span>]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">//使用迭代器遍历输出</span></span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter=student.<span class="built_in">begin</span>();iter!=student.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为:<br>    3 test<br>    100 syh<br>    200 sc<br>    300 abc</p><h5 id="map查找"><a href="#map查找" class="headerlink" title="map查找"></a>map查找</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//查找key值是否存在 存在返回该元素的迭代器 不存在返回 end()</span></span><br><span class="line"><span class="built_in">count</span>(key);<span class="comment">//查找map中key的对数 对map来说要么是0要么是1 对multimap来说 可能大于1</span></span><br><span class="line"><span class="comment">//count对map来说也可以用if来判断是否能查找到想要的key</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>(keyElem);<span class="comment">//返回第一个值大于keyElem的迭代器</span></span><br><span class="line"><span class="built_in">upper_bound</span>(keyElem);<span class="comment">//返回最后一个值大于keyElem的迭代器</span></span><br><span class="line"><span class="built_in">equal_range</span>(keyElem);<span class="comment">//返回值是一个pair类型</span></span><br></pre></td></tr></table></figure><h5 id="map删除数据"><a href="#map删除数据" class="headerlink" title="map删除数据"></a>map删除数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">erase</span>(map&lt;T1,T2&gt;::iterator iter);<span class="comment">// 删除迭代器所指的节点</span></span><br><span class="line"><span class="built_in">erase</span>(key);<span class="comment">//删除key值对应的节点</span></span><br><span class="line"><span class="built_in">erase</span>(map&lt;T1,T2&gt;::iterator iter1,map&lt;T1,T2&gt;::iterator iter2);<span class="comment">//删除iter1到iter2之间的数据</span></span><br></pre></td></tr></table></figure><h4 id="STL容器表格对比"><a href="#STL容器表格对比" class="headerlink" title="STL容器表格对比"></a>STL容器表格对比</h4><p>||vector|deque|list|set|multiset|map|multimap|<br>|:——:|:——:|:——:|:——:|:——:|:——:|:——:|:——:|:——:|:——:|<br>|数据结构|单端数组|双向队列|循环双向链表|二叉树|二叉树|二叉树|二叉树|<br>|随机存取|是|是|否|否|否|key(否)|key(否)|<br>|元素寻找|慢|慢|非常慢|快|快|key(快)|key(快)|<br>|元素增减|尾端|头/尾|任何位置|-|-|-|-|</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>STL收录了大量常用的算法例如排序sort() 查找find()等等 特定的算法搭配特定的数据结构<br>算法分为质变算法和非质变算法<br>质变算法是指运算过程中会改变元素的内容 例如拷贝替换删除等<br>非质变算法是指运算过程中不会改变元素的内容 例如查找遍历寻找极值等等</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器(iterator)是一种抽象的设计概念 《设计模式》一书中囊括了共23种设计模式的完整描述<br>其中关于迭代器的定义为:提供一种方法 使之能够依照次序寻访某个容器中的各个元素 并且还可以不暴露容器的内部表示方式<br>综上 迭代器就是在某一容器中进行某种算法的操作 可谓是容器和算法的粘合剂 容器和算法分开独立设计 再由迭代器粘合在一起 这也是STL的中心思想<br>迭代器的种类分为:<br>输入迭代器 输出迭代器 前向迭代器 双向迭代器 随机访问迭代器</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 构造函数&amp;运算符重载</title>
      <link href="/2020/04/18/C++%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2020/04/18/C++%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="C-构造函数-amp-运算符重载"><a href="#C-构造函数-amp-运算符重载" class="headerlink" title="C++ 构造函数&amp;运算符重载"></a>C++ 构造函数&amp;运算符重载</h2><p>构造函数:创建对象时调用的类成员函数 构造函数可以重载<br>默认构造函数:无参数构造函数 名称和类名相同<br>有参构造函数:名称和类名相同 参数列表的参数表示的不是类成员 而是要赋给类成员的值<br>拷贝(复制)构造函数:一种特殊的构造函数 函数名称和类名称相同 拷贝构造函数的参数列表里必须有一个参数是本类型的一个引用变量<br>析构函数:删除对象时调用的类成员函数 没有参数 在程序关闭前调用析构函数释放资源 析构函数无法重载<br>C++重载:C++允许在同一作用域存在多个功能相似的同名函数和运算符<br>运算符重载:重载的运算符是带有特殊名称的函数，函数名是由关键字<code>operator</code>和其后要重载的运算符符号构成的</p><span id="more"></span> <h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数，就是以一个对象作为另一个类对象初值的构造函数。在下面三种情况下会调用拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chess</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//-------------第一种---------------//</span></span><br><span class="line"><span class="comment">//用一个对象对另一个对象进行显式的初始化</span></span><br><span class="line">Chess chess_one;</span><br><span class="line">Chess chess_two = chess_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------第二种---------------//</span></span><br><span class="line"><span class="comment">//将一个对象作为函数参数 以值传递的方式传给函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getName</span><span class="params">(Chess a)</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">getName</span>(chess_one);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------第三种---------------//</span></span><br><span class="line"><span class="comment">//把一个对象作为函数的返回值 以值传递的方式从函数返回</span></span><br><span class="line"><span class="function">Chess <span class="title">setName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Chess chess_one;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> chess_one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序实例1"><a href="#程序实例1" class="headerlink" title="程序实例1:"></a>程序实例1:</h2><p>程序文件constructor存放在文件目录中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStr</span>();<span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">MyStr</span>(string n);<span class="comment">//有参数构造函数</span></span><br><span class="line">    <span class="built_in">MyStr</span>(<span class="type">const</span> MyStr &amp;s);<span class="comment">//复制构造函数 因为数据成员中无指针 所以浅拷贝可行 后面会讨论浅拷贝深拷贝</span></span><br><span class="line">    ~<span class="built_in">MyStr</span>();<span class="comment">//析构函数</span></span><br><span class="line">    MyStr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MyStr &amp;s)&#123;<span class="comment">//把运算符=重载 因为我们下面要用到对象=对象来进行赋值 记住这个&amp;</span></span><br><span class="line">    <span class="comment">//加上const 对于const和非const的实参函数都能接受 如果不加const 函数就只能接受非const的实参</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;重载赋值运算符= &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=s.name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回值是被赋值者的引用 即*this 这样在函数返回时候避免一次拷贝提高效率</span></span><br><span class="line">        <span class="comment">//这样可以实现连续赋值(a=b=c)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="type">const</span> MyStr &amp;s)&#123;</span><br><span class="line">        os&lt;&lt;s.name&lt;&lt;endl;<span class="comment">//因为name是私有成员 所以函数要声明友元friend</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyStr::<span class="built_in">MyStr</span>()&#123;</span><br><span class="line">    name=<span class="string">&quot;syh&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;默认无参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">MyStr::<span class="built_in">MyStr</span>(string n)&#123;</span><br><span class="line">    name=n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;有参数构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">MyStr::~<span class="built_in">MyStr</span>() &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">MyStr::<span class="built_in">MyStr</span>(<span class="type">const</span> MyStr &amp;s) &#123;</span><br><span class="line">    name=s.name;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">MyStr::<span class="built_in">MyStr</span>(<span class="type">const</span> <span class="type">char</span> *c) &#123;<span class="comment">//有了这个构造函数可以直接MyStr str=&quot;sdas&quot;来进行初始化</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;拷贝构造函数(指针字符串)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    name=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStr str1;<span class="comment">//调用无参构造函数</span></span><br><span class="line">    <span class="function">MyStr <span class="title">str2</span><span class="params">(<span class="string">&quot;outlook&quot;</span>)</span></span>;<span class="comment">//调用有参数构造函数</span></span><br><span class="line">    MyStr str3=str2;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    MyStr str4;<span class="comment">//调用无参构造函数</span></span><br><span class="line">    str4=str2;<span class="comment">//调用重载运算符=</span></span><br><span class="line">    cout&lt;&lt;str1&lt;&lt;str2&lt;&lt;str3&lt;&lt;str4;<span class="comment">//&lt;&lt;被重载设计成能够输出对象的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//调用四次析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">默认无参构造函数</span><br><span class="line">有参数构造函数</span><br><span class="line">拷贝构造函数</span><br><span class="line">默认无参构造函数</span><br><span class="line">重载赋值运算符=</span><br><span class="line">syh</span><br><span class="line">outlook</span><br><span class="line">outlook</span><br><span class="line">outlook</span><br><span class="line">调用析构函数</span><br><span class="line">调用析构函数</span><br><span class="line">调用析构函数</span><br><span class="line">调用析构函数</span><br></pre></td></tr></table></figure><h2 id="程序修改-amp"><a href="#程序修改-amp" class="headerlink" title="程序修改 &amp;"></a>程序修改 &amp;</h2><p>程序实例中第12行代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyStr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MyStr &amp;s);</span><br></pre></td></tr></table></figure><p>如果删掉<code>&amp;</code> 运算符=的重载就会发生一些变化<br>如果不加<code>&amp;</code> 就会在函数调用的时候对实参进行一次拷贝<br>程序运行结果就变为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">默认无参构造函数</span><br><span class="line">有参数构造函数</span><br><span class="line">拷贝构造函数</span><br><span class="line">默认无参构造函数</span><br><span class="line">重载赋值运算符=</span><br><span class="line">拷贝构造函数 <span class="comment">#新增</span></span><br><span class="line">调用析构函数 <span class="comment">#新增</span></span><br><span class="line">syh</span><br><span class="line">outlook</span><br><span class="line">outlook</span><br><span class="line">outlook</span><br><span class="line">调用析构函数</span><br><span class="line">调用析构函数</span><br><span class="line">调用析构函数</span><br><span class="line">调用析构函数</span><br></pre></td></tr></table></figure><p>执行到str4=str2这个赋值传参的时候 在调用运算符=重载之后 会生成一个临时对象 这个临时对象我们暂称pro pro获得了str2的值然后调用了拷贝构造函数将这个值传给str4 然后pro被析构<br><code>MyStr str4;str4=str2;</code>代码等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyStr str4;</span><br><span class="line">pro=str2;//临时对象运算符=重载赋值</span><br><span class="line"><span class="comment">#临时对象pro</span></span><br><span class="line">MyStr str4=pro;//拷贝构造</span><br></pre></td></tr></table></figure><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是系统提供的默认拷贝构造函数<br>浅拷贝执行<code>MyStr str3=str2;</code>仅仅是将对象str2中各个数据成员的值拷贝给对象str3中的数据成员 而不做其他事情 这样str2与str3的name值是相同的 并且它俩指向内存中的同一区域<br>当我们修改str2的name值时 str3的name也会被修改<br>当执行str2和str3的析构函数时 同一内存区域会被释放两次 程序崩溃 </p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>程序实例是深拷贝 当然使用浅拷贝也可以 因为成员变量中没有指针<br>深拷贝是必须显示提供拷贝构造函数 这样执行<code>MyStr str3=str2;</code>为str3的name申请了新的地址空间 再将str2的name值拷贝到str3的name中 这样str2.name与str3.name各自独立</p><h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>C++规定 赋值运算符重载函数 只能是类的非静态的成员函数 不能是静态成员函数也不能是友元函数</p><p>不能是静态成员函数的原因:静态成员函数只能操作类的静态数据成员 不能操作非静态成员<br>不能是友元函数的原因:C++规定当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时 编译器会自动提供一个 但是友元函数并不属于这个类 当我们提供了一个友元的赋值运算符重载时 系统也会自动提供一个 这样程序执行时会产生二义性 C++强制规定 赋值运算符重载函数只能定义为类的成员函数</p><p>赋值运算符重载函数也不能被继承:若子类自己不提供赋值运算符重载函数只是用父类的重载函数 父类的重载函数只能调用父类自己的数据成员 那么子类的数据成员就无法被使用 </p><p>赋值运算符函数要避免自己给自己赋值 如果出现自赋值 立即<code>return *this;</code>:自己给自己赋值毫无意义 还会调用其他函数开销很大</p><p>如果类的数据成员中含有指针p 假设用指针q赋值给p 需要先将p原来指向的空间delete掉(因为指针p的空间通常是之前new来的 如果为p重新分配空间的时候没有将原来的空间delete掉会造成内存泄漏) 如果是自赋值 那么q和p是同一个指针 指向同一个内存空间 在赋值前需要对p原来空间delete 那么q指向的内容也被删除 无法赋值</p><p>定义赋值运算符函数时 需要关注如下几点:<br>1.是否把返回值的类型声明为该类型的引用 并在函数结束前返回对象自身的引用(*this) 只有返回一个引用 才可以允许连续赋值(a=b=c) 否则如果函数的返回值是void 应用该赋值运算符将不能连续赋值 程序不能通过编译<br>2.是否把传入的参数类型声明为const引用 若传入的参数不是引用而是对象 那么从形参到实参会调用一次复制构造函数 把参数声明为引用可以避免这一次无谓的消耗提高代码效率 同时我们在赋值运算符函数内不会改变传入的对象的窗台 因此加上const关键字<br>3.是否释放对象自身已有的内存 若忘记在分配新内存之前释放已有空间 会出现内存泄漏<br>4.是否判断传入的参数和当前对象(*this)是不是同一个对象 如果是同一个 则不进行赋值操作 直接返回 若不判断就进行赋值 那么在释放对象自身的内存的时候会导致:当 *this和传入的参数是同一个对象时 一旦释放了自身的内存 传入参数的内存也同时被释放了 就再也找不到需要赋值的内容了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyStr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MyStr &amp;s)&#123;<span class="comment">//把运算符=重载 因为我们下面要用到对象=对象来进行赋值 记住这个&amp;</span></span><br><span class="line">    <span class="comment">//加上const 对于const和非const的实参函数都能接受 如果不加const 函数就只能接受非const的实参</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;重载赋值运算符= &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;s)&#123;</span><br><span class="line">            <span class="function">MyStr <span class="title">strT</span><span class="params">(s)</span></span>;<span class="comment">//隐式调用构造函数</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> *pTemp=strT.name;</span><br><span class="line">            strT.name=name;</span><br><span class="line">            name=pTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回值是被赋值者的引用 即*this 这样在函数返回时候避免一次拷贝提高效率</span></span><br><span class="line">        <span class="comment">//这样可以实现连续赋值(a=b=c)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数中 先创建一个临时对象strT 然后把strT.name和对象自身的name做交换 由于strT是一个局部变量 离开了if作用域 自动调用strT的析构函数 由于strT.name指向的内存就是对象之前name的内存 相当于自己调用析构函数释放对象的内存</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Next主题配置gitalk</title>
      <link href="/2020/03/17/Hexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AEgitalk/"/>
      <url>/2020/03/17/Hexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AEgitalk/</url>
      
        <content type="html"><![CDATA[<h2 id="gitalk"><a href="#gitalk" class="headerlink" title="gitalk"></a>gitalk</h2><p>在Hexo下的next主题中配置gitalk评论插件<br>gitalk是一个基于 Github Issue 和 Preact 开发的评论插件<br>项目地址是 <code>https://gitalk.github.io</code></p><span id="more"></span> <h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="新建一个github仓库"><a href="#新建一个github仓库" class="headerlink" title="新建一个github仓库"></a>新建一个github仓库</h3><p>在github上新建一个仓库用来存储博客的所有评论 一定要打开Issue 因为最后所有的评论都会被存储在这个仓库的Issue中</p><h3 id="Register-a-new-OAuth-application"><a href="#Register-a-new-OAuth-application" class="headerlink" title="Register a new OAuth application"></a>Register a new OAuth application</h3><p>在github中注册新应用 地址为 <code>https://github.com/settings/applications/new</code></p><p><img src="/2020/03/17/Hexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AEgitalk/OAuth.png" alt="OAuth"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数说明</span></span><br><span class="line">Application name <span class="comment">#应用名随便填写</span></span><br><span class="line">Homepage URL <span class="comment">#填写博客地址 例如:https://shaoyuanhangyes.github.io</span></span><br><span class="line">Authorization callback URL <span class="comment">#填写博客地址</span></span><br></pre></td></tr></table></figure><p>注册成功后 会跳转到github/setting/Developer setting的OAuth Apps页面<br>页面中显示了Client ID和Client Secret 这两项字段需要记忆保存下来</p><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><h3 id="md5-min-js"><a href="#md5-min-js" class="headerlink" title="md5.min,js"></a>md5.min,js</h3><p>部分文章评论区报错<code>Error:Validation Failed</code><br>原因是gitalk的label标题长度要求不超过50 解决方案为通过MD5加密来缩短label长度<br>在文件目录<code>themes/next/source/js/src/</code>下创建<code>md5.min.js</code>文件 内容为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">! <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">t</span>(<span class="params">n, t</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = (<span class="number">65535</span> &amp; n) + (<span class="number">65535</span> &amp; t);</span><br><span class="line">        <span class="keyword">return</span> (n &gt;&gt; <span class="number">16</span>) + (t &gt;&gt; <span class="number">16</span>) + (r &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">16</span> | <span class="number">65535</span> &amp; r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">r</span>(<span class="params">n, t</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt;&lt; t | n &gt;&gt;&gt; <span class="number">32</span> - t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">e</span>(<span class="params">n, e, o, u, c, f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">t</span>(<span class="title function_">r</span>(<span class="title function_">t</span>(<span class="title function_">t</span>(e, n), <span class="title function_">t</span>(u, f)), c), o)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">o</span>(<span class="params">n, t, r, o, u, c, f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">e</span>(t &amp; r | ~t &amp; o, n, t, u, c, f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">u</span>(<span class="params">n, t, r, o, u, c, f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">e</span>(t &amp; o | r &amp; ~o, n, t, u, c, f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params">n, t, r, o, u, c, f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">e</span>(t ^ r ^ o, n, t, u, c, f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">n, t, r, o, u, c, f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">e</span>(r ^ (t | ~o), n, t, u, c, f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">i</span>(<span class="params">n, r</span>) &#123;</span><br><span class="line">        n[r &gt;&gt; <span class="number">5</span>] |= <span class="number">128</span> &lt;&lt; r % <span class="number">32</span>, n[<span class="number">14</span> + (r + <span class="number">64</span> &gt;&gt;&gt; <span class="number">9</span> &lt;&lt; <span class="number">4</span>)] = r;</span><br><span class="line">        <span class="keyword">var</span> e, i, a, d, h, l = <span class="number">1732584193</span>,</span><br><span class="line">            g = -<span class="number">271733879</span>,</span><br><span class="line">            v = -<span class="number">1732584194</span>,</span><br><span class="line">            m = <span class="number">271733878</span>;</span><br><span class="line">        <span class="keyword">for</span> (e = <span class="number">0</span>; e &lt; n.<span class="property">length</span>; e += <span class="number">16</span>) i = l, a = g, d = v, h = m, g = <span class="title function_">f</span>(g = <span class="title function_">f</span>(g = <span class="title function_">f</span>(g = <span class="title function_">f</span>(g = <span class="title function_">c</span>(g = <span class="title function_">c</span>(g = <span class="title function_">c</span>(g = <span class="title function_">c</span>(g = <span class="title function_">u</span>(g = <span class="title function_">u</span>(g = <span class="title function_">u</span>(g = <span class="title function_">u</span>(g = <span class="title function_">o</span>(g = <span class="title function_">o</span>(g = <span class="title function_">o</span>(g = <span class="title function_">o</span>(g, v = <span class="title function_">o</span>(v, m = <span class="title function_">o</span>(m, l = <span class="title function_">o</span>(l, g, v, m, n[e], <span class="number">7</span>, -<span class="number">680876936</span>), g, v, n[e + <span class="number">1</span>], <span class="number">12</span>, -<span class="number">389564586</span>), l, g, n[e + <span class="number">2</span>], <span class="number">17</span>, <span class="number">606105819</span>), m, l, n[e + <span class="number">3</span>], <span class="number">22</span>, -<span class="number">1044525330</span>), v = <span class="title function_">o</span>(v, m = <span class="title function_">o</span>(m, l = <span class="title function_">o</span>(l, g, v, m, n[e + <span class="number">4</span>], <span class="number">7</span>, -<span class="number">176418897</span>), g, v, n[e + <span class="number">5</span>], <span class="number">12</span>, <span class="number">1200080426</span>), l, g, n[e + <span class="number">6</span>], <span class="number">17</span>, -<span class="number">1473231341</span>), m, l, n[e + <span class="number">7</span>], <span class="number">22</span>, -<span class="number">45705983</span>), v = <span class="title function_">o</span>(v, m = <span class="title function_">o</span>(m, l = <span class="title function_">o</span>(l, g, v, m, n[e + <span class="number">8</span>], <span class="number">7</span>, <span class="number">1770035416</span>), g, v, n[e + <span class="number">9</span>], <span class="number">12</span>, -<span class="number">1958414417</span>), l, g, n[e + <span class="number">10</span>], <span class="number">17</span>, -<span class="number">42063</span>), m, l, n[e + <span class="number">11</span>], <span class="number">22</span>, -<span class="number">1990404162</span>), v = <span class="title function_">o</span>(v, m = <span class="title function_">o</span>(m, l = <span class="title function_">o</span>(l, g, v, m, n[e + <span class="number">12</span>], <span class="number">7</span>, <span class="number">1804603682</span>), g, v, n[e + <span class="number">13</span>], <span class="number">12</span>, -<span class="number">40341101</span>), l, g, n[e + <span class="number">14</span>], <span class="number">17</span>, -<span class="number">1502002290</span>), m, l, n[e + <span class="number">15</span>], <span class="number">22</span>, <span class="number">1236535329</span>), v = <span class="title function_">u</span>(v, m = <span class="title function_">u</span>(m, l = <span class="title function_">u</span>(l, g, v, m, n[e + <span class="number">1</span>], <span class="number">5</span>, -<span class="number">165796510</span>), g, v, n[e + <span class="number">6</span>], <span class="number">9</span>, -<span class="number">1069501632</span>), l, g, n[e + <span class="number">11</span>], <span class="number">14</span>, <span class="number">643717713</span>), m, l, n[e], <span class="number">20</span>, -<span class="number">373897302</span>), v = <span class="title function_">u</span>(v, m = <span class="title function_">u</span>(m, l = <span class="title function_">u</span>(l, g, v, m, n[e + <span class="number">5</span>], <span class="number">5</span>, -<span class="number">701558691</span>), g, v, n[e + <span class="number">10</span>], <span class="number">9</span>, <span class="number">38016083</span>), l, g, n[e + <span class="number">15</span>], <span class="number">14</span>, -<span class="number">660478335</span>), m, l, n[e + <span class="number">4</span>], <span class="number">20</span>, -<span class="number">405537848</span>), v = <span class="title function_">u</span>(v, m = <span class="title function_">u</span>(m, l = <span class="title function_">u</span>(l, g, v, m, n[e + <span class="number">9</span>], <span class="number">5</span>, <span class="number">568446438</span>), g, v, n[e + <span class="number">14</span>], <span class="number">9</span>, -<span class="number">1019803690</span>), l, g, n[e + <span class="number">3</span>], <span class="number">14</span>, -<span class="number">187363961</span>), m, l, n[e + <span class="number">8</span>], <span class="number">20</span>, <span class="number">1163531501</span>), v = <span class="title function_">u</span>(v, m = <span class="title function_">u</span>(m, l = <span class="title function_">u</span>(l, g, v, m, n[e + <span class="number">13</span>], <span class="number">5</span>, -<span class="number">1444681467</span>), g, v, n[e + <span class="number">2</span>], <span class="number">9</span>, -<span class="number">51403784</span>), l, g, n[e + <span class="number">7</span>], <span class="number">14</span>, <span class="number">1735328473</span>), m, l, n[e + <span class="number">12</span>], <span class="number">20</span>, -<span class="number">1926607734</span>), v = <span class="title function_">c</span>(v, m = <span class="title function_">c</span>(m, l = <span class="title function_">c</span>(l, g, v, m, n[e + <span class="number">5</span>], <span class="number">4</span>, -<span class="number">378558</span>), g, v, n[e + <span class="number">8</span>], <span class="number">11</span>, -<span class="number">2022574463</span>), l, g, n[e + <span class="number">11</span>], <span class="number">16</span>, <span class="number">1839030562</span>), m, l, n[e + <span class="number">14</span>], <span class="number">23</span>, -<span class="number">35309556</span>), v = <span class="title function_">c</span>(v, m = <span class="title function_">c</span>(m, l = <span class="title function_">c</span>(l, g, v, m, n[e + <span class="number">1</span>], <span class="number">4</span>, -<span class="number">1530992060</span>), g, v, n[e + <span class="number">4</span>], <span class="number">11</span>, <span class="number">1272893353</span>), l, g, n[e + <span class="number">7</span>], <span class="number">16</span>, -<span class="number">155497632</span>), m, l, n[e + <span class="number">10</span>], <span class="number">23</span>, -<span class="number">1094730640</span>), v = <span class="title function_">c</span>(v, m = <span class="title function_">c</span>(m, l = <span class="title function_">c</span>(l, g, v, m, n[e + <span class="number">13</span>], <span class="number">4</span>, <span class="number">681279174</span>), g, v, n[e], <span class="number">11</span>, -<span class="number">358537222</span>), l, g, n[e + <span class="number">3</span>], <span class="number">16</span>, -<span class="number">722521979</span>), m, l, n[e + <span class="number">6</span>], <span class="number">23</span>, <span class="number">76029189</span>), v = <span class="title function_">c</span>(v, m = <span class="title function_">c</span>(m, l = <span class="title function_">c</span>(l, g, v, m, n[e + <span class="number">9</span>], <span class="number">4</span>, -<span class="number">640364487</span>), g, v, n[e + <span class="number">12</span>], <span class="number">11</span>, -<span class="number">421815835</span>), l, g, n[e + <span class="number">15</span>], <span class="number">16</span>, <span class="number">530742520</span>), m, l, n[e + <span class="number">2</span>], <span class="number">23</span>, -<span class="number">995338651</span>), v = <span class="title function_">f</span>(v, m = <span class="title function_">f</span>(m, l = <span class="title function_">f</span>(l, g, v, m, n[e], <span class="number">6</span>, -<span class="number">198630844</span>), g, v, n[e + <span class="number">7</span>], <span class="number">10</span>, <span class="number">1126891415</span>), l, g, n[e + <span class="number">14</span>], <span class="number">15</span>, -<span class="number">1416354905</span>), m, l, n[e + <span class="number">5</span>], <span class="number">21</span>, -<span class="number">57434055</span>), v = <span class="title function_">f</span>(v, m = <span class="title function_">f</span>(m, l = <span class="title function_">f</span>(l, g, v, m, n[e + <span class="number">12</span>], <span class="number">6</span>, <span class="number">1700485571</span>), g, v, n[e + <span class="number">3</span>], <span class="number">10</span>, -<span class="number">1894986606</span>), l, g, n[e + <span class="number">10</span>], <span class="number">15</span>, -<span class="number">1051523</span>), m, l, n[e + <span class="number">1</span>], <span class="number">21</span>, -<span class="number">2054922799</span>), v = <span class="title function_">f</span>(v, m = <span class="title function_">f</span>(m, l = <span class="title function_">f</span>(l, g, v, m, n[e + <span class="number">8</span>], <span class="number">6</span>, <span class="number">1873313359</span>), g, v, n[e + <span class="number">15</span>], <span class="number">10</span>, -<span class="number">30611744</span>), l, g, n[e + <span class="number">6</span>], <span class="number">15</span>, -<span class="number">1560198380</span>), m, l, n[e + <span class="number">13</span>], <span class="number">21</span>, <span class="number">1309151649</span>), v = <span class="title function_">f</span>(v, m = <span class="title function_">f</span>(m, l = <span class="title function_">f</span>(l, g, v, m, n[e + <span class="number">4</span>], <span class="number">6</span>, -<span class="number">145523070</span>), g, v, n[e + <span class="number">11</span>], <span class="number">10</span>, -<span class="number">1120210379</span>), l, g, n[e + <span class="number">2</span>], <span class="number">15</span>, <span class="number">718787259</span>), m, l, n[e + <span class="number">9</span>], <span class="number">21</span>, -<span class="number">343485551</span>), l = <span class="title function_">t</span>(l, i), g = <span class="title function_">t</span>(g, a), v = <span class="title function_">t</span>(v, d), m = <span class="title function_">t</span>(m, h);</span><br><span class="line">        <span class="keyword">return</span> [l, g, v, m]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> t, r = <span class="string">&quot;&quot;</span>,</span><br><span class="line">            e = <span class="number">32</span> * n.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; e; t += <span class="number">8</span>) r += <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(n[t &gt;&gt; <span class="number">5</span>] &gt;&gt;&gt; t % <span class="number">32</span> &amp; <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">d</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> t, r = [];</span><br><span class="line">        <span class="keyword">for</span> (r[(n.<span class="property">length</span> &gt;&gt; <span class="number">2</span>) - <span class="number">1</span>] = <span class="keyword">void</span> <span class="number">0</span>, t = <span class="number">0</span>; t &lt; r.<span class="property">length</span>; t += <span class="number">1</span>) r[t] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="number">8</span> * n.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; e; t += <span class="number">8</span>) r[t &gt;&gt; <span class="number">5</span>] |= (<span class="number">255</span> &amp; n.<span class="title function_">charCodeAt</span>(t / <span class="number">8</span>)) &lt;&lt; t % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">a</span>(<span class="title function_">i</span>(<span class="title function_">d</span>(n), <span class="number">8</span> * n.<span class="property">length</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">l</span>(<span class="params">n, t</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r, e, o = <span class="title function_">d</span>(n),</span><br><span class="line">            u = [],</span><br><span class="line">            c = [];</span><br><span class="line">        <span class="keyword">for</span> (u[<span class="number">15</span>] = c[<span class="number">15</span>] = <span class="keyword">void</span> <span class="number">0</span>, o.<span class="property">length</span> &gt; <span class="number">16</span> &amp;&amp; (o = <span class="title function_">i</span>(o, <span class="number">8</span> * n.<span class="property">length</span>)), r = <span class="number">0</span>; r &lt; <span class="number">16</span>; r += <span class="number">1</span>) u[r] = <span class="number">909522486</span> ^ o[r], c[r] = <span class="number">1549556828</span> ^ o[r];</span><br><span class="line">        <span class="keyword">return</span> e = <span class="title function_">i</span>(u.<span class="title function_">concat</span>(<span class="title function_">d</span>(t)), <span class="number">512</span> + <span class="number">8</span> * t.<span class="property">length</span>), <span class="title function_">a</span>(<span class="title function_">i</span>(c.<span class="title function_">concat</span>(e), <span class="number">640</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> t, r, e = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; n.<span class="property">length</span>; r += <span class="number">1</span>) t = n.<span class="title function_">charCodeAt</span>(r), e += <span class="string">&quot;0123456789abcdef&quot;</span>.<span class="title function_">charAt</span>(t &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">15</span>) + <span class="string">&quot;0123456789abcdef&quot;</span>.<span class="title function_">charAt</span>(<span class="number">15</span> &amp; t);</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">v</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(n))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title function_">v</span>(n))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">p</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">g</span>(<span class="title function_">m</span>(n))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params">n, t</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">l</span>(<span class="title function_">v</span>(n), <span class="title function_">v</span>(t))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params">n, t</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">g</span>(<span class="title function_">s</span>(n, t))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">n, t, r</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t ? r ? <span class="title function_">s</span>(t, n) : <span class="title function_">C</span>(t, n) : r ? <span class="title function_">m</span>(n) : <span class="title function_">p</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> define &amp;&amp; define.<span class="property">amd</span> ? <span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line">    &#125;) : <span class="string">&quot;object&quot;</span> == <span class="keyword">typeof</span> <span class="variable language_">module</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span> ? <span class="variable language_">module</span>.<span class="property">exports</span> = A : n.<span class="property">md5</span> = A</span><br><span class="line">&#125;(<span class="variable language_">this</span>);</span><br><span class="line"><span class="comment">//# sourceMappingURL=md5.min.js.map</span></span><br></pre></td></tr></table></figure><p>并且要在下一项即将新建的<code>gital.swig</code>文件中引入这个js文件 同时要对id进行md5加密</p><h3 id="gitalk-swig"><a href="#gitalk-swig" class="headerlink" title="gitalk.swig"></a>gitalk.swig</h3><p>在文件目录<code>themes/next/layout/_third-party/comments/</code>下 新建<code>gitalk.swig</code>文件<br>添加代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;<span class="built_in">link</span> rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;/js/src/md5.min.js&quot;</span>&gt;&lt;/script&gt; <span class="comment">#引入md5.js</span></span><br><span class="line">   &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: <span class="string">&#x27;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&#x27;</span>,</span><br><span class="line">          clientSecret: <span class="string">&#x27;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&#x27;</span>,</span><br><span class="line">          repo: <span class="string">&#x27;&#123;&#123; theme.gitalk.repo &#125;&#125;&#x27;</span>,</span><br><span class="line">          owner: <span class="string">&#x27;&#123;&#123; theme.gitalk.owner &#125;&#125;&#x27;</span>,</span><br><span class="line">          admin: [<span class="string">&#x27;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&#x27;</span>],</span><br><span class="line">          <span class="built_in">id</span>: md5(&#123;&#123; theme.gitalk.ID &#125;&#125;), <span class="comment">#对id进行md5加密</span></span><br><span class="line">          labels: &#123;&#123; theme.gitalk.labels &#125;&#125;,</span><br><span class="line">          perPage: &#123;&#123; theme.gitalk.perPage &#125;&#125;,</span><br><span class="line">          pagerDirection: <span class="string">&#x27;&#123;&#123; theme.gitalk.pagerDirection &#125;&#125;&#x27;</span>,</span><br><span class="line">          createIssueManually: &#123;&#123; theme.gitalk.createIssueManually &#125;&#125;,</span><br><span class="line">          distractionFreeMode: &#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(<span class="string">&#x27;gitalk-container&#x27;</span>)           </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="index-swig"><a href="#index-swig" class="headerlink" title="index.swig"></a>index.swig</h3><p>修改<code>themes/next/layout/_third-party/comments/index.swig</code>文件 在最后一行添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">&#x27;gitalk.swig&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure><h3 id="comments-swig"><a href="#comments-swig" class="headerlink" title="comments.swig"></a>comments.swig</h3><p>修改<code>themes/next/layout/_partials/comments.swig</code>文件 找到以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div class=<span class="string">&quot;comments&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;comments&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在空白处添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;div <span class="built_in">id</span>=<span class="string">&quot;gitalk-container&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="gitalk-styl"><a href="#gitalk-styl" class="headerlink" title="gitalk.styl"></a>gitalk.styl</h3><p>在文件目录下<code>themes/next/source/css/_common/components/third-party/</code>新建<code>gitalk.styl</code><br>添加代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure><h3 id="third-party-styl"><a href="#third-party-styl" class="headerlink" title="third-party.styl"></a>third-party.styl</h3><p>修改<code>themes/next/source/css/_common/components/third-party/third-party.styl</code>文件 在最后一行添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">&quot;gitalk&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>在next主题下的<code>themes/next/_config.yml</code>中添加gitalk的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  githubID: shaoyuanhangyes  <span class="comment"># account name</span></span><br><span class="line">  repo: gitalk <span class="comment"># GitHub repository.准备工作中新建的仓库</span></span><br><span class="line">  ClientID: fe67**************c438e <span class="comment"># GitHub Application Client ID.</span></span><br><span class="line">  ClientSecret: 62b0************86ab67bc57b11 <span class="comment"># GitHub Application Client Secret.</span></span><br><span class="line">  owner: shaoyuanhangyes <span class="comment"># GitHub repository owner. Can be personal user or organization.</span></span><br><span class="line">  adminUser: shaoyuanhangyes</span><br><span class="line">  distractionFreeMode: <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode.</span></span><br><span class="line">  ID: location.pathname</span><br><span class="line">  labels: <span class="string">&quot;[&#x27;Gitalk&#x27;]&quot;</span></span><br><span class="line">  perPage: 15 <span class="comment"># Pagination size, with maximum 100.</span></span><br><span class="line">  pagerDirection: last <span class="comment"># Comment sorting direction, available values are last and first. </span></span><br><span class="line">  createIssueManually: <span class="literal">true</span> <span class="comment"># By default, Gitalk will create a corresponding github issue for your every single page automatically when the logined user is belong to the admin users. You can create it manually by setting this option to true.</span></span><br></pre></td></tr></table></figure><h2 id="调试收集错误"><a href="#调试收集错误" class="headerlink" title="调试收集错误"></a>调试收集错误</h2><p>配置好后<code>hexo clean</code> <code>hexo g</code> <code>hexo d</code>部署完毕后即可<br>然后在某一文章下发现存在gitalk的评论框 先登录github账户 然后点击init按钮 自己发表一个评论 其他人就可以在这篇文章下评论了</p><h3 id="Error-Not-Found"><a href="#Error-Not-Found" class="headerlink" title="Error Not Found"></a>Error Not Found</h3><p>错误原因是主题配置文件<code>_config.yml</code>中gitalk字段配置错误 往往错误集中在<code>repo</code>中 这个仓库的名字要填写的是新申请要保存issues的仓库名</p><h3 id="Error-Validation-Failed"><a href="#Error-Validation-Failed" class="headerlink" title="Error:Validation Failed"></a>Error:Validation Failed</h3><p>错误原因 标题长度超过50 处理办法为使用md5加密id来缩短label长度 具体操作在<code>md5.min.js</code>栏目中</p>]]></content>
      
      
      <categories>
          
          <category> Hexo配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb</title>
      <link href="/2020/02/07/Mongodb/"/>
      <url>/2020/02/07/Mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu下Mongodb"><a href="#Ubuntu下Mongodb" class="headerlink" title="Ubuntu下Mongodb"></a>Ubuntu下Mongodb</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><span id="more"></span> <h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入Mongodb命令行界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p>创建数据库或进入现有数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use db_name <span class="comment">#db_name为数据库名字</span></span><br></pre></td></tr></table></figure><p>查看当前连接的数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure><p>查看所有的数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><p>销毁数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use <span class="built_in">local</span></span><br><span class="line">db.dropDatabase() <span class="comment">#销毁名为local的数据库</span></span><br></pre></td></tr></table></figure><p>创建集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use db_name</span><br><span class="line">db.createCollection(<span class="string">&quot;users&quot;</span>) <span class="comment">#在名为db_name的数据库下创建users集合</span></span><br><span class="line">show collecions <span class="comment">#查看集合</span></span><br><span class="line">db.users.drop() <span class="comment">#删除users集合</span></span><br></pre></td></tr></table></figure><p>向集合中插入数据<br>insert()方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use db_name</span><br><span class="line">db.users.insert([</span><br><span class="line">    &#123;name: <span class="string">&quot;syh&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;shaoyuanhangyes@outlook.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;name: <span class="string">&quot;Ruojhen&quot;</span>,</span><br><span class="line">    gender: <span class="string">&quot;male&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>save()方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use db_name</span><br><span class="line">db.users.save([</span><br><span class="line">    &#123;name: <span class="string">&quot;syh&quot;</span>,</span><br><span class="line">    email: <span class="string">&quot;shaoyuanhangyes@outlook.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;name: <span class="string">&quot;Ruojhen&quot;</span>,</span><br><span class="line">    gender: <span class="string">&quot;male&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>insert()与save()区别<br>insert侧重于新增记录 save可以保存一个新增记录也可以保存记录的修改 类似于Mysql的Update<br>查询语句<br>find()</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use db_name</span><br><span class="line">db.users.find() <span class="comment">#直接返回users集合中所有文档</span></span><br><span class="line">db.users.find().pretty() <span class="comment">#使返回的文档数据更加美观易读</span></span><br></pre></td></tr></table></figure><p>使得find()始终以pretty()返回</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;DBQuery.prototype._prettyShell = true&quot;</span> &gt;&gt; ~/.mongorc.js</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2020/02/07/Linux/"/>
      <url>/2020/02/07/Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="自用Linux命令笔记"><a href="#自用Linux命令笔记" class="headerlink" title="自用Linux命令笔记"></a>自用Linux命令笔记</h2><span id="more"></span><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>ls 查看当前目录下的文件夹有哪些<br>mkdir 新建一个文件夹<br>pwd 显示当前文件夹<br>rm 删除<br>cp 拷贝文件<br>mv 移动文件<br>tar 压缩文件<br>unzip 解压zip文件<br>ps 显示系统的运行进程<br>top 显示cpu占用</p><h1 id="Linux下多线程编程"><a href="#Linux下多线程编程" class="headerlink" title="Linux下多线程编程"></a>Linux下多线程编程</h1><h2 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h2><p>由I/O处理单元 逻辑单元 网络存储单元(可选)组成 每个单元间通过请求队列进行通信来协作<br>I/O处理单元:处理客户端连接 读写网络数据<br>逻辑单元:用于处理业务逻辑的线程<br>网络存储单元:本地数据库和文件等 </p><h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I/O模型"></a>五种I/O模型</h2><p>应用程序向操作系统发出I/O请求:应用程序发出IO请求给操作系统内核 操作系统内核需要等待数据就绪 这里的数据可能来自别的应用程序或者网络<br>一般I/O分为两个阶段 等待数据阶段 拷贝数据阶段 等待数据阶段 若没数据 应用程序就阻塞等待 拷贝数据阶段是将就绪的数据拷贝到应用程序工作区<br>在Linux系统中 操作系统的I/O操作是一个系统调用recvfrom() 就是一个系统调用recvfrom包含等待数据就绪和拷贝数据</p><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>输入输出(input/output)的对象可以是文件(file) 网络(socket) 进程之间的管道(pipe)<br>在linux系统中 都用文件描述符(fd)来表示<br>同步/异步是真对应用程序和内核的交互而言的 同步指用户进程触发I/O操作并等待或者轮询的去查看I/O操作是否就绪 比如自己洗衣服的时候不能干别的事情<br>异步是指用户进程触发I/O操作之后便开始做其他的事情 当I/O操作已经完成的时候会得到I/O操作完成的通知 例如自己用洗衣机洗衣服 期间去做别的事情 洗衣机洗好衣服会有声音提示</p><p>阻塞/非阻塞是针对进程在访问数据的时候 根据I/O操作的就绪状态来采取的不同方式<br>阻塞指当试图对文件描述符进行读写时 若缓冲区没东西可读或暂时不可写 程序就进入等待状态 直到有东西可读/写为止 比如人工窗口充值 若充值业务员不在 那我们只能在原地等待 一直等到业务员回来为止<br>非阻塞指当试图对文件描述符进行读写时 若缓冲区没东西可读或暂时不可写 读写函数马上返回 不会等待 比如在银行排队办业务 领取一张呼号票 之后去干自己的事情 等轮到我们了银行会呼叫通知 这时候我们再去办业务</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ol><li>可读事件:当文件描述符关联的内核读缓冲区可读 则触发可读事件 (可读：内核缓冲区非空，有数据可以读取)</li><li>可写事件:当文件描述符关联的内核写缓冲区可写 则触发可写事件 (可写：内核缓冲区不满，有空闲空间可以写入）</li></ol><h3 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h3><p>就是当事件发生时主动通知 通知机制的反面是轮询机制 意思就是挨个遍历去询问才能得到消息</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是一种I/O事件通知机制 是linux内核实现I/O多路复用的一个实现<br>I/O多路复用是指在一个操作里同时监听多个输入输出源 在其中一个或多个输入输出源可用的时候返回 然后对其进行读写操作<br>简言之 epoll是一种当文件描述符的内核缓冲区非空的时候发出可读信号来通知 当写缓冲区不满的时候发出可写的信号通知的一种机制</p><h4 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h4><h5 id="int-epoll-create-int-size"><a href="#int-epoll-create-int-size" class="headerlink" title="int epoll_create(int size)"></a>int epoll_create(int size)</h5><p>内核产生一个epoll实例数据结构并返回一个文件描述符(fd) 这个描述符就是epoll实例的句柄 后面的两个接口都以它为中心(形参epfd)<br>size表示所要监视文件描述符的最大值 不过后来的linux版本中已经被弃用 同时size不能传0 会抛出 invalid argument的error</p><h5 id="int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)"></a>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</h5><p>将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data&#123;</span><br><span class="line">    void *ptr; //指向用户自定义数据</span><br><span class="line">    int fd; //注册的文件描述符</span><br><span class="line">    unint32_t u32; //32bit <span class="built_in">integer</span></span><br><span class="line">    uint64_t u64; //64bit <span class="built_in">integer</span></span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">struct epolll_event&#123;</span><br><span class="line">    uint32_t events; //描述epoll事件</span><br><span class="line">    //events域描述一组epoll事件 在epoll_ctl调用中解释为描述符所期望的epoll事件 可多选</span><br><span class="line"></span><br><span class="line">    epoll_data_t data; //上面的union </span><br><span class="line">    //data域是唯一能给出描述符信息的字段 所以在调用epoll_ctl加入一个需要检测的描述符时</span><br><span class="line">    //一定要在data域写入描述符相关信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于需要监听的文件描述符的集合 epoll_ctl对红黑树进行管理 红黑树中的每个成员由描述符的值和所要监控的文件描述符指向的文件表项的引用等组成</p><p>op参数的操作类型有:<br>    1. epoll_ctl_add 向interest list添加一个需要监视的描述符<br>    2. epoll_ctl_del 从interest list中删除一个描述符<br>    3. epoll_ctl_mod 修改interest list中的一个描述符</p><p>struct epoll_event结构描述一个文件描述符的epoll行为 在使用epoll_wait()返回处于ready状态的描述符列表</p><p>常用epoll事件描述:<br>     epollin 描述符处于可读状态<br>     epollout 描述符处于可写状态<br>     epollpri 由带外数据触发 表示描述符有紧急的数据可读<br>     epollet 将epoll event通知模式设置为edge triggered 设置为边缘触发<br>     epolloneshot 第一次进行通知 之后不再监测 如果还想继续监测 就需要再次把这个socket加入到epoll队列中<br>     epollhup 本端描述符产生一个挂断事件 默认监测事件<br>     epollrdhup 对端描述符产生一个挂断事件<br>     epollerr 描述符产生错误时触发 默认监测事件</p><h5 id="int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)"></a>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</h5><p>阻塞等待注册的事件发生 返回事件的数目 并将触发的事件写入events数组中<br>epoll_wait返回值number是不会大于maxevents的 返回的是活跃客户端的数量 并且将这些活跃的客户端信息加入到events<br>events:用来记录被触发的events 大小和maxevents一致<br>maxevents:返回events的最大个数</p><p>处于ready状态的那些文件描述符会被复制进ready list中 epoll_wait()用于向用户进程返回ready list<br>events和maxevents两个参数描述一个由用户分配的struct epoll event数组 调用返回时 内核将ready list复制到这个数组中 并将实际复制的个数作为返回值<br>如果ready list比maxevents长就只能复制maxevents个成员</p><p>timeout:描述函数调用中阻塞时间上限 单位ms<br>    1. timeout = -1 表示调用将一直阻塞 直到有文件描述符进入ready状态或者捕捉到信号才返回<br>    2. timeout = 0  用于非阻塞检测是否有描述符处于ready状态 不管结果如何 调用都立即返回<br>    3. timeout &gt; 0  表示调用将最多持续timeout时间 如果期间有检测对象变为ready状态或捕捉到信号则返回 否则直到超时</p><h4 id="epoll的两种触发方式"><a href="#epoll的两种触发方式" class="headerlink" title="epoll的两种触发方式"></a>epoll的两种触发方式</h4><p>epoll监控多个文件描述符的I/O事件 epoll支持边缘触发(edge trigger ET)和水平触发(level trigger LT) 通过epoll_wait()等待I/O事件<br>如果当前没有可用事件就阻塞调用线程</p><p>select和poll只支持LT工作模式 epoll的默认工作模式是LT模式</p><h5 id="LT水平触发的时机"><a href="#LT水平触发的时机" class="headerlink" title="LT水平触发的时机"></a>LT水平触发的时机</h5><p>对于读操作 只要缓冲区不为空 LT模式返回读就绪<br>对于写操作 只要缓冲区还没满 LT模式返回写就绪<br>当被监控的文件描述符上有可读写事件发生时 epoll_wait()会通知处理程序去读写 如果这次没有把数据一次性全读完(读写缓冲区太小)<br>那么下次调用epoll_wait()时 它还会通知你在上次没读写完的文件描述符上继续读写 若你一直不去读写 它会一直通知你<br>若系统中有大量你不需要读写的文件描述符 而他们每次都返回 会大大降低处理程序检索自己关心的文件描述符的效率</p><h5 id="ET边缘触发的时机"><a href="#ET边缘触发的时机" class="headerlink" title="ET边缘触发的时机"></a>ET边缘触发的时机</h5><p>对于读操作<br>    1. 当缓冲区由不可读变为可读的时候(缓冲区由空变为不空的时候)<br>    2. 当有新数据到达的时候(缓冲区中的待读数据变多的时候)<br>    3. 当缓冲区内有数据可读 且应用程序对相应的文件描述符进行epoll_ctl_mod修改epollin事件时</p><p>对于写操作<br>    1. 当缓冲区由不可写变为可写时<br>    2. 当有旧数据被发送走 即缓冲区种数据变少的时候<br>    3. 当缓冲区有空间可写 且应用进程对相应的文件描述符进行epoll_ctl_mod修改epollout事件时</p><p>当被监控的文件描述符上有可读写事件发生时 epoll_wait()会通知处理程序去读写 如果这次没有把数据一次性全读完(读写缓冲区太小)<br>那么下次调用epoll_wait()时 那么下次调用epoll_wait()时 也就是它只会通知你一次 直到该文件描述符上出现第二次可读写事件才会通知你<br>这种模式比水平触发效率高 系统不会充斥大量你不关心的就绪文件描述符</p><p>在边缘触发的模式下 缓冲区从不可读变成可读 会唤醒应用进程 缓冲区数据变少的情况下不会再唤醒应用进程</p><p>For instance 1):<br>    1. 读缓冲区刚开始是空的<br>    2. 读缓冲区写入2KB数据<br>    3. 水平触发和边缘触发此时都会发出可读信号<br>    4. 收到信号通知后读取了1kb的数据 缓冲区还剩1kb<br>    5. 水平触发会再通知你继续读写 边缘触发不会再通知你</p><p>For instance 2):<br>    水平触发:0表示缓冲区无数据 1表示缓冲区有数据 缓冲区有数据则一直为1 就一直触发<br>    边缘触发:0表示缓冲区无数据 1表示缓冲区有数据 只有在0变为1的时候才触发</p><h4 id="epoll-select-poll比较"><a href="#epoll-select-poll比较" class="headerlink" title="epoll select poll比较"></a>epoll select poll比较</h4><h5 id="用户态将文件描述符传入内核的方式"><a href="#用户态将文件描述符传入内核的方式" class="headerlink" title="用户态将文件描述符传入内核的方式"></a>用户态将文件描述符传入内核的方式</h5><p>select: 创建3个文件描述符并拷贝到内核中 分别监听读/写/异常 这里单个进程可以打开的文件描述符fd数量默认限制为1024<br>poll: 将传入的struct pollfd结构体数组拷贝到内核中进行监听<br>epoll: 执行epoll_create会在内核的高速cache区域中建立一棵红黑树以及就绪链表(该链表存储已经就绪的文件描述符) 用户执行的epoll_ctl()添加文件描述符会在红黑树上增加相应的结点</p><h5 id="内核态检测文件描述符读写状态的方式"><a href="#内核态检测文件描述符读写状态的方式" class="headerlink" title="内核态检测文件描述符读写状态的方式"></a>内核态检测文件描述符读写状态的方式</h5><p>select: 采用轮询方式 遍历所有fd 最后返回一个描述符读写操作是否就绪的mask掩码 根据这个掩码给fd_set赋值<br>poll: 采用轮询方式 查询每个fd的状态 若就绪则在等待队列中加入一项并继续遍历<br>epoll: 采用回调机制 执行epoll_ctl的add操作时 不仅将文件描述符放进红黑树中 而且也注册了回调函数 内核在检测到某文件描述符可读/可写的时候会调用回调函数 该回调函数将fd放在就绪链表中</p><h5 id="找到就绪的文件描述符并传递给用户态的方式"><a href="#找到就绪的文件描述符并传递给用户态的方式" class="headerlink" title="找到就绪的文件描述符并传递给用户态的方式"></a>找到就绪的文件描述符并传递给用户态的方式</h5><p>select: 将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数 用户态并不知道是哪些文件描述符处于就绪态 需要遍历来判断<br>poll: 将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数 用户态并不知道是哪些文件描述符处于就绪态 需要遍历来判断<br>epoll: epoll_wait()只用观察就绪链表中有无数据就行 最后将链表的数据返回给数组并返回就绪的数量 内核将就绪的文件描述符放在传入的数组中 所以只用遍历依次处理即可 这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现的 减少了不必要的拷贝</p><h5 id="重复监听的处理方式"><a href="#重复监听的处理方式" class="headerlink" title="重复监听的处理方式"></a>重复监听的处理方式</h5><p>select: 将新的监听文件描述符集合拷贝传入内核中 继续以上步骤<br>poll: 将新的struct pollfd结构体数组拷贝传入内核中 继续以上步骤<br>epoll: 无需重新构建红黑树 直接沿用已存在的即可</p><h4 id="epoll比select-poll更高效的原因"><a href="#epoll比select-poll更高效的原因" class="headerlink" title="epoll比select/poll更高效的原因"></a>epoll比select/poll更高效的原因</h4><p>1.select采用fd标注位来存放 poll采用链表来进行文件描述符的存储 所以select会受到最大连接数的限制 poll就不会<br>2.select poll epoll虽然都会返回就绪的文件描述符数量 但select/poll并不会明确指出哪些fd处于就绪状态 epoll可以 系统调用返回后 调用select/poll的程序需要遍历监听的整个fd来找到谁处于就绪 epoll可以直接处理<br>3.select/poll都需要将有关文件描述符的数据结构拷贝进内核 最后再拷贝出来 而epoll创建的有关文件描述符的数据结构本身就存在内核态中 epoll使用mmap()减少复制开销<br>4.select/poll采用轮询方式来检查fd是否处于就绪态 epoll采用回调机制 随着fd的增加 select/poll的效率线性降低 epoll不会受到太大影响 除非活跃的socket太多<br>5.epoll的边缘触发机制效率高 系统不会充斥大量的不关心的就绪文件描述符<br>假如连接数少并且连接都十分活跃情况下 select/poll性能比epoll好 因为epoll的通知机制需要很多函数回调 </p><h3 id="四种同步I-O"><a href="#四种同步I-O" class="headerlink" title="四种同步I/O"></a>四种同步I/O</h3><p>同步I/O指内核向应用程序通知的是就绪事件 比如只通知有客户端连接 要求用户代码自行执行I/O操作</p><h4 id="同步阻塞I-O"><a href="#同步阻塞I-O" class="headerlink" title="同步阻塞I/O"></a>同步阻塞I/O</h4><p>用户进程在发起一个I/O操作以后必须等待I/O操作的完成 只有I/O操作完成之后 用户进程才能运行</p><h4 id="同步非阻塞I-O"><a href="#同步非阻塞I-O" class="headerlink" title="同步非阻塞I/O"></a>同步非阻塞I/O</h4><p>用户进程发起一个I/O操作后就返回做其他事情 每隔一段时间就去检查I/O事件是否就绪 没有就绪就可以做其他事 非阻塞I/O执行系统调用总是立即返回 不管时间是否已经发生 若时间没有发生 则返回-1<br>此时可以根据errno区分这两种情况 对于accept recv send 事件未发生时 errno被设置成eagain</p><h4 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h4><p>应用程序发起I/O请求时 给I/O安装一个信号处理函数 请求立即返回 操作系统底层则处于等待状态(等待数据就绪) 直到数据就绪收到SIGIO信号 然后通过信号通知主调程序 主调程序采取调用系统函数recvfrom()完成I/O操作</p><h4 id="多路复用I-O"><a href="#多路复用I-O" class="headerlink" title="多路复用I/O"></a>多路复用I/O</h4><p>也称之为事件驱动I/O linux用 select/poll函数实现I/O复用模型 select/poll好处为单个进程就可以同时处理多个网络连接的I/O<br>基本原理是select/poll会不断的轮询遍历所有socket 当某个socket有数据到达了就通知用户进程<br>多路复用中 通过select可以同时监听多个I/O请求的内核操作 只要有任意一个内核操作就绪 都可以通过select返回 再进行系统调用recvfrom()完成I/O操作<br>这个过程应用程序就可以同时监听多个I/O请求 比基于多线程阻塞I/O好很多 因为服务器只需要少数线程就可以进行大量客户端通信<br>但是和阻塞I/O不同的是这两个函数可以同时阻塞多个I/O操作 而且可以同时对多个读/写操作的I/O函数进行检测 知道有数据可读或可写时才真正调用I/O操作函数</p><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>异步I/O是指内核向应用程序通知的是完成事件 比如读取客户端的数据后才通知应用程序 由内核完成I/O操作<br>linux中 可以调用aio_read()告诉内核描述字缓冲区指针和缓冲区的大小 文件偏移及通知的方式 然后立即返回 当内核将数据拷贝到缓冲区后在通知应用程序<br>整个过程中应用程序不需要阻塞</p><h3 id="I-O模型举例"><a href="#I-O模型举例" class="headerlink" title="I/O模型举例"></a>I/O模型举例</h3><p>想吃牛肉面<br>同步阻塞: 在饭店点餐 然后在那坐着等着 还要不停的问做好了没有<br>同步非阻塞: 在饭店点完餐 就出去溜达了 不过溜达一会就回来问做好了没有<br>多路复用: 溜达的时候 饭店打电话说饭做好了来自取一下<br>异步(非阻塞): 饭店打电话说 面做好了我现在送到你所在的地方</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>在读取输入流或者写入输出流时 在读/写操作完成之前 线程会一直阻塞 传统的服务器端同步阻塞I/O </p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>基于事件驱动思想 采用reactor模式 是一种同步非阻塞的I/O模型 也是I/O多路复用的基础 成为解决高并发与大量连接的有效方式<br>I/O处理单元只负责监听文件描述符上是否可读/写 有的话由操作系统通知应用程序 应用程序再将流读取到缓冲区或写入系统<br>NIO适合连接数目多连接比较短的架构 例如聊天服务器 </p><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>基于事件驱动思想 采用Proactor模式 是一种异步I/O模型 进行I/O操作时 直接调用API的read和write 对于读操作 操作系统将数据读到缓冲区 兵通知应用程序 对于写操作 操作系统将write()传递的流写入并主动通知应用程序 节省了NIO中select轮询遍历通知队列的代价<br>AIO的实施需要充分调用OS参与 所以性能方面不同操作系统差异比较明显 因此实际中AIO应用不广泛<br>AIO适用于连接数目多且连接比较长的架构 例如相册服务器 AIO接受数据需要预先分配缓存 对连接数量大流量小的情况造成了内存浪费</p><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>要求主线程(I/O处理单元)只负责循环等待监听文件描述符是否有事件发生 有的话就通知工作线程(逻辑单元) 除此之外主线程不做任何其他实质性工作<br>读写数据 接受新的连接 处理客户请求 都在工作线程中完成<br>使用同步I/O模型(epoll_wait为例)实现Reactor模式的流程:<br>1.主线程往epoll内核事件表中注册socket上的读就绪事件<br>主线程调用epoll_wait等待socket上有数据可读<br>当socket上有数据可读时 epoll_wait通知主线程 主线程将socket可读事件插入请求队列<br>睡眠在请求队列上的某个工作线程被唤醒 它从socket读取数据 并处理客户请求 然后往epoll内核事件表中注册该socket上写就绪事件<br>主线程调用epoll_wait等待socket可写<br>当socket可写的时候 epoll_wait通知主线程 主线程将socket可写事件插入请求队列<br>睡眠在请求队列上的某个工作线程被唤醒 它往socket上写入服务器处理客户请求的结果</p><p><img src="/2020/02/07/Linux/Reactor.png" alt="Reactor"></p><p>工作线程从请求队列中取出事件后 将根据事件的类型来决定如何处理: 对于可读事件 执行读数据和处理请求的操作 对于可写事件 执行写数据的操作</p><h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><p>与Reactor模式不同 Proactor模式将所有I/O操作都交给主线程和内核来处理 工作线程只负责业务逻辑</p><h3 id="使用同步I-O方式模拟出Proactor模式"><a href="#使用同步I-O方式模拟出Proactor模式" class="headerlink" title="使用同步I/O方式模拟出Proactor模式"></a>使用同步I/O方式模拟出Proactor模式</h3><p>原理: 主线程执行数据读写操作 读写完成后 主线程向工作线程通知这一”完成事件” 从工作线程的角度看 它直接获得了数据读写的结果 只需要对读写结果进行逻辑处理<br>流程:<br>1.主线程往epoll内核事件表中注册socket上的读就绪事件<br>主线程调用epoll_wait等待socket上有数据可读<br>当socket上有数据可读时 epoll_wait通知主线程 主线程从socket循环读取数据 直到没有数据可读 然后将读取的数据封装成一个请求对象并插入请求队列<br>睡眠在请求队列上的某个工作线程被唤醒 它将获得请求对象并处理客户请求 然后往epoll内核事件表中注册该socket上写就绪事件<br>主线程调用epoll_wait等待socket可写<br>当socket可写的时候 epoll_wait通知主线程 主线程往socket上写入服务器处理客户请求的结果</p><p><img src="/2020/02/07/Linux/Proactor.png" alt="Proactor"></p><h2 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h2><p>并发模式中的同步异步是指 同步指程序按照代码序列的顺序执行 异步指程序的执行需要系统事件驱动 系统事件有中断 信号等<br>像服务器这种既要求实时性 有要求能同时处理多个客户请求 应该同时使用同步线程和异步线程 即采用半同步半异步模式实现<br>同步线程处理客户逻辑(相当于工作线程) 异步线程处理I/O事件(相当于主线程)  异步线程监听到客户请求后 将其封装成请求对象并插入请求队列中 请求队列将通知某个工作在同步模式的工作线程唉读取处理该请求对象</p><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>1.线程数不多 多客户端请求<br>若是proactor模式 主线程读取完数据才能加入请求队列 这时候可以换成普通reactor 每个线程去接收数据 进一步可以使用主从reactor<br>主从reactor中 主reactor是一个线程 负责监听连接请求 然后派发给accepor 传递给从reactor处理读写事件 处理请求的是其余N个不同线程 也就是从reactor 然后通过请求的密集度来调控reactor的个数<br>2.reactor模式中若一个iancheng被占用很久 服务器怎么解决接下来的连接请求<br>若没有线程数限制 目前项目设置是固定线程数 可以改成动态线程池<br>3.定时器是基于升序链表 换成时间轮呢<br>性能上提升有限 逻辑上更优 时间轮或者时间堆目的是时间上更加精准 将之前的自定义时间变成了当前最先超时的定时器与当前的时间差<br>现在的升序链表是自定义时间出发alarm新号 这样会造成遍历和触发的浪费 比如某次遍历发现没有任何超时要处理的定时器</p><h2 id="高级I-O函数"><a href="#高级I-O函数" class="headerlink" title="高级I/O函数"></a>高级I/O函数</h2><p>和网络编程相关的三类高级I/O函数 用于创建文件描述符的pipe dup函数 用于读写的readv/writev sendfile mmap/munmap splice tee函数 用于控制I/O行为的fcntl函数</p><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>pipe函数用于创建管道 来进行进程间通信 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure><p>参数是一个包含两个int整数的数组指针 成功返回0 并将一对打开的文件描述符值填入参数指向的数组 失败返回-1并设置errno<br>pipe函数创建的两个文件描述符fd[0] fd[1]分别构成管道两端 fd[1]写入的数据可以从fd[0]读出 fd[0]只能从管道读数据 fd[1]只能往管道写数据 若要实现双向传输 应该使用两个管道<br>默认情况下 这一对文件描述符都是阻塞的 若用read来读取一个空管道 read会被阻塞直到管道内有数据可读 若用write往一个满的管道写入数据 则write也会被阻塞 直到管道有空间可用<br>应用程序可以把fd[0] fd[1]设置为非阻塞的<br>管道内部传输的数据是字节流 管道容量大小默认65536字节 可以使用fcntl函数来修改管道容量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/socket.h&gt;</span></span><br><span class="line">int socketpair(int domain, int <span class="built_in">type</span>, int protocol, int fd[2]);</span><br></pre></td></tr></table></figure><p>socketpair创建双向管道 domain只能是本地的协议簇 意味着我们仅能在本地使用这个双向管道 socketpair创建的fd[0] fd[1]既可读又可写<br>成功返回0 失败返回-1 并设置errno</p><h3 id="dup-dup2函数"><a href="#dup-dup2函数" class="headerlink" title="dup/dup2函数"></a>dup/dup2函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int dup(int file_descriptor);</span><br><span class="line">int dup2(int file_descriptor_one,int file_descriptor_two);</span><br></pre></td></tr></table></figure><p>dup()创建一个新的文件描述符 和file_descriptor指向相同的文件管道网络连接 并且dup返回的文件描述符总是取系统当前可用的最小整数值<br>dup2将返回第一个不小于file_descriptor_two的整数值<br>两个函数调用失败返回-1 并设置errno</p><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv()/writev()"></a>readv()/writev()</h3><p>readv()将数据从文件描述符读到分散的内存块中 writev()将多块分散的内存数据一并写入文件描述符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/uio.h&gt;</span></span><br><span class="line">ssize_t readv(int fd, const struct iovec *vector, int count)</span><br><span class="line">ssize_t writev(int fd, const struct iovec *vector, int count)</span><br><span class="line">``</span><br><span class="line">fd参数是被操作的目标文件描述符 vector是类型是iovec的结构数据 count是vector的长度 </span><br><span class="line">两个函数成功屎返回读出写入的fd字节数 失败返回-1 并设置errno</span><br></pre></td></tr></table></figure><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile()"></a>sendfile()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/sendfile.h&gt;</span></span><br><span class="line">ssize_t sendfile(int out_fd,int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure><p>in_fd是待读出内容的文件描述符 out_fd是待写入内容的文件描述符 offset是指定读入文件流从哪个位置开始读 若为空就使用读入文件流的默认起始位置 count指定in_fd out_fd之间传输的字节数<br>sendfile成功返回传输的字节数 失败返回-1并设置errno in_fd必须指向真实的文件 out_fd必须是一个socket</p><h3 id="mmap-munmap"><a href="#mmap-munmap" class="headerlink" title="mmap()/munmap()"></a>mmap()/munmap()</h3><p>mmap()用于申请一段内存空间 这段内存作为进程通信的<code>共享内存</code><br>也可以将文件直接映射到其中 munmap()则释放由mmap创建的这段内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/mman.h&gt;</span></span><br><span class="line">void *mmap(void *start, size_t length, int port, int flags, int fd, off_t offset);</span><br><span class="line"></span><br><span class="line">int munmap(void *start, size_t length);</span><br></pre></td></tr></table></figure><p>start参数允许用户使用某个特定的地址作为这段内存的起始地址 被设置NULL就自动分配一个 length为这段内存的长度 port设置内存段的访问权限 有可读(PORT_READ) 可写(PORT_WRITE) 可执行(PORT_EXWC) 不可访问(PORT_NONE)<br>flags参数控制内存段内容被修改后程序的行为<br>fd参数是被映射文件对应的文件描述符 一般通过open()获得<br>offset参数设置文件从何处开始映射<br>mmap()成功返回指向目标内存区域的指针 失败返回MAP_FAILED((void*)-1) 并设置errno munmap()成功返回0 失败返回-1 并设置errno</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice()在两个文件描述符之间移动数据(零拷贝操作)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;fcntl.h&gt;</span></span><br><span class="line">ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags)</span><br></pre></td></tr></table></figure><p>fd_in参数是待输入数据的文件描述符 若fd_in是管道文件描述符 那么off_in必须设置为NULL<br>若fd_in是socket off_in表示从输入数据流的何处开始读取数据 off_in被设置成NULL时表示从输入数据流的当前偏移位置读入 若不是NULL 则指出具体偏移位置<br>fd_out/off_out与fd_in/off_in相同 用于输出数据流 len指定移动数据的长度 flags参数控制数据如何移动<br>使用splice()时 fd_in/fd_out必须至少有一个是管道文件描述符 调用成功返回移动数据的字节 可能返回0表示没有数据要移动 失败返回-1 并设置errno</p><h3 id="tee"><a href="#tee" class="headerlink" title="tee()"></a>tee()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;fcntl.h&gt;</span></span><br><span class="line">ssize_t <span class="built_in">tee</span>(int fd_in, int fd_out, size_t len, unsigned int flags);</span><br></pre></td></tr></table></figure><p>tee()在两个管到文件描述符之间复制数据 也是零拷贝操作不消耗数据 tee成功返回负值的字节数 可能返回0表示没有数据要移动 失败返回-1 并设置errno</p><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h3><p>提供了对文件描述符的各种操作控制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;fcntl.h&gt;</span></span><br><span class="line">int fcntl(int fd, int cmd, ...);</span><br></pre></td></tr></table></figure><p>fd是被操作的问价鸟舒服 cmd参数指定执行何种类型操作 根据操作类型不同 可能还需要第三个可选参数arg</p><p><img src="/2020/02/07/Linux/fcntl.png" alt="Fcntl1"></p><p>fcntl失败返回-1 并设置errno<br>在网络编程中fcntl通常用来将一个文件描述符设置为非阻塞的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int setnonblocking(int fd)&#123;</span><br><span class="line">    int old_option=fcntl(fd,F_GETFL);/*获取文件描述符旧状态*/</span><br><span class="line">    int new_option=old_option | O_ONBLOCK; /*设置非阻塞标志*/</span><br><span class="line">    fcntl(fd,F_SETFL, new_option);</span><br><span class="line">    <span class="built_in">return</span> old_option</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h2><p>rsyslogd既能接收用户进程输出的日志 又能接收内核日志 用户进程通过调用syslog函数生成系统日志 该函数将日志输出到一个UNIX本地域socket类型(AF_UNIX)的文件/dev/log中 rsyslogd则监听文件获取用户进程输出  内核日志由printk打印到内核的环状缓存中 环状缓存内容映射到/proc/kmsg文件中 rsyslogd通过读取该文件获得内核日志</p><p><img src="/2020/02/07/Linux/Linux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97.png" alt="Linux系统日志"></p><h3 id="syslog"><a href="#syslog" class="headerlink" title="syslog()"></a>syslog()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;syslog.h&gt;</span></span><br><span class="line">void syslog(int priority, const char *message,...);</span><br></pre></td></tr></table></figure><p>priority参数是设施值与日志级别的按位或 设施值的默认值为LOG_USER  日志级别有七种 分别是<br>LOG_EMERG 0 系统不可用 LOG_ALERT 1 报警 LOG_CRIT 2 非常严重 LOG_ERR 3 错误 LOG_WARNING 4 警告<br>LOG_NOTICE 5 通知 LOG_INFO 6 信息 LOG_DEBUG 7 调试<br>void openlog(const char *ident, int logopt, int facility)可以改变syslog默认输出方式<br>ident指定的字符串会被添加到日志消息的日期时间之后 通常被设置为程序名字 logopt对后续syslog调用的行为进行配置<br>facility用来修改syslog函数中的默认设施值<br>为了过滤日志留下重要的调试信息 需要简单的设置日志掩码 日志级别大于掩码的日志信息会被系统忽略<br>int setlogmask(int maskpri) maskpri指定日志掩码值 返回进程之前的掩码值<br>最后不要忘了closelog();</p><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>进程除了pid外 还有进程组的pgid</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Include&lt;unistd.h&gt;</span></span><br><span class="line">pid_t getpgid(pid_t pid);//成功返回pid所属的pgid 失败返回-1</span><br><span class="line">int setpgid(pid_t pid, pid_t pgid);//用于讲PID为pid的进程的PGID设置为pgid 若pid和pgid相同 则由pid指定的进程为进程组首领 pid=0表示当前进程的PGID为pgid 若pgid=0 则使用pid座位目标pGID 成功返回0 失败返回-1</span><br></pre></td></tr></table></figure><p>一个进程只能设置自己或者其子进程的PGID 并且子进程调用exec函数后 不能在父进程中对它设置PGID</p><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>一些有关联的进程会形成一个会话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">pid_t setsid();//创建一个会话session</span><br></pre></td></tr></table></figure><p>该函数不能由首领进程调用 否则产生错误<br>调用该函数不仅创建新会话 调用该函数的进程会成为会话的首领 此时该进程是新会话的唯一成员 新建一个进程组 它PGID就是调用进程的PID 调用进程成为该组的首领 调用进程甩开终端<br>成功返回新进程组的PGID 失败返回-1<br>Linux并未提供会话ID (SID)的概念 但Linux认为SID等于会话首领所在的进程组的PGID<br>pid_t getsid(pid_t pid)来读取SID</p><h4 id="PS命令查看进程-进程组-会话之间的关系"><a href="#PS命令查看进程-进程组-会话之间的关系" class="headerlink" title="PS命令查看进程 进程组 会话之间的关系"></a>PS命令查看进程 进程组 会话之间的关系</h4>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows配置FTP</title>
      <link href="/2020/02/05/Windows%E9%85%8D%E7%BD%AEFTP/"/>
      <url>/2020/02/05/Windows%E9%85%8D%E7%BD%AEFTP/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows配置FTP服务器"><a href="#Windows配置FTP服务器" class="headerlink" title="Windows配置FTP服务器"></a>Windows配置FTP服务器</h2><h3 id="Windows下通过IIS配置FTP注意事项"><a href="#Windows下通过IIS配置FTP注意事项" class="headerlink" title="Windows下通过IIS配置FTP注意事项"></a>Windows下通过IIS配置FTP注意事项</h3><p>一般用于解决本地能访问FTP目录而同一局域网下的其他设备无法访问的问题</p><span id="more"></span> <h4 id="防火墙规则"><a href="#防火墙规则" class="headerlink" title="防火墙规则"></a>防火墙规则</h4><p>防火墙的入站出站规则有关于FTP的必须全部启动<br>新建入站出站规则针对所有本地TCP端口</p><h4 id="IIS基本设置"><a href="#IIS基本设置" class="headerlink" title="IIS基本设置"></a>IIS基本设置</h4><p>在IIS下的网站主页中 点击右边侧栏的基本设置 连接为选择特定用户 测试设置能显示全部通过</p>]]></content>
      
      
      <categories>
          
          <category> FTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FTP </tag>
            
            <tag> Microsoft Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2020/01/07/MySQL/"/>
      <url>/2020/01/07/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="Windows启动MySQL"><a href="#Windows启动MySQL" class="headerlink" title="Windows启动MySQL"></a>Windows启动MySQL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一定要利用管理员权限打开cmd命令行</span></span><br><span class="line">net start mysql //启动mysql的服务</span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment">#输入正确密码后登陆成功</span></span><br></pre></td></tr></table></figure><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>遇到了各种各样的输入中文空白或者乱码 客户端字符集更改为gbk即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在Mysql目录下的my.ini中</span></span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=gbk</span><br></pre></td></tr></table></figure><span id="more"></span> <h3 id="MySQL语句"><a href="#MySQL语句" class="headerlink" title="MySQL语句"></a>MySQL语句</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database db_name character <span class="built_in">set</span> = utf8; <span class="comment">#db_name为数据库名字</span></span><br></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database db_name;</span><br></pre></td></tr></table></figure><h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use db_name;</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">范围(无符号)</th><th align="center">范围(有符号)</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">Tinyint</td><td align="center">1字节</td><td align="center">(-128,127)</td><td align="center">(0,255)</td><td align="center">小整数</td></tr><tr><td align="center">Smallint</td><td align="center">2字节</td><td align="center">(-32 768,32 767)</td><td align="center">(0,65 535)</td><td align="center">大整数</td></tr><tr><td align="center">Mediumint</td><td align="center">3字节</td><td align="center">(-8 388 608,8 388 607)</td><td align="center">(0,16 777 215)</td><td align="center">大整数</td></tr><tr><td align="center">int</td><td align="center">4字节</td><td align="center">(-2 147 483 648,2 147 483 647)</td><td align="center">(0,4 294 967 295)</td><td align="center">大整数</td></tr><tr><td align="center">Bigint</td><td align="center">8字节</td><td align="center">(-9 223 372 036 854 775 808，9 223 372 036 854 775 807)</td><td align="center">(0,18 446 744 073 709 551 615)</td><td align="center">极大整数</td></tr><tr><td align="center">Float</td><td align="center">4字节</td><td align="center">有效数字6-7位</td><td align="center"></td><td align="center">单精度浮点数</td></tr><tr><td align="center">Double</td><td align="center">8字节</td><td align="center">有效数字15-16位</td><td align="center"></td><td align="center">双精度浮点数</td></tr></tbody></table><h5 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h5><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">范围</th><th align="center">格式</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">Date</td><td align="center">3字节</td><td align="center">1000-01-01/9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期</td></tr><tr><td align="center">Time</td><td align="center">3字节</td><td align="center"></td><td align="center">HH:MM:SS</td><td align="center">时间或持续时间</td></tr><tr><td align="center">Year</td><td align="center">1字节</td><td align="center">1901/2155</td><td align="center">YYYY</td><td align="center">年份</td></tr><tr><td align="center">Datatime</td><td align="center">8字节</td><td align="center">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">具体时间</td></tr><tr><td align="center">TimeStamp</td><td align="center">4字节</td><td align="center">1970-01-01 00:00:00/2038-01-19 03:14:07</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">时间戳</td></tr><tr><td align="center">插入时间数据必须加双引号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><table><thead><tr><th align="center">类型</th><th align="center">字节</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">Char</td><td align="center">0-255字节</td><td align="center">定长字符串</td></tr><tr><td align="center">Varchar</td><td align="center">0-65535字节</td><td align="center">变长字符串</td></tr><tr><td align="center">Blob</td><td align="center">0-65535字节</td><td align="center">二进制形式的长文本数据</td></tr><tr><td align="center">Text</td><td align="center">0-65535字节</td><td align="center">长文本数据</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Mysql5.0以上 汉字字节数与编码有关 UTF-8中一个汉字3个字节 GBK中一个汉字2个字节</span></span><br></pre></td></tr></table></figure><h4 id="创建-删除模式"><a href="#创建-删除模式" class="headerlink" title="创建/删除模式"></a>创建/删除模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create schema &lt;模式名&gt; authorization &lt;用户名&gt;</span><br><span class="line">drop schema &lt;模式名&gt; &lt;cascade/restrict&gt;</span><br><span class="line"><span class="comment">#cascade级联 删除模式的同时把该模式下所有的数据库对象全部删除</span></span><br><span class="line"><span class="comment">#restrict限制 如果该模式下存在已定义的数据库对象(表/视图) 就拒绝删除语句的执行</span></span><br></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table Student(<span class="comment">#学生信息表</span></span><br><span class="line">    Sno varchar(9) primary key,<span class="comment">#Sno为主键</span></span><br><span class="line">    Sname varchar(20) unique,<span class="comment">#唯一</span></span><br><span class="line">    Ssex varchar(2),</span><br><span class="line">    Sage smallint,</span><br><span class="line">    Sdept varchar(20)</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">学号Sno</th><th align="center">姓名Sname</th><th align="center">性别Ssex</th><th align="center">年龄Sage</th><th align="center">专业Sdept</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#外键示范</span></span><br><span class="line">create table Course(</span><br><span class="line">    Cno varchar(4) primary key,<span class="comment">#Cno为主键</span></span><br><span class="line">    Cname varchar(40) not null,</span><br><span class="line">    Cpno varchar(4),<span class="comment">#Cpno为外键 参照表是Course下的Cno</span></span><br><span class="line">    Ccredit smallint,</span><br><span class="line">    foreign key(Cpno) references Course(Cno)<span class="comment">#参照表可以是自己表里的字段</span></span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table Student</span><br><span class="line">add entrance <span class="built_in">date</span> not null;<span class="comment">#为Student表添加一列entrance 类型为date 约束为not null</span></span><br><span class="line"><span class="comment">#增加新的一列的数据都为空</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table Student</span><br><span class="line">drop ent;<span class="comment">#删除Student表中名为ent的一列</span></span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table Student;</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>表的数据量较大时 查询操作比较耗时 建立索引加快查询速度 能快速定位到需要查询的内容</p><h5 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index Stusno on Student(Sno) asc/desc);<span class="comment">#Stusno为索引名 asc升序desc降序</span></span><br></pre></td></tr></table></figure><h5 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index Stusno rename to Ssno;<span class="comment">#更改旧索引名Stusno为Ssno</span></span><br></pre></td></tr></table></figure><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index Ssno;<span class="comment">#删除名为Ssno的索引</span></span><br></pre></td></tr></table></figure><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into Student (字段名,字段名) values(值,值);</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询全体记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from &lt;表名&gt;</span><br></pre></td></tr></table></figure><p>查询部分字段记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &lt;字段名&gt;,&lt;字段名&gt; from &lt;表名&gt;</span><br></pre></td></tr></table></figure><p>查询表内某一字段存在大量重复元素时 使用distinct</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct &lt;字段名&gt; from &lt;表名&gt;</span><br></pre></td></tr></table></figure><h5 id="where"><a href="#where" class="headerlink" title="where"></a>where</h5><table><thead><tr><th align="center">学号Sno</th><th align="center">姓名Sname</th><th align="center">性别Ssex</th><th align="center">年龄Sage</th><th align="center">专业Sdept</th></tr></thead><tbody><tr><td align="center">201215121</td><td align="center">张三</td><td align="center">男</td><td align="center">20</td><td align="center">CS</td></tr><tr><td align="center">201215122</td><td align="center">李四</td><td align="center">女</td><td align="center">19</td><td align="center">IS</td></tr><tr><td align="center">201215123</td><td align="center">王五</td><td align="center">女</td><td align="center">18</td><td align="center">MA</td></tr><tr><td align="center">201215124</td><td align="center">赵六</td><td align="center">男</td><td align="center">22</td><td align="center">IE</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sage&lt;20;</span><br><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sdept=<span class="string">&quot;CS&quot;</span>;</span><br><span class="line">select Sno,Cno from SC <span class="built_in">where</span> Grade is null;<span class="comment">#is不能换=</span></span><br><span class="line"></span><br><span class="line">select Sno,Sname,Sage from student <span class="built_in">where</span> Sage between 19 and 20;<span class="comment">#Sage在19-20之间(包括19和20)</span></span><br><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sage not between 19 and 20;<span class="comment">#Sage不在19-20之间</span></span><br><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sdept <span class="keyword">in</span> (<span class="string">&quot;CS&quot;</span>,<span class="string">&quot;IS&quot;</span>);</span><br><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sdept not <span class="keyword">in</span> (<span class="string">&quot;CS&quot;</span>,<span class="string">&quot;IS&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><p>字符匹配 使用like和%<br>a%  以a为开头的字符串<br>a%b 以a为开头b为结尾的字符串 长度不限<br>a_b 以a为开头b为结尾的长度为3的字符串  <code>#字符串为汉字时要注意编码格式 注意一个汉字占几位</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sname like <span class="string">&quot;刘%&quot;</span>;<span class="comment">#查询Sname姓刘的所有人</span></span><br><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sname like <span class="string">&quot;刘_&quot;</span>;<span class="comment">#查询Sname姓刘的两个字名字的人</span></span><br><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sname like <span class="string">&quot;_阳%&quot;</span>;<span class="comment">#查询第二个字为阳的名字</span></span><br><span class="line">select Sno,Sname from student <span class="built_in">where</span> Sname not like <span class="string">&quot;刘%&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据库系统概论第5版王珊编著中提到Order By语句默认从小到大升序asc排列</span></span><br><span class="line">select * from sc order by Grade desc;<span class="comment">#查询结果按成绩从大到小 降序排列</span></span><br><span class="line">select * from sc order by Grade asc;<span class="comment">#查询结果按成绩从小到大 升序排列</span></span><br><span class="line">select * from student order by Sdept,Sage desc; <span class="comment">#同一个Sdept中Sage从大到小排列</span></span><br><span class="line"><span class="comment">#空值被认为是最大的</span></span><br></pre></td></tr></table></figure><h5 id="聚焦函数"><a href="#聚焦函数" class="headerlink" title="聚焦函数"></a>聚焦函数</h5><p>函数不能用于Where语句 只能用于Select语句 或者 Group By中的Having语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Count()<span class="comment">#统计个数 空值也计算进去</span></span><br><span class="line">Sum()<span class="comment">#计算一列数的总和  要求存储的数据必须是数值型数据 不能是字符型数据</span></span><br><span class="line">Avg()<span class="comment">#计算一列数的平均值  要求存储的数据必须是数值型数据 不能是字符型数据</span></span><br><span class="line">Max()<span class="comment">#一列数值的最大值</span></span><br><span class="line">Min()<span class="comment">#一列数值的最小值</span></span><br></pre></td></tr></table></figure><p>Distinct 查询中筛除掉指定列的重复值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select Count(*) from student;<span class="comment">#查询学生总人数</span></span><br><span class="line">select Count(Distinct Sno) from SC;<span class="comment">#查询了选修的人数</span></span><br><span class="line">select Avg(Grade) from SC <span class="built_in">where</span> Sno=201215121;<span class="comment">#查询学号201215121的平均成绩</span></span><br><span class="line">select Max(Grade) from SC <span class="built_in">where</span> Cno=2;<span class="comment">#查询课程号为2的最高成绩</span></span><br><span class="line">select Sum(Ccredit) from SC,Course</span><br><span class="line"><span class="built_in">where</span> Sno=201215121 and SC.Cno=Course.Cno;<span class="comment">#查询Sno为201215121选课的总学分数</span></span><br></pre></td></tr></table></figure><h5 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h5><p>分组后使用Having指定筛选条件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select Cno,Count(Sno) from SC Group By Cno;<span class="comment">#查询课程号和选课的人数 按照Cno的值分组 有相同Cno的值的在一个组 然后用Count函数对每个组的总人数进行计算</span></span><br><span class="line">select Sno from SC Group By Sno Having Count(*)&gt;=3;<span class="comment">#Group By按照Sno分组 Having筛选 元组个数&gt;=3 才会被查询到</span></span><br></pre></td></tr></table></figure><p>Where Having 区别 Where语句作用于基本表与视图 从中选择满足条件的组 Having作用于组 从中满足条件的组</p><h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><p>一次查询涉及到多个数据表</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2019/11/11/%E5%9B%BE/"/>
      <url>/2019/11/11/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>G=(V,E) V顶点 E边</p><h3 id="图的概念及术语"><a href="#图的概念及术语" class="headerlink" title="图的概念及术语"></a>图的概念及术语</h3><p>1.无向图<br>2.有向图<br>3.简单图:无重复边 没有结点到自身的边<br>4.多重图:有重复边 有结点到自身的边<br>5.完全图<br>无向完全图:任意两个顶点都存在边 n个顶点的无向完全图有$\frac{n(n-1)}{2}$个边<br>有向完全图:任意两个顶点间都存在方向相反的边 n个顶点的有向完全图有n(n-1)个边<br>6.子图<br>图本身就是自己的子图<br>生成子图:子图中包含了原图的所有顶点<br>7.连通 强连通<br>无向图对应连通图 有向图对应强连通图</p><span id="more"></span> <table><thead><tr><th align="center">无向图</th><th align="center">连通图</th><th align="center">有向图</th><th align="center">强连通图</th></tr></thead><tbody><tr><td align="center">顶点u-w间有路径存在 则u w连通</td><td align="center">任意两个结点都连通的图叫连通图</td><td align="center">u&gt;w w&gt;u都有路径存在 则u w强连通</td><td align="center">任意两个结点都强连通的图叫强连通图</td></tr><tr><td align="center">连通图:n个顶点最少n-1个边</td><td align="center">-</td><td align="center">强连通图:n个顶点最少n个边</td><td align="center">-</td></tr><tr><td align="center">连通分量=极大连通子图:</td><td align="center">包含了所有边的连通子图</td><td align="center">强连通分量=极大强连通子图</td><td align="center">包含了所有边的强连通子图</td></tr></tbody></table><p>8.极小连通子图:边数最少的连通子图<br>9.生成树:连通图中包含了全部结点的一个极小连通子图(不唯一) n个结点n-1条边<br>生成森林:非连通图所有连通分量的生成树组成生成森林(不唯一)<br>10.度<br>n个结点e个边的无向图中度的总数为2e<br>n个结点e个边的有向图中入度=出度=e<br>11.网(带权图):对边赋予权值 就成了网<br>12.稀疏图/稠密图:当|E|&lt;|V|log|E|时 该图为稀疏图 反之为稠密图</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>一维数组存结点 二维数组存边 所以空间复杂度$O(n^2)$</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define Maxsize 100</span></span><br><span class="line">typedef char VertexType;//结点类型</span><br><span class="line">typedef int EdgeType;//边类型</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    VertexType Vex[Maxsize];//一维数组</span><br><span class="line">    EdgeType Edge[Maxsize][Maxsize];//二维数组</span><br><span class="line">    int vexnum,edgenum;//结点个数，边个数</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p>性质：<br>适合稠密图<br>有向图邻接矩阵中一行非零的个数为该点的入度 一列非零的个数为该点的出度<br>无向图的邻接矩阵为实对称矩阵 $A=A^T$ 一行/列非零个数为该点的度<br>邻接矩阵$A$  $A^n元素A^n[i][j]=X 其中X=i-j$路径长度为n的路径的个数<br>针对稀疏图 邻接矩阵内存放了很多0/无意义的数据 造成了空间上的浪费 因此针对稀疏图我们采用邻接表的方式进行存储</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>为每个结点建立一个与之相连的单链表存放与结点相连的边<br>顶点表为顺序存储 存顶点的数据 存边表的头指针<br>边表为链式存储 存放与该结点相连的所有边</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define Maxsize </span></span><br><span class="line">typedef struct ArcNode&#123;//边表</span><br><span class="line">    int adjvex;//边表数据域 存放相连结点的标号</span><br><span class="line">    struct ArcNode *next;//指向下一个边</span><br><span class="line">&#125;ArcNode;</span><br><span class="line">typedef struct VNode&#123;//顶点表</span><br><span class="line">    VertexType data;//顶点元素</span><br><span class="line">    ArcNode *first;//指向第一个边</span><br><span class="line">&#125;VNode，AdjList[Maxsize];</span><br><span class="line">typedef struct&#123;//邻接表</span><br><span class="line">    AdjList vertices;//存整个图的数据</span><br><span class="line">    int vexnum,arcnum;//顶点个数，边个数</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><p>性质:<br>适合稀疏图<br>因为对结点相连的边选择顺序不同 所以邻接表不唯一<br>有向图邻接表存储空间O(|V|+|E|) 结点对应边表的长度为该结点的出度 入度需要遍历邻接表计算<br>无向图邻接表存储空间O(|V|+2|E|) 结点对应边表的长度为该结点的度</p><h4 id="邻接矩阵与邻接表比较"><a href="#邻接矩阵与邻接表比较" class="headerlink" title="邻接矩阵与邻接表比较"></a>邻接矩阵与邻接表比较</h4><table><thead><tr><th align="center">邻接矩阵</th><th align="center">vs</th><th align="center">邻接表</th></tr></thead><tbody><tr><td align="center">适合稠密图</td><td align="center">适用性</td><td align="center">适用稀疏图</td></tr><tr><td align="center">效率高</td><td align="center">判断两个顶点间是否存在边</td><td align="center">效率低</td></tr><tr><td align="center">效率低</td><td align="center">找出某顶点相邻的边</td><td align="center">效率高</td></tr></tbody></table><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>十字链表是<code>有向图</code>的一种链式存储结构</p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p>邻接多重表是<code>无向图</code>的一种链式存储结构</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h4><p>通过一个队列和一个数组来实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">bool visited[Maxsize];//辅助数组visited来标记对应编号的顶点是否被访问过</span><br><span class="line">void BFSTraverse(Graph G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++) visited[i]=0;//初始化辅助数组全部置0;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++)&#123;//不连通的图的顶点也可以被循环到</span><br><span class="line">        <span class="keyword">if</span>(!visited[0]) BFS(G,i);//若该顶点未被访问过 对该顶点执行BFS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//FirstNeighbor(G,x) 求图G中顶点x的第一个邻接点 若存在则返回顶点编号 不存在就返回-1</span><br><span class="line">//NextNeighbor(G,x,y) y是x的一个邻接点 返回除了y之外的下一个邻接点 不存在就返回-1</span><br><span class="line"></span><br><span class="line">void BFS(Graph G,int v)&#123;//v为顶点在visited数组中的编号</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=1;//v被标记访问过</span><br><span class="line">    EnQueue(Q,v);//v入队</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;//队列不为空时执行循环</span><br><span class="line">        DeQueue(Q,v);</span><br><span class="line">        <span class="keyword">for</span>(int w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,x,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;//若该邻接点未被访问过</span><br><span class="line">                visit[w];</span><br><span class="line">                visited[w]=1;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS算法性能分析: 空间复杂度$O(|V|)$ 时间复杂度 G为邻接矩阵 $O(|V|^2)$ G为邻接表 $O(|V|+|E|)$<br>可以利用BFS解决无权图的单源最短路径问题<br>可以利用BFS得到广度优先生成树 邻接矩阵的广度优先生成树唯一 邻接表的广度优先生成树不唯一(邻接表的边表序列不唯一)</p><h4 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h4><p>通过递归或者栈实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool visited[Maxsize];//标记数组</span><br><span class="line">void DFSTraverse(Graph G)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++) visited[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) DFS(G,i);//结点未被访问过 进行DFS；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(Graph G,int v)&#123;</span><br><span class="line">    visit[v];</span><br><span class="line">    visited[v]=1;</span><br><span class="line">    <span class="keyword">for</span>(int w=FisrtNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) DFS(G,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS算法性能分析: 空间复杂度$O(|V|)$ 时间复杂度 G为邻接矩阵 $O(|V|^2)$ G为邻接表 $O(|V|+|E|)$<br>深度优先遍历得出的序列得到深度优先生成树/森林<br>邻接矩阵的深度优先生成树唯一 邻接表的深度优先生成树不唯一(邻接表的边表序列不唯一)</p><h4 id="遍历和连通性"><a href="#遍历和连通性" class="headerlink" title="遍历和连通性"></a>遍历和连通性</h4><p>在无向图中 BFS()与DFS()的调用次数为连通分量的个数</p><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>最小生成树就是极小连通子图 包含了所有顶点和最少的边 权值唯一且最小 |E|=|V|-1<br>性质:带权无向连通图才有最小生成树 最小生成树不一定唯一 当所有的边权值都不一样时才有唯一的最小生成树<br>图有n个顶点n-1个边时 最小生成树就是它自己</p><p>从策略上来说，Prim算法是直接查找，多次寻找邻边的权重最小值，而Kruskal是需要先对权重排序后查找的<br>所以说，Kruskal在算法效率上是比Prim快的，因为Kruskal只需一次对权重的排序就能找到最小生成树，而Prim算法需要多次对邻边排序才能找到</p><h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5><p>适用于稠密图<br>首先以一个结点作为最小生成树的初始结点，然后以迭代的方式找出最小生成树中各结点权重最小的边，并加到最小生成树中。（加入之后如果产生回路了就要跳过这条边，选择下一个结点）当所有的结点都加入到最小生成树中后，就找出了这个连通图的最小生成树</p><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p>Kruskal算法在找最小生成树结点之前，需要对权重从小到大进行排序。将排序好的权重边依次加入到最小生成树中（如果加入时产生回路就跳过这条边，加入下一条边），当所有的结点都加入到最小生成树中后，就找到了这个连通图的最小生成树</p><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><h5 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h5><h4 id="拓扑排序-AOV网"><a href="#拓扑排序-AOV网" class="headerlink" title="拓扑排序(AOV网)"></a>拓扑排序(AOV网)</h4><h4 id="关键路径-AOE网"><a href="#关键路径-AOE网" class="headerlink" title="关键路径(AOE网)"></a>关键路径(AOE网)</h4>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2019/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树定义与性质"><a href="#二叉树定义与性质" class="headerlink" title="二叉树定义与性质"></a>二叉树定义与性质</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>每个结点最多有两个子树</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>1.非空二叉树上叶子结点数=度为2的结点数+1(树的结点数=所有结点度数+1)$n_0=n_2+1$<br>2.非空二叉树第k层最多有$2^{k-1}$个结点<br>3.高度为h的二叉树最多有$2^h-1$个结点<br>4.n个结点的完全二叉树的高度为$\lceil$$log_2(n+1)$$\rceil$ 或者$\lfloor$$log_2n$$\rfloor+1$<br>5.n个结点的完全二叉树 叶结点的个数$n_0$为$n_0=n-\lfloor$$n/2$$\rfloor$</p><h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><p>1.满二叉树<br>2.完全二叉树:每个结点编号都与相同深度的满二叉树的结点一一对应<br>3.二叉排序树:左子树的结点关键字均小于根结点 右字数的结点关键字均大于根结点<br>4.平衡二叉树:树上任一结点的左子树和右子树的深度之差不超过1</p><span id="more"></span> <h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h4><p>满二叉树和完全二叉树适合顺序存储 按满二叉树的编号分配位置 不存在的空结点置0</p><h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct BiTNode *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>先序遍历+中序遍历可确定二叉树(先序遍历第一个为根结点 根结点将中序遍历序列划分为左右序列再以此类推)<br>后序遍历+中序遍历可确定二叉树(后序遍历最后一个为根结点 将中序遍历序列左右划分))<br>层次遍历+中序遍历可确定二叉树<br>以此二叉树为例进行遍历 </p><div style="width: 220px;height: 220px;">    ![二叉树遍历例子](binary-tree.png)</div><h4 id="先序遍历-根左右"><a href="#先序遍历-根左右" class="headerlink" title="先序遍历(根左右)"></a>先序遍历(根左右)</h4><p>若二叉树非空 </p><li>1.访问根结点</li><li>2.先序遍历左子树</li><li>3.先序遍历右子树</li>先序遍历递归算法: 时间复杂度 $O(n)$<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(BiTree T)&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>序列为 `1 2 4 6 3 5`<h4 id="中序遍历-左根右"><a href="#中序遍历-左根右" class="headerlink" title="中序遍历(左根右)"></a>中序遍历(左根右)</h4><p>若二叉树非空 </p><li>1.中序遍历左子树</li><li>2.访问根结点</li><li>3.中序遍历右子树</li>中序遍历递归算法: 时间复杂度 $O(n)$<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void InOrder(BiTree T)&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>序列为 `2 6 4 1 3 5`<p>中序遍历非递归算法效率高于递归算法 且需要栈来实现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void InOrder2(BiTree T)&#123;</span><br><span class="line">    InitStack(S);BiTree p;//p始终指向栈顶元素</span><br><span class="line">    <span class="keyword">while</span>(p||IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S,p);p=p-&gt;lchild;//根结点进栈 遍历左子树</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S,p)；visit(p);</span><br><span class="line">            p=p-&gt;rchild;//结点出栈 并被访问 然后遍历右子树 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历-左右根"><a href="#后序遍历-左右根" class="headerlink" title="后序遍历(左右根)"></a>后序遍历(左右根)</h4><p>若二叉树非空 </p><li>1.后序遍历左子树</li><li>2.后序遍历右子树</li><li>3.访问根结点</li>后序遍历递归算法: 时间复杂度 $O(n)$<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void PostOrder(BiTree T)&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>序列为 `6 4 2 5 3 1`<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>按照每一层从左到右的顺序遍历整棵树 借助一个队列实现层次遍历<br>层次遍历算法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void LevelOrder(BiTree T)&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);//根结点入队</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;//队列非空时循环</span><br><span class="line">        DeQueue(Q,p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=null) EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=null) EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列为 <code>1 2 3 4 5 6</code> </p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>tag为0：child指向孩子结点 tag为1:child指向前驱/后继结点</p><table><thead><tr><th align="center">ltag</th><th align="center">lchild</th><th align="center">data</th><th align="center">rchild</th><th align="center">rtag</th></tr></thead><tbody><tr><td align="center">左标识位</td><td align="center">左孩子/前驱结点</td><td align="center">元素位</td><td align="center">右孩子/后继结点</td><td align="center">右标识位</td></tr><tr><td align="center">线索二叉树结构体代码：</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ThreadNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct ThreadNode *lchild,*rchild;</span><br><span class="line">    int ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure><p>中序线索二叉树递归算法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">递归函数InThread：</span><br><span class="line">void InThread(ThreadTree &amp;p,ThreadTree &amp;pre)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=null)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==null)&#123;</span><br><span class="line">            p-&gt;lchild==null;p-&gt;ltag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((pre!=null)&amp;&amp;(pre-&gt;rchild==null))&#123;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">            pre-&gt;rtag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        InThread(p-&gt;rchild,pre)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">主函数CreateInThread</span><br><span class="line">void CreateInThread(ThreadTree T)&#123;</span><br><span class="line">    ThreadTree pre=null;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        InThread(T,pre);</span><br><span class="line">        pre-&gt;rchild=null;</span><br><span class="line">        pre-&gt;rtag=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h3><h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h4><h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h4><h4 id="哈弗曼树-哈弗曼编码"><a href="#哈弗曼树-哈弗曼编码" class="headerlink" title="哈弗曼树/哈弗曼编码"></a>哈弗曼树/哈弗曼编码</h4><h3 id="树-森林"><a href="#树-森林" class="headerlink" title="树 森林"></a>树 森林</h3><h4 id="树存储结构"><a href="#树存储结构" class="headerlink" title="树存储结构"></a>树存储结构</h4><p>1.双亲表示法:采用一组连续空间来存储结点 每个结点都有一个伪指针来表示其双亲结点的下标 根结点下标为0伪指针为-1<br>寻找双亲结点效率高 寻找孩子结点效率低</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define Maxsize</span></span><br><span class="line">typedef struct&#123;//树结点定义</span><br><span class="line">    ElemType data;</span><br><span class="line">    int parent;//双亲下标</span><br><span class="line">&#125;PTNode;</span><br><span class="line">typedef struct&#123;//树类型定义</span><br><span class="line">    PTNode nodes[Maxsize];</span><br><span class="line">    int n;//结点数</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><p>2.孩子表示法:将每个结点的孩子结点都用单链表连接起来 n个结点有n个孩子链表 按层次遍历给结点下标标号 根结点为0<br>寻找孩子结点效率高 寻找双亲结点效率低</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define Maxsize</span></span><br><span class="line">typedef struct&#123;//单链表中孩子结点</span><br><span class="line">    int child;//孩子结点下标</span><br><span class="line">    struct CNode *next;//下一个孩子结点的指针</span><br><span class="line">&#125;CNode;</span><br><span class="line">typedef struct&#123;//每一个结点</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct CNode *child;//第一个孩子结点的指针</span><br><span class="line">&#125;CNode;</span><br><span class="line">typedef struct&#123;//树类型定义</span><br><span class="line">    PTNode nodes[Maxsize];</span><br><span class="line">    int n;//结点数</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><p>3.孩子兄弟表示法(二叉树表示法):左指针指向结点的第一个孩子结点 右指针指向结点的下一个兄弟结点(左孩子右兄弟)<br>可以方便的实现树转化为二叉树的操作 易于查找孩子结点 缺点:查找双亲结点很麻烦 需为每个结点添加一个parent域指向父结点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CSNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct CSNode *firstchild,*nextsibling;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h4 id="树-森林与二叉树转换"><a href="#树-森林与二叉树转换" class="headerlink" title="树 森林与二叉树转换"></a>树 森林与二叉树转换</h4><p>1.树与二叉树转换(左孩子右兄弟方法):结点的左指针指向第一个孩子结点 右指针指向它在树中相邻的兄弟结点<br>2.森林与二叉树转换:将森林中每一个树按照左孩子右兄弟转化为多个二叉树 然后将这几个二叉树的根结点都当做相邻的兄弟结点 然后连接起来构成一个大的二叉树<br>卐:二叉树转化为树或森林都是唯一的</p><h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><p>个人见解 转化为对应的二叉树再进行遍历写出序列</p><table><thead><tr><th align="center">树</th><th align="center">森林</th><th align="center">二叉树</th></tr></thead><tbody><tr><td align="center">先根遍历</td><td align="center">先序遍历</td><td align="center">先序遍历</td></tr><tr><td align="center">后根遍历</td><td align="center">中序遍历</td><td align="center">中序遍历</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2019/08/07/%E9%98%9F%E5%88%97/"/>
      <url>/2019/08/07/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>判断条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q.front=Q.rear=0//队空</span><br><span class="line">队满判断不能简单的定义为Q.rear==Maxsize 执行多次的入队出队操作后 会出现Q.front=Q.rear-1;Q.rear=Maxsize </span><br><span class="line">即为队列中只有队尾有一个元素 出现<span class="string">&quot;上溢出&quot;</span> 但这个溢出并不是真正的溢出 队列中还有空位置所以是<span class="string">&quot;假溢出&quot;</span></span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>判断条件：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=<span class="number">0</span><span class="comment">//队列初始化</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Maxsize<span class="comment">//队列满</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear<span class="comment">//队列空</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear+<span class="number">1</span>)%Maxsize<span class="comment">//入队 队尾指针向后移一位</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+<span class="number">1</span>)%Maxsize<span class="comment">//出队 对首指针向后移一位</span></span><br><span class="line">length=(<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>rear-<span class="module-access"><span class="module"><span class="identifier">Q</span>.</span></span>front+Maxsize)%Maxsize</span><br></pre></td></tr></table></figure><p>牺牲最后一个存储单元 防止队列满时front与rear指向同一个元素导致无法判断是队列空还是满<br>所以队列满的条件为 rear就在front后面的存储单元<br>能够存储的元素数量为Maxsize-1</p><span id="more"></span> <p>具体代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define Maxsize 6</span></span><br><span class="line">typedef char ElemType; </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">ElemType *data;//队列元素 </span><br><span class="line">int front,rear;//头指针与尾指针 </span><br><span class="line">&#125;SqQueue;</span><br><span class="line">bool InitQueue(SqQueue &amp;Q)//初始化空队列Q </span><br><span class="line">&#123;</span><br><span class="line">Q.data = new ElemType[Maxsize];</span><br><span class="line"><span class="keyword">if</span>(!Q.data) <span class="built_in">return</span> 0;</span><br><span class="line">Q.front=Q.rear=0;//头指针等于尾指针是队列为空的标志 </span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool EnQueue(SqQueue &amp;Q,ElemType e)//入队 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+1)%Maxsize==Q.front) <span class="built_in">return</span> 0;//队满 </span><br><span class="line">Q.data[Q.rear]=e;</span><br><span class="line">Q.rear=(Q.rear+1)%Maxsize;//队尾指针+1取模=向后移位 </span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool DeQueue(SqQueue &amp;Q,ElemType &amp;e)//出队 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="built_in">return</span> 0;//队空 </span><br><span class="line">e=Q.data[Q.front];</span><br><span class="line">Q.front=(Q.front+1)%Maxsize;//队首指针+1取模=向后移位 </span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool QueueLength(SqQueue Q)//循环队列长度 </span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;(Q.rear-Q.front+Maxsize)%Maxsize;</span><br><span class="line">&#125;</span><br><span class="line">void ShowQueue(SqQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">int i=Q.front;</span><br><span class="line"><span class="keyword">while</span>(i!=Q.rear)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">Q.data[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">i=(i+1)%Maxsize;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">SqQueue Q</span>;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">if</span>(!InitQueue(Q)) cout&lt;&lt;<span class="string">&quot;循环队列初始化失败&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要入队的元素个数 个数不能大于5否则入队失败&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;=j;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要入队的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">EnQueue(Q,e); </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;元素入队成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入对应功能的数字： 1.入队 2.出队 3.求循环队列长度 4.显示队列元素 &quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;m;</span></span><br><span class="line"><span class="string">switch(m)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">case 1:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入入队的元素&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;e;</span><br><span class="line">EnQueue(Q,e);</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 2:</span><br><span class="line">&#123;</span><br><span class="line">DeQueue(Q,e);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;删除成功&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 3:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;队列长度为&quot;;</span></span><br><span class="line"><span class="string">QueueLength(Q);</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl</span>;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 4:</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;显示队列的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">ShowQueue(Q);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;是否继续执行操作 1.继续 2.退出&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">&#125;<span class="keyword">while</span>(n==1);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>顾名思义 链式队列就是同时带有头指针和尾指针的单链表<br>头指针指向队头结点 尾指针指向队尾结点 即单链表最后一个结点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef char ElemType; </span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;//next指向struct Lnode结构体变量 </span><br><span class="line">&#125;LNode,*LinkNode;//结构体类型LNode 别名为*LinkNode </span><br><span class="line">typedef struct&#123;</span><br><span class="line">LNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line">bool InitQueue(LinkQueue &amp;Q)&#123;//初始化 </span><br><span class="line">Q.front=Q.rear=new LNode;  </span><br><span class="line">    Q.front-&gt;next=NULL;  </span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool EnQueue(LinkQueue &amp;Q,ElemType e)//入列 </span><br><span class="line">&#123;</span><br><span class="line">LNode *p=new LNode;</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">Q.rear-&gt;next=p;</span><br><span class="line">Q.rear=p;</span><br><span class="line">&#125;</span><br><span class="line">bool DeQueue(LinkQueue &amp;Q,ElemType &amp;e)//出队 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="built_in">return</span> 0;</span><br><span class="line">LNode *p=new LNode;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front;</span><br><span class="line">delete p;</span><br><span class="line"><span class="built_in">return</span> 1; </span><br><span class="line">&#125;</span><br><span class="line">int DestroyQueue(LinkQueue &amp;Q,ElemType &amp;e)//销毁链队列 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!InitQueue(Q))</span><br><span class="line">&#123;  </span><br><span class="line">DeQueue(Q,e);</span><br><span class="line">&#125;</span><br><span class="line">delete Q.front;  </span><br><span class="line">    Q.front=Q.rear=NULL;</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">void DispQueue(LinkQueue Q)//显示链队列元素 </span><br><span class="line">&#123;</span><br><span class="line">LNode *p=new LNode;</span><br><span class="line">LNode *q=new LNode;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==NULL) cout&lt;&lt;<span class="string">&quot;队列为空&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=Q.front-&gt;next;</span></span><br><span class="line"><span class="string">q=Q.rear;</span></span><br><span class="line"><span class="string">while(p!=NULL)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">cout&lt;&lt;endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">LinkQueue Q;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">if</span>(!InitQueue(Q)) cout&lt;&lt;<span class="string">&quot;链队初始化失败&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要入队的元素个数&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;=j;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要入队的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">EnQueue(Q,e); </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;元素入队成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入对应功能的数字： 1.入队 2.出队 3.销毁链队列 4.显示队列元素 &quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;m;</span></span><br><span class="line"><span class="string">switch(m)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">case 1:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入入队的元素&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;e;</span><br><span class="line">EnQueue(Q,e);</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 2:</span><br><span class="line">&#123;</span><br><span class="line">DeQueue(Q,e);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;删除成功&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 3:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">if(!DestroyQueue(Q,e)) cout&lt;&lt;&quot;销毁失败&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;销毁成功&quot;</span>&lt;&lt;<span class="string">endl; </span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 4:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;显示队列的元素&quot;&lt;&lt;endl</span>;</span><br><span class="line">DispQueue(Q);</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;是否继续执行操作 1.继续 2.退出&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;n;</span></span><br><span class="line"><span class="string">&#125;while(n==1);</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2019/07/30/%E6%A0%88/"/>
      <url>/2019/07/30/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>栈的操作只能在栈顶进行入栈出栈 后进先出<br>栈为空时 栈顶指针top为-1<br>n个不同元素进栈 出栈序列的个数为$\frac{1}{n+1}C_{2n}^{n}$ <code>卡特兰(Catalan)数</code></p><span id="more"></span> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define Maxsize 100</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">ElemType data[Maxsize];</span><br><span class="line">int top;//栈顶指针 </span><br><span class="line">&#125;SqStack;</span><br><span class="line">void InitStack(SqStack &amp;S)&#123;//初始化</span><br><span class="line">S.top=-1;</span><br><span class="line">&#125; </span><br><span class="line">bool Push(SqStack &amp;S,ElemType e)//入栈 在栈顶插入一个新的元素 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==Maxsize-1) <span class="built_in">return</span> 0;//栈满 </span><br><span class="line">S.data[++S.top]=e; //栈顶指针先加1 再将元素存入</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">int Pop(SqStack &amp;S,ElemType &amp;e)//出栈 将栈顶元素删除 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==-1) <span class="built_in">return</span> 0;//栈空 </span><br><span class="line">e=S.data[S.top--];//先将元素输出 再将栈顶指针减1</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool GetTop(SqStack S,ElemType &amp;e)&#123;//取栈顶元素 </span><br><span class="line"><span class="keyword">if</span>(S.top==-1) <span class="built_in">return</span> 0;</span><br><span class="line">e=S.data[S.top];</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125; </span><br><span class="line">int Show(SqStack S)&#123;//从栈顶遍历到栈底</span><br><span class="line">int i;</span><br><span class="line"><span class="keyword">for</span>(i=S.top;i&gt;=0;i--)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">S.data[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line">InitStack(S);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要入栈的元素个数&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;j;</span></span><br><span class="line"><span class="string">for(int i=1;i&lt;=j;i++)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入入栈的元素&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;e;</span><br><span class="line">Push(S,e);</span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;元素入栈成功&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入对应功能的数字： 1.入栈 2.出栈 3.取栈顶元素 4.从栈顶到栈底显示元素 &quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">switch(m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 1:</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入入栈的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">Push(S,e);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 2:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">Pop(S,e);</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="built_in">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 3:</span><br><span class="line">&#123;</span><br><span class="line">ElemType a;</span><br><span class="line">GetTop(S,a);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;栈顶元素是&quot;</span>&lt;&lt;<span class="string">a&lt;&lt;endl;</span></span><br><span class="line"><span class="string">break; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 4:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;从栈顶到栈底显示元素&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="string">Show(S);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;是否继续执行操作 1.继续 2.退出&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;n;</span></span><br><span class="line"><span class="string">&#125;while(n==1);</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>两个顺序栈S1 S2共享一个一维数据空间 两个栈的栈底分别设置为共享空间的两端<br><code>S1.top=-1</code>时 栈S1为空 <code>S2.top=Maxsize</code>时 栈S2为空<br>两个栈顶指针相邻<code>S2.top-S1.top=1</code>时 两个栈满<br>共享栈能更有效的利用存储空间 降低发生上溢的可能</p><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>便于多个栈共享存储空间提高效率 并且不会存在栈满上溢的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct LinkNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LinkNode *next;</span><br><span class="line">&#125;*LiStack;</span><br><span class="line">bool InitStack(LiStack &amp;S)//链栈初始化 </span><br><span class="line">&#123;</span><br><span class="line">S=NULL;//S始终指向栈顶元素 </span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool Push(LiStack &amp;S,ElemType e)//入栈 </span><br><span class="line">&#123;</span><br><span class="line">LinkNode *p =new LinkNode;</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=S;</span><br><span class="line">S=p;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool Pop(LiStack &amp;S,ElemType &amp;e)//出栈 </span><br><span class="line">&#123;</span><br><span class="line">LinkNode *p=new LinkNode;</span><br><span class="line"><span class="keyword">if</span>(S==NULL) <span class="built_in">return</span> 0;//空栈 </span><br><span class="line">e=S-&gt;data;</span><br><span class="line">p=S;</span><br><span class="line">S=S-&gt;next;</span><br><span class="line">delete p;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool GetTop(LiStack S)//取栈顶元素; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S!=NULL) cout&lt;&lt;<span class="string">S-&gt;data&lt;&lt;endl;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void Show(LiStack &amp;S</span>)</span><br><span class="line">&#123;</span><br><span class="line">LinkNode *p =S;//p代替S对栈进行从上到下的遍历 </span><br><span class="line"><span class="keyword">while</span>(p!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">p</span>=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">LiStack S;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line"><span class="keyword">if</span>(!InitStack(S)) cout&lt;&lt;<span class="string">&quot;链栈初始化失败&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要入栈的元素个数&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=j;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入入栈的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">Push(S,e);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;元素入栈成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入对应功能的数字： 1.入栈 2.出栈 3.取栈顶元素 4.从栈顶到栈底显示元素 &quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;m;</span></span><br><span class="line"><span class="string">switch(m)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">case 1:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入入栈的元素&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;e;</span><br><span class="line">Push(S,e);</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 2:</span><br><span class="line">&#123;</span><br><span class="line">Pop(S,e);</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 3:</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;栈顶元素为&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">GetTop(S);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 4:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;栈顶到栈底的元素依次为&quot;&lt;&lt;endl</span>;</span><br><span class="line">Show(S); </span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;是否继续执行操作 1.继续 2.退出&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;n;</span></span><br><span class="line"><span class="string">&#125;while(n==1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2019/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>整个归并排序需要进行$O(log_2n)$次 每一次的归并时间复杂度为$O(n)$<br>所以一共的时间复杂度也为$O(nlog_2n)$<br>归并排序是一种稳定的排序方法</p><span id="more"></span> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Merge(SqList &amp;L,int low,int mid,int high)&#123;//low=1 high=n表长 </span><br><span class="line">int i,j,k;</span><br><span class="line">SqList B;//辅助顺序表B </span><br><span class="line">B.data=new ElemType[MAXSIZE];</span><br><span class="line"><span class="keyword">for</span>(k=low;k&lt;=high;k++) B.data[k]=L.data[k];//将L中所有的元素都复制到B中 </span><br><span class="line"><span class="keyword">for</span>(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(B.data[i]&lt;=B.data[j]) L.data[k]=B.data[i++];//将B划分为左右半区 从各自半区第一个互相比较 </span><br><span class="line"><span class="keyword">else</span> L.data[k]=B.data[j++];//较小的插入到L中 然后后移继续比较大小 直到i超过mid或者j超过high </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) L.data[k++]=B.data[i++];//j越界了i还未遍历完 表示左边区剩下的都是大的 </span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)  L.data[k++]=B.data[j++];//i越界了j还未遍历完 表示右半区剩下的都是大的 </span><br><span class="line">//这两个<span class="keyword">while</span>循环只会有一个会执行 </span><br><span class="line">&#125;</span><br><span class="line">bool MergeSort(SqList &amp;L,int low,int high)&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">int mid=(low+high)/2;</span><br><span class="line">MergeSort(L,low,mid);//左半区递归 </span><br><span class="line">MergeSort(L,mid+1,high);//右半区递归 </span><br><span class="line">Merge(L,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2019/07/17/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/17/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>时间复杂度$O(n^2)$<br>简单选择排序是一种稳定的排序方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool SelectSort(SqList &amp;L,int n)&#123;</span><br><span class="line">int i,j,min;</span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">min=i;</span><br><span class="line"><span class="keyword">for</span>(j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[j]&lt;L.data[min])&#123;</span><br><span class="line">min=j; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min!=i)&#123;//如果最小值不是最开始的值 两个数换位置</span><br><span class="line">L.data[0]=L.data[i];</span><br><span class="line">L.data[i]=L.data[min];</span><br><span class="line">L.data[min]=L.data[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><span id="more"></span> <h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换排序</title>
      <link href="/2019/07/13/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/13/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>最坏情况下 即元素全部逆序 时间复杂度$O(n^2)$<br>平均时间复杂度也为$O(n^2)$<br>冒泡排序是一种稳定的排序方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool BubbleSort(SqList &amp;L,int n)&#123;//n为表长</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">int s=0;</span><br><span class="line"><span class="keyword">for</span>(int j=n;j&gt;i;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[j-1]&gt;L.data[j]) swap(L.data[j-1],L.data[j]);//若后面的小于前面的 交换位置 然后再跟前面的比较 </span><br><span class="line">s=1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s==0) <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span> <p><code>Swap()函数</code>功能为交换这两个数的位置</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> pivot=L.data[low];<span class="comment">//第一个元素作为枢轴</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high&amp;&amp;L.data[high]&gt;=pivot) high--;</span><br><span class="line">L.data[low]=L.data[high];<span class="comment">//从序列的末端向前遍历 </span></span><br><span class="line"><span class="comment">//把比枢轴小的第一个遍历到的元素放在low指向的位置</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high&amp;&amp;L.data[low]&lt;=pivot) low++;</span><br><span class="line">L.data[high]=L.data[low];<span class="comment">//从枢轴后的第一个元素开始向后遍历 </span></span><br><span class="line"><span class="comment">//把第一个比枢轴大的元素放在刚刚high指向的位置</span></span><br><span class="line">&#125;</span><br><span class="line">L.data[low]=pivot;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(SqList &amp;L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;<span class="comment">//low=1 high=n表长</span></span><br><span class="line"><span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line"><span class="type">int</span> pivotpos=<span class="built_in">Partition</span>(L,low,high);</span><br><span class="line"><span class="built_in">QuickSort</span>(L,low,pivotpos<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">QuickSort</span>(L,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg:<br>Circle1:元素初始序列<code>98 36 -9 0 47 23 1 8 10 7</code> 以98为枢轴 从序列末端选择比98小的元素 high指向7 7占据第一个位置<br>从枢轴后向后遍历选择比枢轴大的元素 low指到了最后一个元素也没有找到 low=high跳出循环 枢轴98占据最后一个位置<br>Circle2:元素第二次序列变更为<code>7 36 -9 0 47 23 1 8 10| 98</code>原枢纽98左侧的序列以7位枢轴 从序列末端选择比7小的元素 high指向1 1占据第一个位置<br>从枢轴后向后遍历选择比枢轴大的元素 low指向36 36换到第二次序列中1的位置 low&lt;high继续循环<br>high继续向前遍历寻找比枢轴小的元素 high指向0 0换到第二次序列中36的位置<br>low继续向前遍历寻找比枢轴大的元素 还未遍历到low=high 跳出循环 枢轴7占据第二次序列中0的位置<br>Circle3:元素第三次序列变更为<code>1 0 -9| 7| 47 23 36 8 10| 98</code> 原枢轴7左侧的序列<code>1 0 -9</code><br>以1为枢轴 从序列末端寻找比1小的元素 high指向-9 -9占据第一个位置 从枢轴向后遍历寻找比枢轴大的元素 还未找到 low=high 跳出循环 枢轴1占据第三次序列 -9的位置 左侧序列变更为<code>-9 0 |1</code><br>原枢轴7右侧的序列<code>47 23 36 8 10</code>以47为枢轴 从末端寻找比47小的元素 high指向10 10占据第一个位置 从枢轴向后遍历寻找比枢轴47大的元素 还未找到 low=high 跳出循环 47占据第三次序列中10的位置 右侧序列变更为<code>10 23 36 8 |47</code><br>Circle4:元素第四次序列变更为<code>-9 0| 1| 7| 10 23 36 8| 47| 98</code><br>左侧序列<code>-9 0</code> -9为枢轴 从序列末端寻找比枢轴-9小的元素 还未找到low=high 跳出循环 左侧序列依旧为<code>-9| 0</code><br>右侧序列<code>10 23 36 8</code> 10为枢轴 从序列末端寻找比10小的元素 high指向8 8占据第一个位置 从枢轴向后遍历寻找比10大的元素 low指向23 23 占据第四次序列中8的位置 high继续向前遍历寻找比枢轴10小的元素 还未找到 low=high 跳出循环 枢轴10占据第四次序列中23的位置<br>序列变更为<code>8 |10| 36 23</code><br>Circle5:元素第五次序列变更为<code>-9| 0| 1| 7| 8| 10| 36 23| 47| 98</code> 其中<code>36 23</code>以36为枢轴 从序列末端选择比枢轴36小的元素 high指向23 23占据第一个位置 从枢轴向后遍历寻找比36大的元素 还未找到 low=high跳出循环 36占据第五次序列中23的位置<br>元素最终序列变更为<code>-9 0 1 7 8 10 23 36 47 98</code> 快排结束</p><p>时间复杂度：最好情况下(元素序列越无序) 算法效率越高 $O(nlogn)$ 即每一次Partition函数所得的枢轴都平分序列<br>最坏情况下(元素序列越有序) 算法效率越低 $O(n^2)$ 即每一次Partition函数所得的枢轴都是元素序列的两端点</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2019/07/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序是一个稳定的排序 算法时间复杂度$O(n^2)$<br>适用于顺序存储和链式存储</p><h4 id="前提环境条件"><a href="#前提环境条件" class="headerlink" title="前提环境条件"></a>前提环境条件</h4><p>在顺序表中对表内元素进行直接插入排序<br>对线性表·1描述的顺序表做了几处修改<br>顺序表创建从<code>L.data[1]</code>开始存储元素 <code>L.data[0]</code>不存储元素<br>顺序表遍历从<code>L.data[1]</code>到<code>L.data[n]</code> n为<code>L.length</code>表长</p><span id="more"></span> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt; </span></span><br><span class="line"><span class="comment">#define MAXSIZE 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef int ElemType;//排序必须是数字</span><br><span class="line">typedef struct&#123;</span><br><span class="line">ElemType *data;</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList;</span><br><span class="line">bool Initlist_Sq(SqList &amp;L)&#123;//初始化顺序表L </span><br><span class="line">L.data = new ElemType[MAXSIZE]; </span><br><span class="line">L.length = 0;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">bool ListInsert_Sq(SqList &amp;L,int i,ElemType e)&#123;//插入表L </span><br><span class="line"><span class="keyword">if</span>((i&lt;1)||(i&gt;L.length+1)) <span class="built_in">return</span> 0;</span><br><span class="line"><span class="keyword">if</span>(L.length==MAXSIZE) <span class="built_in">return</span> 0;</span><br><span class="line"><span class="keyword">for</span>(int j=L.length;j&gt;=i;j--)&#123;</span><br><span class="line">L.data[j] = L.data[j-1];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i] = e;//从L.data[1]开始存储元素</span><br><span class="line">L.length++;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line">int GetLength(SqList L)&#123;//求表长 </span><br><span class="line"><span class="built_in">return</span> (L.length); </span><br><span class="line">&#125;</span><br><span class="line">int ShowList(SqList L)&#123;//遍历整个线性表的元素并输出 </span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=L.length;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">L.data[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="直接插入排序代码"><a href="#直接插入排序代码" class="headerlink" title="直接插入排序代码"></a>直接插入排序代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool InsertSort(SqList &amp;L,int n)&#123;//n为表长</span><br><span class="line">int i,j;</span><br><span class="line"><span class="keyword">for</span>(i=2;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]&lt;L.data[i-1])&#123;//第i个元素小于它前驱的元素 </span><br><span class="line">L.data[0]=L.data[i];//哨兵暂存i元素 </span><br><span class="line"><span class="keyword">for</span>(j=i-1;L.data[0]&lt;L.data[j];j--)//从后向前查找待插入的位置 </span><br><span class="line">L.data[j+1]=L.data[j];//将比L.data[0]大的元素都向后移位 </span><br><span class="line">L.data[j+1]=L.data[0]; //复制到插入位置 </span><br><span class="line">            //L.data[0]比L.data[j]大 跳出循环 在L.data[j+1]插入L.data[0]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="折半插入算法"><a href="#折半插入算法" class="headerlink" title="折半插入算法"></a>折半插入算法</h3><p>针对顺序存储的线性表 可以使用折半查找来确定待插入位置<br>折半插入排序是一种稳定的排序方法<br>折半插入排序相较于直接插入排序减少了比较元素的次数 约为$O(nlog_{2}n)$<br>比较元素次数取决于表中元素个数n<br>元素移动次数未改变 因此时间复杂度仍为$O(n^2)$</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool InsertSort(SqList &amp;L,int n)&#123;//从小到大的递增顺序排序</span><br><span class="line">int i,j,low,high,mid;</span><br><span class="line"><span class="keyword">for</span>(i=2;i&lt;=n;i++)&#123;</span><br><span class="line">L.data[0]=L.data[i];//L.data[0]暂存i位置的元素</span><br><span class="line">low=1;high=i-1;//设置折半查找的范围</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/2;</span><br><span class="line"><span class="keyword">if</span>(L.data[mid]&gt;L.data[0]) high=mid-1;//查找左半区</span><br><span class="line"><span class="keyword">else</span> low=mid+1;//查找右半区</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=i-1;j&gt;=high+1;j--)</span><br><span class="line">L.data[j+1]=L.data[j];//后移元素 空出插入位置</span><br><span class="line">L.data[high+1]=L.data[0];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序又称为缩小增量排序 只适用于顺序存储的线性表<br>设置一个增量 增量为区间长度 一般选择表长的一半 一直减半到1<br>在这个增量下的所有元素进行排序 然后缩小增量 再对这个增量下的所有元素进行排序 直到增量为1 进行最后的排序<br>n在某个特定范围时 希尔排序的时间复杂度为$O(n^{1.3})$<br>最坏情况下 希尔排序的时间复杂度为$O(n^2)$<br>希尔排序可能会改变元素的相对次序 因此是一种不稳定的排序方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool ShellSort(SqList &amp;L,int n)&#123;//希尔排序</span><br><span class="line">int i,j,dk;</span><br><span class="line"><span class="keyword">for</span>(dk=n/2;dk&gt;=1;dk=dk/2)&#123;//dk为区间大小 初值为表长的一半 dk可以自己设置 </span><br><span class="line"><span class="keyword">for</span>(i=dk+1;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]&lt;L.data[i-dk])&#123;</span><br><span class="line">L.data[0]=L.data[i];</span><br><span class="line"><span class="keyword">for</span>(j=i-dk;j&gt;0&amp;&amp;L.data[0]&lt;L.data[j];j-=dk)//同一区间大小下的一组元素完全排序 </span><br><span class="line">L.data[j+dk]=L.data[j];</span><br><span class="line">L.data[j+dk]=L.data[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int k=1;k&lt;=L.length;k++)&#123;//一次dk排序后遍历表 观察元素排序变化 </span><br><span class="line">cout&lt;&lt;<span class="string">L.data[k]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>For instance:<br>L表内元素为<code> 96 36 -9 0 47 23 1 8 10 7</code> 表长n为10 增量dk为5<br>第一次排序 L[1]与L[6]比较排序 L[2]与L[7]比较排序 L[3]与L[8]比较排序 L[4]与L[9]比较排序 L[5]与L[10]比较排序<br>L表内元素为<code> 23 1 -9 0 7 98 36 8 10 47</code> 增量dk为5/2=2<br>第二次排序 L[1] L[3] L[5] L[7] L[9]比较排序 L[2] L[4] L[6] L[8] L[10]比较排序<br>L表内元素为<code> -9 0 7 1 10 8 23 47 36 98</code> 增量dk为2/2=1<br>第三次排序 十个元素同时比较排序<br>L表内元素为<code> -9 0 1 7 8 10 23 36 47 98</code> 排序完毕</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表·4</title>
      <link href="/2019/07/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B74/"/>
      <url>/2019/07/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B74/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构复习·4-线性表：循环单链表-循环双链表"><a href="#数据结构复习·4-线性表：循环单链表-循环双链表" class="headerlink" title="数据结构复习·4 线性表：循环单链表/循环双链表"></a>数据结构复习·4 线性表：循环单链表/循环双链表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><p>单链表的最后一个结点的指针指向NULL <code>r-&gt;next=NULL</code><br>循环单链表的最后一个结点的指针指向头结点 <code>r-&gt;next=L</code><br>从而整个链表形成一个环<br>单链表为空条件为头结点的指针指向NULL <code>L-&gt;next=NULL</code><br>循环单链表为空的条件为头结点的指否等于头指针 <code>L-&gt;next=L</code></p><span id="more"></span> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int InitList_L(LinkList &amp;L,int n)//后插法创建空表 </span><br><span class="line">&#123;</span><br><span class="line">L=new LNode;//头结点 </span><br><span class="line">L-&gt;next=L;</span><br><span class="line">LinkList r;//尾指针</span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">LNode *p=new LNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=L;//最后一个结点的next指针指向头结点L</span></span><br><span class="line"><span class="string">r-&gt;next=p;</span></span><br><span class="line"><span class="string">r=p;//r与L的关系为r-&gt;next=L</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h4><p>循环单链表的插入删除算法与单链表的操作完全一样 </p><h4 id="遍历循环单链表"><a href="#遍历循环单链表" class="headerlink" title="遍历循环单链表"></a>遍历循环单链表</h4><p>注意遍历时循环的条件要改为<code>p-&gt;next!=L</code>时继续遍历</p><h4 id="循环单链表全部代码"><a href="#循环单链表全部代码" class="headerlink" title="循环单链表全部代码"></a>循环单链表全部代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define Maxsize 100</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;//next指向struct Lnode结构体变量 </span><br><span class="line">&#125;LNode,*LinkList;//结构体类型LNode 别名为*LinkList </span><br><span class="line">int InitList_L(LinkList &amp;L,int n)//后插法创建空表 </span><br><span class="line">&#123;</span><br><span class="line">L=new LNode;//头结点 </span><br><span class="line">L-&gt;next=L;</span><br><span class="line">LinkList r;</span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">LNode *p=new LNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=L;</span></span><br><span class="line"><span class="string">r-&gt;next=p;</span></span><br><span class="line"><span class="string">r=p;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int ListInsert_L(LinkList &amp;L,int i,ElemType e)//插入数据 </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">LNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">LNode *s=new LNode;</span></span><br><span class="line"><span class="string">s-&gt;data=e;</span></span><br><span class="line"><span class="string">s-&gt;next=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next=s;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int ListDelete_L(LinkList &amp;L,int i)//删除数据 </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">LNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">LNode *q=new LNode;</span></span><br><span class="line"><span class="string">q=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="string">delete q;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void Disp_L(LinkList L)//显示数据 </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">LNode *p=L;</span></span><br><span class="line"><span class="string">while(p-&gt;next!=L)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">LinkList L;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要插入的元素数量&quot;</span>;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(InitList_L(L,n)) cout&lt;&lt;<span class="string">&quot;单链表创建完毕&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;单链表创建失败&quot;&lt;&lt;endl</span>; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入对应功能的数字： 1.插入 2.删除 3.显示表 &quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;m;</span></span><br><span class="line"><span class="string">switch(m)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">case 1:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要插入的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要输入的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">if(!ListInsert_L(L,i,e)) cout&lt;&lt;&quot;插入数据失败&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;插入数据成功&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">break; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 2:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要删除的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line"><span class="keyword">if</span>(!ListDelete_L(L,i)) cout&lt;&lt;<span class="string">&quot;删除失败&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="built_in">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 3:</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输出表数据&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">Disp_L(L);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;是否继续执行操作 1.继续 2.退出&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line">&#125;<span class="keyword">while</span>(j==1);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p>双链表的最后一个结点指向NULL <code>r-&gt;next=NULL</code><br>循环双链表的最后一个结点的后继指针指向头结点<code>r-&gt;next=L</code><br>头结点的前驱指针指向最后一个结点<code>L-&gt;prior=r</code><br>从而整个链表形成一个环<br>双链表为空条件为头结点的指针指向NULL <code>L-&gt;next=NULL</code><br>循环单链表为空的条件为头结点的后继指针与前驱指针等于头指针<br><code>L-&gt;next=L;L-&gt;prior=L</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int InitList(DLinkList &amp;L,int n)&#123;</span><br><span class="line">L=new DNode;//头结点 </span><br><span class="line">L-&gt;next=L;L-&gt;prior=L;//空表 </span><br><span class="line">DLinkList r;//尾指针 </span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">DNode *p=new DNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=L;//最后一个结点的后继指向头结点</span></span><br><span class="line"><span class="string">L-&gt;prior=p; //头结点的前驱指向最后一个结点</span></span><br><span class="line"><span class="string">p-&gt;prior=r;</span></span><br><span class="line"><span class="string">r-&gt;next=p;</span></span><br><span class="line"><span class="string">r=p;//r-&gt;next=L L-&gt;prior=r;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="插入和删除操作-1"><a href="#插入和删除操作-1" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h4><p>循环双链表的插入删除算法与双链表的操作完全一样 </p><h4 id="遍历循环双链表"><a href="#遍历循环双链表" class="headerlink" title="遍历循环双链表"></a>遍历循环双链表</h4><p>注意遍历时循环的条件要改为<code>p-&gt;next!=L</code>时继续遍历</p><h4 id="循环双链表全部代码"><a href="#循环双链表全部代码" class="headerlink" title="循环双链表全部代码"></a>循环双链表全部代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define Maxsize 100</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct DNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct DNode *prior,*next;//prior next指针指向struct DNode结构体变量 </span><br><span class="line">&#125;DNode,*DLinkList; //结构体类型为DNode 别名DLinkList</span><br><span class="line">int InitList(DLinkList &amp;L,int n)&#123;</span><br><span class="line">L=new DNode;//头结点 </span><br><span class="line">L-&gt;next=L;L-&gt;prior=L;//空表 </span><br><span class="line">DLinkList r;//尾指针 </span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">DNode *p=new DNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=L;//最后一个结点的后继指向头结点</span></span><br><span class="line"><span class="string">L-&gt;prior=p; //头结点的前驱指向最后一个结点</span></span><br><span class="line"><span class="string">p-&gt;prior=r;</span></span><br><span class="line"><span class="string">r-&gt;next=p;</span></span><br><span class="line"><span class="string">r=p;//r-&gt;next=L L-&gt;prior=r;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int ListInsert(DLinkList &amp;L,int i,ElemType e)&#123;//插入数据 </span></span><br><span class="line"><span class="string">DNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">DNode *s=new DNode;</span></span><br><span class="line"><span class="string">s-&gt;data=e;</span></span><br><span class="line"><span class="string">s-&gt;next=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next-&gt;prior=s;</span></span><br><span class="line"><span class="string">s-&gt;prior=p;</span></span><br><span class="line"><span class="string">p-&gt;next=s;</span></span><br><span class="line"><span class="string">return 1; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">int ListDelete(DLinkList &amp;L,int i)&#123;</span></span><br><span class="line"><span class="string">DNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">DNode *q=new DNode;</span></span><br><span class="line"><span class="string">q=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="string">q-&gt;next-&gt;prior=p;</span></span><br><span class="line"><span class="string">delete q;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void ShowList(DLinkList L)&#123;//显示元素 </span></span><br><span class="line"><span class="string">DNode *p=L;</span></span><br><span class="line"><span class="string">while(p-&gt;next!=L)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">DLinkList L;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要插入的元素数量&quot;</span>;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(InitList(L,n)) cout&lt;&lt;<span class="string">&quot;双链表创建完毕&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;双链表创建失败&quot;&lt;&lt;endl</span>; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入对应功能的数字： 1.插入 2.删除 3.显示表 &quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;m;</span></span><br><span class="line"><span class="string">switch(m)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">case 1:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要插入的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要输入的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">if(!ListInsert(L,i,e)) cout&lt;&lt;&quot;插入数据失败&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;插入数据成功&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">break; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 2:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要删除的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line"><span class="keyword">if</span>(!ListDelete(L,i)) cout&lt;&lt;<span class="string">&quot;删除失败&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="built_in">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 3:</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输出表数据&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">ShowList(L);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;是否继续执行操作 1.继续 2.退出&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line">&#125;<span class="keyword">while</span>(j==1);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表·3</title>
      <link href="/2019/07/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B73/"/>
      <url>/2019/07/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B73/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构复习·3-线性表：双链表"><a href="#数据结构复习·3-线性表：双链表" class="headerlink" title="数据结构复习·3 线性表：双链表"></a>数据结构复习·3 线性表：双链表</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>建议重新复习一下C++对结构体的定义以及typedef声明新的类型名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt; </span></span><br><span class="line"><span class="comment">#define OK 1</span></span><br><span class="line"><span class="comment">#define ERROR 0</span></span><br><span class="line"><span class="comment">#define OVERFLOW -2</span></span><br><span class="line"><span class="comment">#define MAXSIZE 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct DNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct DNode *prior,*next;//prior next指针指向struct DNode结构体变量</span><br><span class="line">    //prior为前驱指针 next为后继指针</span><br><span class="line">&#125;DNode,*DLinkList; //结构体类型为DNode 别名DLinkList</span><br></pre></td></tr></table></figure><span id="more"></span> <h3 id="后插法创建双链表"><a href="#后插法创建双链表" class="headerlink" title="后插法创建双链表"></a>后插法创建双链表</h3><p>后插法(尾插法)：新元素插入到链表表尾，结点的次序与插入的次序是一致的<br>后插法只比头插法多了一个指向表尾结点的指针r</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int InitList(DLinkList &amp;L,int n)&#123;</span><br><span class="line">L=new DNode;//头结点 </span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">DLinkList r;//创建表尾指针r</span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">DNode *p=new DNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=NULL;</span></span><br><span class="line"><span class="string">p-&gt;prior=r;</span></span><br><span class="line"><span class="string">r-&gt;next=p;</span></span><br><span class="line"><span class="string">r=p;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="插入结点-针对后插法创建的链表"><a href="#插入结点-针对后插法创建的链表" class="headerlink" title="插入结点(针对后插法创建的链表)"></a>插入结点(针对后插法创建的链表)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int ListInsert(DLinkList &amp;L,int i,ElemType e)&#123;//插入数据 </span><br><span class="line">DNode *p=L;</span><br><span class="line">int j=1;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;(j&lt;i))</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">DNode *s=new DNode;</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior=s;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line"><span class="built_in">return</span> 1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int ListDelete(DLinkList &amp;L,int i)&#123;</span><br><span class="line">DNode *p=L;</span><br><span class="line">int j=1;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;(j&lt;i))&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">DNode *q=new DNode;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line">delete q;</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示双链表内数据"><a href="#显示双链表内数据" class="headerlink" title="显示双链表内数据"></a>显示双链表内数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ShowList(DLinkList L)&#123;//显示元素 </span><br><span class="line">DNode *p=L;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">cout&lt;&lt;<span class="string">p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要计算表长 在while循环里放置一个计数器i输出即可</p><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;//</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define Maxsize 100</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct DNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct DNode *prior,*next;//prior next指针指向struct DNode结构体变量 </span><br><span class="line">&#125;DNode,*DLinkList; //结构体类型为DNode 别名DLinkList</span><br><span class="line">int InitList(DLinkList &amp;L,int n)&#123;</span><br><span class="line">L=new DNode;//头结点 </span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">DLinkList r;</span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">DNode *p=new DNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=NULL;</span></span><br><span class="line"><span class="string">p-&gt;prior=r;</span></span><br><span class="line"><span class="string">r-&gt;next=p;</span></span><br><span class="line"><span class="string">r=p;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int ListInsert(DLinkList &amp;L,int i,ElemType e)&#123;//插入数据 </span></span><br><span class="line"><span class="string">DNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">DNode *s=new DNode;</span></span><br><span class="line"><span class="string">s-&gt;data=e;</span></span><br><span class="line"><span class="string">s-&gt;next=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next-&gt;prior=s;</span></span><br><span class="line"><span class="string">s-&gt;prior=p;</span></span><br><span class="line"><span class="string">p-&gt;next=s;</span></span><br><span class="line"><span class="string">return 1; </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">int ListDelete(DLinkList &amp;L,int i)&#123;</span></span><br><span class="line"><span class="string">DNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">DNode *q=new DNode;</span></span><br><span class="line"><span class="string">q=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="string">q-&gt;next-&gt;prior=p;</span></span><br><span class="line"><span class="string">delete q;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void ShowList(DLinkList L)&#123;//显示元素 </span></span><br><span class="line"><span class="string">DNode *p=L;</span></span><br><span class="line"><span class="string">while(p-&gt;next!=NULL)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">DLinkList L;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要插入的元素数量&quot;</span>;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(InitList(L,n)) cout&lt;&lt;<span class="string">&quot;双链表创建完毕&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;双链表创建失败&quot;&lt;&lt;endl</span>; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入对应功能的数字： 1.插入 2.删除 3.显示表 &quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;m;</span></span><br><span class="line"><span class="string">switch(m)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">case 1:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要插入的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要输入的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">if(!ListInsert(L,i,e)) cout&lt;&lt;&quot;插入数据失败&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;插入数据成功&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">break; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 2:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要删除的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line"><span class="keyword">if</span>(!ListDelete(L,i)) cout&lt;&lt;<span class="string">&quot;删除失败&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="built_in">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 3:</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输出表数据&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">ShowList(L);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;是否继续执行操作 1.继续 2.退出&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line">&#125;<span class="keyword">while</span>(j==1);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu上传下载文件</title>
      <link href="/2019/06/14/Ubuntu%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2019/06/14/Ubuntu%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用pscp上传下载文件"><a href="#使用pscp上传下载文件" class="headerlink" title="使用pscp上传下载文件"></a>使用pscp上传下载文件</h1><h2 id="pscp上传文件到指定目录"><a href="#pscp上传文件到指定目录" class="headerlink" title="pscp上传文件到指定目录"></a>pscp上传文件到指定目录</h2><p>eg. 将Windows10下D:\Code\datastructure.txt文件上传到Ubuntu下var/www目录下<br>cmd的pscp命令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /D D:\Code\</span><br><span class="line">pscp D:\Code\php.zip root@ip:/var/www/</span><br><span class="line"><span class="comment">#ip为服务器的公网ip地址</span></span><br><span class="line"><span class="comment">#然后输入root的密码即可上传成功</span></span><br></pre></td></tr></table></figure><span id="more"></span> <h2 id="pscp下载文件到指定目录"><a href="#pscp下载文件到指定目录" class="headerlink" title="pscp下载文件到指定目录"></a>pscp下载文件到指定目录</h2><p>eg. 将Ubuntu下/var/www/目录下所有文件都下载到Windows10下D:\Code目录下<br>cmd的pscp命令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /D D:\Code\</span><br><span class="line">pscp -r root@ip:/var/www <span class="string">&quot;D:\Code&quot;</span></span><br><span class="line"><span class="comment">#ip为服务器的公网ip地址</span></span><br><span class="line"><span class="comment">#然后输入root的密码即可下载成功</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令</title>
      <link href="/2019/06/06/Git%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/06/06/Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>本文旨在记录本人学习和使用git命令操作的时候遇到的问题和解决方案 </p><h3 id="修改commit注释"><a href="#修改commit注释" class="headerlink" title="修改commit注释"></a>修改commit注释</h3><p>学习git提交文件到github的时候没有注意自己commit的命名，因此事后需要作出修改</p><h3 id="修改最新一次的commit注释"><a href="#修改最新一次的commit注释" class="headerlink" title="修改最新一次的commit注释"></a>修改最新一次的commit注释</h3><p>添加了commit注释，但是没有push </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><span id="more"></span> <p>进入了Vim编辑状态，按i进入插入模式<br>直接编辑注释信息，按ESC退出插入模式<br>输入:wq回车后保存退出</p><h3 id="修改历史提交过的commit注释"><a href="#修改历史提交过的commit注释" class="headerlink" title="修改历史提交过的commit注释"></a>修改历史提交过的commit注释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~5</span><br><span class="line"><span class="comment">#~5表示修改近5次的提交状态注释</span></span><br></pre></td></tr></table></figure><p>命令键入后进入Vim编辑状态，文件内容最上面有着几行pick信息，pick的内容就是曾提交过的commit注释。<br>按i进入插入模式，将想修改的注释前的pick修改为edit，然后ESC退出插入模式<br>输入:wq回车后保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这时候就可以修改commit信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>continue后修改成功</p><h3 id="拉取repo"><a href="#拉取repo" class="headerlink" title="拉取repo"></a>拉取repo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>pull后 本地文件就会下载git云端文件 保持更新一致</p><h4 id="pull后提示abort"><a href="#pull后提示abort" class="headerlink" title="pull后提示abort"></a>pull后提示abort</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by merge:</span><br><span class="line">        _config.yml</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>针对此情况 先使用stash备份当前工作区 再拉取git云端文件 最后再将备份的工作区恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h4 id="push后发现-non-fast-forward"><a href="#push后发现-non-fast-forward" class="headerlink" title="push后发现 non-fast-forward"></a>push后发现 non-fast-forward</h4><p>起因: 因为发现本地一个cpp文件为空 以为是误操作删除了代码 所以将本地仓库回退到了上一个commit 然后修改了cpp文件内的部分代码 然后再push操作 发现报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">To https://github.com/shaoyuanhangyes/LeetCode.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;https://github.com/shaoyuanhangyes/LeetCode.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>分析问题: 未保证远程本地仓库的一致性 因为本地仓库回退了上一个版本 所以相当于没有及时的与远程仓库同步拉取的同时 又在本地仓库新添加了一些内容 所以push操作的时候 会检测到之前从远程仓库拉取的状态和现在的状态不一致 为了安全考虑拒绝了你的push</p><p>non-fast-forward 不能快速前进 之所以不能快速前进是因为路不一样了 即在git里的提交历史出现分叉 主线不再是一条直线 git不知道如何前进 所以报错 让你来决定走哪条线</p><p>解决方案1: 合并之前的历史提交 然后再push </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master <span class="comment">#重定基 将提交历史趋向于一条直线</span></span><br></pre></td></tr></table></figure><p>git pull git fetch git merge的关系为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="operator">=</span> git <span class="keyword">fetch</span> <span class="operator">+</span> git <span class="keyword">merge</span> FETCH_HEAD </span><br><span class="line"></span><br><span class="line">git pull <span class="comment">--rebase =  git fetch + git rebase FETCH_HEAD</span></span><br></pre></td></tr></table></figure><p>解决方案2: 直接用当前本地仓库内容去覆盖远程仓库内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -force</span><br></pre></td></tr></table></figure><p>除非真的想完全覆盖远程仓库 否则不要强制执行push</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表·2</title>
      <link href="/2019/05/29/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B72/"/>
      <url>/2019/05/29/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B72/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构复习·2-线性表：单链表"><a href="#数据结构复习·2-线性表：单链表" class="headerlink" title="数据结构复习·2 线性表：单链表"></a>数据结构复习·2 线性表：单链表</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>建议重新复习一下C++对结构体的定义以及typedef声明新的类型名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt; </span></span><br><span class="line"><span class="comment">#define OK 1</span></span><br><span class="line"><span class="comment">#define ERROR 0</span></span><br><span class="line"><span class="comment">#define OVERFLOW -2</span></span><br><span class="line"><span class="comment">#define MAXSIZE 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct LNode&#123;       //定义单链表节点类型</span><br><span class="line">ElemType data;     //数据域</span><br><span class="line">struct LNode *next; //指针域 next指向LNode结构体变量</span><br><span class="line">&#125;LNode,*LinkList;    //结构体类型LNode 别名为*LinkList</span><br></pre></td></tr></table></figure><span id="more"></span> <h3 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a>头插法创建单链表</h3><p>头插法(前插法)：新元素插入到链表的表头，即头结点之后，因此结点的次序与插入的次序相反</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int InitList_L(LinkList &amp;L,int n)//头插法创建空表 </span><br><span class="line">&#123;</span><br><span class="line">L=new LNode;//创建头结点</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">LNode *p=new LNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=L-&gt;next;//p结点与头结点的下一个结点建立连接</span></span><br><span class="line"><span class="string">L-&gt;next=p;//p结点与头结点建立连接，p结点成为头结点的下一个结点</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="后插法创建单链表"><a href="#后插法创建单链表" class="headerlink" title="后插法创建单链表"></a>后插法创建单链表</h3><p>后插法(尾插法)：新元素插入到链表表尾，结点的次序与插入的次序是一致的<br>后插法只比头插法多了一个指向表尾结点的指针r</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int InitList_L(LinkList &amp;L,int n)//后插法创建空表 </span><br><span class="line">&#123;</span><br><span class="line">L=new LNode;//创建头结点</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">LinkList r;//创建表尾指针r</span><br><span class="line">r=L;//表为空时表尾指针r暂时指向头结点</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">  LNode *p=new LNode;//创建新元素的结点p</span></span><br><span class="line"><span class="string">  cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">  p-&gt;next=NULL;//插入新元素p为表尾</span></span><br><span class="line"><span class="string">  r-&gt;next=p;//p结点与头结点建立连接</span></span><br><span class="line"><span class="string">  r=p;//r指向表尾元素</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="插入结点-针对后插法创建的链表"><a href="#插入结点-针对后插法创建的链表" class="headerlink" title="插入结点(针对后插法创建的链表)"></a>插入结点(针对后插法创建的链表)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int ListInsert_L(LinkList &amp;L,int i,ElemType e)//插入数据 </span><br><span class="line">&#123;</span><br><span class="line">LNode *p=L;//p暂时指向头结点</span><br><span class="line">int j=1;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;(j&lt;i))&#123;//若合法，指针p查找到第i-1个结点</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">LNode *s=new LNode;</span><br><span class="line">s-&gt;data=e;//创建新结点并赋值</span><br><span class="line">s-&gt;next=p-&gt;next;//向后连接</span><br><span class="line">p-&gt;next=s;//向前连接</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int ListDelete_L(LinkList &amp;L,int i)//删除数据 </span><br><span class="line">&#123;</span><br><span class="line">LNode *p=L;</span><br><span class="line">int j=1;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;(j&lt;i))</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;//与插入结点的查询i-1相同 p指向第i-1个结点</span><br><span class="line">LNode *q=new LNode;</span><br><span class="line">q=p-&gt;next;//将要删除的结点赋给q</span><br><span class="line">p-&gt;next=q-&gt;next;//i-1结点指向i+1结点</span><br><span class="line">delete q;//释放结点q</span><br><span class="line"><span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示链表内数据"><a href="#显示链表内数据" class="headerlink" title="显示链表内数据"></a>显示链表内数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Disp_L(LinkList L)//显示数据 </span><br><span class="line">&#123;</span><br><span class="line">LNode *p=L;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">cout&lt;&lt;<span class="string">p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要计算表长 在while循环里放置一个计数器i输出即可</p><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define Maxsize 100</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct LNode *next;//next指向struct Lnode结构体变量 </span><br><span class="line">&#125;LNode,*LinkList;//结构体类型LNode 别名为*LinkList </span><br><span class="line">int InitList_L(LinkList &amp;L,int n)//后插法创建空表 </span><br><span class="line">&#123;</span><br><span class="line">L=new LNode;//头结点 </span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">LinkList r;</span><br><span class="line">r=L;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入一个元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">LNode *p=new LNode;</span></span><br><span class="line"><span class="string">cin&gt;&gt;p-&gt;data;</span></span><br><span class="line"><span class="string">p-&gt;next=NULL;</span></span><br><span class="line"><span class="string">r-&gt;next=p;</span></span><br><span class="line"><span class="string">r=p;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int ListInsert_L(LinkList &amp;L,int i,ElemType e)//插入数据 </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">LNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">LNode *s=new LNode;</span></span><br><span class="line"><span class="string">s-&gt;data=e;</span></span><br><span class="line"><span class="string">s-&gt;next=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next=s;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int ListDelete_L(LinkList &amp;L,int i)//删除数据 </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">LNode *p=L;</span></span><br><span class="line"><span class="string">int j=1;</span></span><br><span class="line"><span class="string">while(p&amp;&amp;(j&lt;i))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">++j;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">LNode *q=new LNode;</span></span><br><span class="line"><span class="string">q=p-&gt;next;</span></span><br><span class="line"><span class="string">p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="string">delete q;</span></span><br><span class="line"><span class="string">return 1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void Disp_L(LinkList L)//显示数据 </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">LNode *p=L;</span></span><br><span class="line"><span class="string">while(p-&gt;next!=NULL)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">p=p-&gt;next;</span></span><br><span class="line"><span class="string">cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">LinkList L;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要插入的元素数量&quot;</span>;</span><br><span class="line">int i,j,m,n;</span><br><span class="line">ElemType e;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(InitList_L(L,n)) cout&lt;&lt;<span class="string">&quot;单链表创建完毕&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;单链表创建失败&quot;&lt;&lt;endl</span>; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入对应功能的数字： 1.插入 2.删除 3.显示表 &quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;m;</span></span><br><span class="line"><span class="string">switch(m)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">case 1:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要插入的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入要输入的元素&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">cin&gt;&gt;e;</span></span><br><span class="line"><span class="string">if(!ListInsert_L(L,i,e)) cout&lt;&lt;&quot;插入数据失败&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;插入数据成功&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">break; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 2:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;请输入要删除的位置&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line"><span class="keyword">if</span>(!ListDelete_L(L,i)) cout&lt;&lt;<span class="string">&quot;删除失败&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">else cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl</span>;</span><br><span class="line"><span class="built_in">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> 3:</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输出表数据&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">Disp_L(L);</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;是否继续执行操作 1.继续 2.退出&quot;&lt;&lt;endl</span>;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line">&#125;<span class="keyword">while</span>(j==1);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetBrains</title>
      <link href="/2019/02/26/JetBrains/"/>
      <url>/2019/02/26/JetBrains/</url>
      
        <content type="html"><![CDATA[<h2 id="激活步骤"><a href="#激活步骤" class="headerlink" title="激活步骤"></a>激活步骤</h2><p>将jetbrains-agent.jar移动到bin目录下</p><p>然后打开 clion64.exe.vmoptions 添加此行代码 Goland同理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:D:\Code\JetBrains\CLion 2019.3.5\bin\jetbrains-agent.jar</span><br></pre></td></tr></table></figure><p>打开exe进入界面 选择Help-&gt;Register<br>在Licensed server address处填写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fls.jetbrains-agent.com</span><br></pre></td></tr></table></figure><p>activate后 即可激活<br>此激活方式必须保证打开Jetbrains软件的时候处于联网状态 否则会连接不到激活服务器</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown书写数学公式</title>
      <link href="/2019/01/16/Markdown%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/01/16/Markdown%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>theme/next下_config.yml中<code> mathjax: enable: true</code>要开启</p><h2 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h2><h3 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h3><p><strong>行内公式</strong>是可以让公式在文中与文字或其他东西混编，不独占一行。<code> $数学公式$</code></p><ul><li>示例<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能方程 <span class="symbol">$</span>E = mc^<span class="number">2</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li>显示<br>质能方程 $E = mc^2$<span id="more"></span> <h3 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h3></li></ul><p><strong>独立公式</strong>使公式单独占一行，不与文中其他文字等混编。 <code> $$数学公式$$</code></p><ul><li>示例<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能方程 <span class="symbol">$</span><span class="symbol">$</span>E = mc^<span class="number">2</span><span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li>显示<br>质能方程 $$E = mc^2$$</li></ul><h2 id="普通数学公式"><a href="#普通数学公式" class="headerlink" title="普通数学公式"></a>普通数学公式</h2><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><p>与平时书写习惯一样</p><ul><li>示例<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>x = <span class="number">25</span>*y+<span class="number">18</span>-z/<span class="number">2</span>+<span class="number">10</span>%<span class="number">3</span><span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li>显示<br>$$x = 25*y+18-z/2+10%3$$</li></ul><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>使用<code>^</code>来表示上标 <code>_</code>来表示下标 同时如果上下标的内容多于一个字符 可以使用<code>&#123;&#125;</code>来将这些内容括起来当做一个整体 上下标是可以嵌套的。</p><ul><li>示例<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$$x</span> = a_&#123;<span class="number">1</span>&#125;<span class="symbol">^n</span>+a_&#123;<span class="number">2</span>&#125;<span class="symbol">^n</span>+a_&#123;<span class="number">3</span>&#125;<span class="symbol">^n</span>$$</span><br></pre></td></tr></table></figure></li><li>显示<br>$$x = a_{1}^n+a_{2}^n+a_{3}^n$$<br>如果希望左右两边都能有上下标，可以使用\sideset语法</li><li>示例<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\sideset&#123;^<span class="number">1</span>_2&#125;&#123;^<span class="number">3</span>_4&#125;\bigotimes<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li>显示<br>$$\sideset{^1_2}{^3_4}\bigotimes$$</li></ul><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p><code>()</code> <code>[]</code> 和<code>|</code>都表示它们自己，但是<code>&#123;&#125;</code>因为有特殊作用因此当需要显示大括号时一般使用<code>\lbrace \rbrace</code>来表示。</p><ul><li>示例<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>f(x,y) = <span class="number">25</span>*\lbrace x+(y<span class="number">-1</span>)/<span class="number">2</span> \rbrace<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li>显示<br>$$f(x,y) = 25*\lbrace x+(y-1)/2 \rbrace$$</li></ul><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>分数使用<code>\frac&#123;分母&#125;&#123;分子&#125;</code>这样的语法 不过推荐使用<code>\cfrac</code>来代替<code>\frac</code>显示公式不会太挤。</p><ul><li>示例<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\<span class="built_in">frac</span>&#123;<span class="number">1</span>&#125;&#123;<span class="number">3</span>&#125; 与 \cfrac&#123;<span class="number">1</span>&#125;&#123;<span class="number">3</span>&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li>显示</li></ul><p>$$\frac{1}{3} 与 \cfrac{1}{3}$$</p><h3 id="根号开方"><a href="#根号开方" class="headerlink" title="根号开方"></a>根号开方</h3><p>开方使用<code>\sqrt[次数]&#123;被开方数&#125;</code>这样的语法</p><ul><li>示例<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\<span class="built_in">sqrt</span>[<span class="number">2</span>]&#123;X&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\<span class="built_in">sqrt</span>[<span class="number">3</span>]&#123;Y&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\<span class="built_in">sqrt</span>&#123;<span class="number">5</span>-x&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure></li><li>显示<br>$$\sqrt[2]{X}$$<br>$$\sqrt[3]{Y}$$<br>$$\sqrt{5-x}$$</li></ul><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><table><thead><tr><th align="center">代码</th><th align="center">大写</th><th align="center">代码</th><th align="center">小写</th></tr></thead><tbody><tr><td align="center"><code>A</code></td><td align="center">$A$</td><td align="center"><code>\alpha</code></td><td align="center">$\alpha$</td></tr><tr><td align="center"><code>B</code></td><td align="center">$B$</td><td align="center"><code>\beta</code></td><td align="center">$\beta$</td></tr><tr><td align="center"><code>\Gamma</code></td><td align="center">$\Gamma$</td><td align="center"><code>\gamma</code></td><td align="center">$\gamma$</td></tr><tr><td align="center"><code>\Delta</code></td><td align="center">$\Delta$</td><td align="center"><code>\delta</code></td><td align="center">$\delta$</td></tr><tr><td align="center"><code>E</code></td><td align="center">$E$</td><td align="center"><code>\epsilon</code></td><td align="center">$\epsilon$</td></tr><tr><td align="center"><code>Z</code></td><td align="center">$Z$</td><td align="center"><code>\zeta</code></td><td align="center">$\zeta$</td></tr><tr><td align="center"><code>H</code></td><td align="center">$H$</td><td align="center"><code>\eta</code></td><td align="center">$\eta$</td></tr><tr><td align="center"><code>\Theta</code></td><td align="center">$\Theta$</td><td align="center"><code>\theta</code></td><td align="center">$\theta$</td></tr><tr><td align="center"><code>I</code></td><td align="center">$I$</td><td align="center"><code>\iota</code></td><td align="center">$\iota$</td></tr><tr><td align="center"><code>K</code></td><td align="center">$K$</td><td align="center"><code>\kappa</code></td><td align="center">$\kappa$</td></tr><tr><td align="center"><code>\Lambda</code></td><td align="center">$\Lambda$</td><td align="center"><code>\lambda</code></td><td align="center">$\lambda$</td></tr><tr><td align="center"><code>M</code></td><td align="center">$M$</td><td align="center"><code>\mu</code></td><td align="center">$\mu$</td></tr><tr><td align="center"><code>N</code></td><td align="center">$N$</td><td align="center"><code>\nu</code></td><td align="center">$\nu$</td></tr><tr><td align="center"><code>\Xi</code></td><td align="center">$\Xi$</td><td align="center"><code>\xi</code></td><td align="center">$\xi$</td></tr><tr><td align="center"><code>O</code></td><td align="center">$O$</td><td align="center"><code>\omicron</code></td><td align="center">$\omicron$</td></tr><tr><td align="center"><code>\Pi</code></td><td align="center">$\Pi$</td><td align="center"><code>\pi</code></td><td align="center">$\pi$</td></tr><tr><td align="center"><code>P</code></td><td align="center">$P$</td><td align="center"><code>\rho</code></td><td align="center">$\rho$</td></tr><tr><td align="center"><code>\Sigma</code></td><td align="center">$\Sigma$</td><td align="center"><code>\sigma</code></td><td align="center">$\sigma$</td></tr><tr><td align="center"><code>T</code></td><td align="center">$T$</td><td align="center"><code>\tau</code></td><td align="center">$\tau$</td></tr><tr><td align="center"><code>\Upsilon</code></td><td align="center">$\Upsilon$</td><td align="center"><code>\upsilon</code></td><td align="center">$\upsilon$</td></tr><tr><td align="center"><code>\Phi</code></td><td align="center">$\Phi$</td><td align="center"><code>\phi</code></td><td align="center">$\phi$</td></tr><tr><td align="center"><code>X</code></td><td align="center">$X$</td><td align="center"><code>\chi</code></td><td align="center">$\chi$</td></tr><tr><td align="center"><code>\Psi</code></td><td align="center">$\Psi$</td><td align="center"><code>\psi</code></td><td align="center">$\psi$</td></tr><tr><td align="center"><code>\Omega</code></td><td align="center">$\Omega$</td><td align="center"><code>\omega</code></td><td align="center">$\omega$</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="center">符号</th><th align="center">代码</th><th align="center">符号</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">$\pm$</td><td align="center"><code>\pm</code></td><td align="center">$\times$</td><td align="center"><code>\times</code></td></tr><tr><td align="center">$\div$</td><td align="center"><code>\div</code></td><td align="center">$\mid$</td><td align="center"><code>\mid</code></td></tr><tr><td align="center">$\cdot$</td><td align="center"><code>\cdot</code></td><td align="center">$\ast$</td><td align="center"><code>\ast</code></td></tr><tr><td align="center">$\cdot$</td><td align="center"><code>\cdot</code></td><td align="center">$\ast$</td><td align="center"><code>\ast</code></td></tr><tr><td align="center">$\bigodot$</td><td align="center"><code>\bigodot</code></td><td align="center">$\bigotimes$</td><td align="center"><code>\bigotimes</code></td></tr><tr><td align="center">$\bigoplus$</td><td align="center"><code>\bigoplus</code></td><td align="center">$\circ$</td><td align="center"><code>\circ</code></td></tr><tr><td align="center">$\leq$</td><td align="center"><code>\leq</code></td><td align="center">$\geq$</td><td align="center"><code>\geq</code></td></tr><tr><td align="center">$\neq$</td><td align="center"><code>\neq</code></td><td align="center">$\approx$</td><td align="center"><code>\approx</code></td></tr><tr><td align="center">$\equiv$</td><td align="center"><code>\equiv</code></td><td align="center">$\sum$</td><td align="center"><code>\sum</code></td></tr><tr><td align="center">$\prod$</td><td align="center"><code>\prod</code></td><td align="center">$\coprod$</td><td align="center"><code>\coprod</code></td></tr><tr><td align="center">$\bot$</td><td align="center"><code>\bot</code></td><td align="center">$\angle$</td><td align="center"><code>\angle</code></td></tr><tr><td align="center">$\lceil n\rceil$</td><td align="center"><code>\lceil n\rceil</code></td><td align="center">$\lfloor n\rfloor$</td><td align="center"><code>\lfloor n\rfloor</code></td></tr></tbody></table><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><table><thead><tr><th align="center">符号</th><th align="center">代码</th><th align="center">符号</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">$\sin$</td><td align="center"><code>\sin</code></td><td align="center">$\cos$</td><td align="center"><code>\cos</code></td></tr><tr><td align="center">$\tan$</td><td align="center"><code>\tan</code></td><td align="center">$\cot$</td><td align="center"><code>\cot</code></td></tr><tr><td align="center">$\sec$</td><td align="center"><code>\sec</code></td><td align="center">$\csc$</td><td align="center"><code>\csc</code></td></tr><tr><td align="center">$\arcsin$</td><td align="center"><code>\arcsin</code></td><td align="center">$\arccos$</td><td align="center"><code>\arccos</code></td></tr><tr><td align="center">$\arctan$</td><td align="center"><code>\arctan</code></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h3><table><thead><tr><th align="center">符号</th><th align="center">代码</th><th align="center">符号</th><th align="center">代码</th><th align="center">符号</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">$\log$</td><td align="center"><code>\log</code></td><td align="center">$\lg$</td><td align="center"><code>\lg</code></td><td align="center">$\ln$</td><td align="center"><code>\ln</code></td></tr></tbody></table><h3 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h3><table><thead><tr><th align="center">符号</th><th align="center">代码</th><th align="center">符号</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">$\lim$</td><td align="center"><code>\lim</code></td><td align="center">$\prime$</td><td align="center"><code>\prime</code></td></tr><tr><td align="center">$\infty$</td><td align="center"><code>\infty</code></td><td align="center">$\mathrm{d}$</td><td align="center"><code>\mathrm&#123;d&#125;</code></td></tr><tr><td align="center">$\int$</td><td align="center"><code>\int</code></td><td align="center">$\oint$</td><td align="center"><code>\oint</code></td></tr><tr><td align="center">$\iint$</td><td align="center"><code>\iint</code></td><td align="center">$\iiint$</td><td align="center"><code>iiint</code></td></tr><tr><td align="center">$\partial$</td><td align="center"><code>$\partial$</code></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="省略号-Martrix"><a href="#省略号-Martrix" class="headerlink" title="省略号(Martrix)"></a>省略号(Martrix)</h3><table><thead><tr><th align="center">符号</th><th align="center">代码</th><th align="center">符号</th><th align="center">代码</th><th align="center">符号</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">$$\cdots$$</td><td align="center"><code>$$\cdots$$</code></td><td align="center">$$\ddots$$</td><td align="center"><code>$$\ddots$$</code></td><td align="center">$$\vdots$$</td><td align="center"><code>$$\vdots$$</code></td></tr></tbody></table><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>在开头使用 <code>\begin&#123;matrix&#125;</code> 在结尾使用 <code>\end&#123;matrix&#125;</code> 在中间插入矩阵元素 每个元素之间插入<code>&amp;</code> 并在每行结尾处使用 <code>\\</code> <strong>(更新最新版本后必须要<code>\\\</code>才能起到换行 可能是新版本转义的问题 老版本不存在)</strong><br>使用矩阵时必须声明<code>$</code>或<code>$$</code>符号。</p><table><thead><tr><th align="center">符号</th><th>代码</th></tr></thead><tbody><tr><td align="center">$$\begin{matrix}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \end{matrix}$$</td><td><code>$$\begin&#123;matrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\\ a_&#123;31&#125; &amp; a_&#123;32&#125; &amp; a_&#123;33&#125; \end&#123;matrix&#125;$$</code></td></tr><tr><td align="center">$$\begin{pmatrix}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix}$$</td><td><code>$$\begin&#123;pmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\\ a_&#123;31&#125; &amp; a_&#123;32&#125; &amp; a_&#123;33&#125; \end&#123;pmatrix&#125;$$</code></td></tr><tr><td align="center">$$\begin{vmatrix}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \end{vmatrix}$$</td><td><code>$$\begin&#123;vmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\\ a_&#123;31&#125; &amp; a_&#123;32&#125; &amp; a_&#123;33&#125; \end&#123;vmatrix&#125;$$</code></td></tr><tr><td align="center">$$\begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \end{bmatrix}$$</td><td><code>$$\begin&#123;bmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\\ a_&#123;31&#125; &amp; a_&#123;32&#125; &amp; a_&#123;33&#125; \end&#123;bmatrix&#125;$$</code></td></tr><tr><td align="center">$$\begin{Bmatrix}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \end{Bmatrix}$$</td><td><code>$$\begin&#123;Bmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\\ a_&#123;31&#125; &amp; a_&#123;32&#125; &amp; a_&#123;33&#125; \end&#123;Bmatrix&#125;$$</code></td></tr><tr><td align="center">$$\begin{Vmatrix}a_{11} &amp; a_{12} &amp; a_{13} \\a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \end{Vmatrix}$$</td><td><code>$$\begin&#123;Vmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\\ a_&#123;31&#125; &amp; a_&#123;32&#125; &amp; a_&#123;33&#125; \end&#123;Vmatrix&#125;$$</code></td></tr><tr><td align="center">$$\begin{pmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \end{pmatrix}_{n\times n}$$</td><td><code>$$\begin&#123;pmatrix&#125;a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\\a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\ a_&#123;n1&#125; &amp; a_&#123;n2&#125; &amp; \cdots &amp; a_&#123;nn&#125; \end&#123;pmatrix&#125;_&#123;n\times n&#125;$$</code></td></tr></tbody></table><h2 id="综合案例示例"><a href="#综合案例示例" class="headerlink" title="综合案例示例"></a>综合案例示例</h2><table><thead><tr><th align="center">符号</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">$$\pi=16\arctan(\frac{1}{5})-4\arctan(\frac{1}{239})$$</td><td align="center"><code>$$\pi=16\arctan(\frac&#123;1&#125;&#123;5&#125;)-4\arctan(\frac&#123;1&#125;&#123;239&#125;)$$</code></td></tr><tr><td align="center">$$(\sin{x})^{\prime}=\cos{x}$$</td><td align="center"><code>$$(\sin&#123;x&#125;)\prime=\cos&#123;x&#125;$$</code></td></tr><tr><td align="center">$$\lim_{x\to+\infty}\cfrac{sin{x}}{x}=0$$</td><td align="center"><code>$$\lim_&#123;x\rightarrow+\infty&#125;\cfrac&#123;sin&#123;x&#125;&#125;&#123;x&#125;=0$$</code></td></tr><tr><td align="center">$$\int_{a}^{b}f(x)\mathrm{d}{x}=f(\xi)(b-a)$$</td><td align="center"><code>$$\int_&#123;a&#125;^&#123;b&#125;f(x)\mathrm&#123;d&#125;&#123;x&#125;=f(\xi)(b-a)$$</code></td></tr><tr><td align="center">$$e^{i\theta}=\cos\theta+i\sin\theta$$</td><td align="center"><code>$$e^&#123;i\theta&#125;=\cos\theta+i\sin\theta$$</code></td></tr><tr><td align="center">$$\lim_{n\to+\infty}\sum_{i=1}^{n}f[a+\frac{i}{n}(b-a)]\frac{b-a}{n}=\int_{a}^{b}f(x)\mathrm{d}{x}$$</td><td align="center"><code>$$\lim_&#123;n\to+\infty&#125;\sum_&#123;i=1&#125;^&#123;n&#125;f[a+\frac&#123;i&#125;&#123;n&#125;(b-a)]\frac&#123;b-a&#125;&#123;n&#125;=&lt;br&gt;\int_&#123;a&#125;^&#123;b&#125;f(x)\mathrm&#123;d&#125;&#123;x&#125;$$</code></td></tr><tr><td align="center">$$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-{\frac{(x-\mu)^2}{2\sigma^2}}} -\infty&lt; x &lt;+\infty$$</td><td align="center"><code>$$f(x)=\frac&#123;1&#125;&#123;\sqrt&#123;2\pi&#125;\sigma&#125;e^&#123;\frac&#123;(x-\mu)^2&#125;&#123;2\sigma^2&#125;&#125; -\infty&lt; x &lt;+\infty$$</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表·1</title>
      <link href="/2019/01/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B71/"/>
      <url>/2019/01/14/%E7%BA%BF%E6%80%A7%E8%A1%A8%C2%B71/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构复习·1-线性表：顺序表"><a href="#数据结构复习·1-线性表：顺序表" class="headerlink" title="数据结构复习·1 线性表：顺序表"></a>数据结构复习·1 线性表：顺序表</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType *data;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><span id="more"></span> <h3 id="顺序表操控函数"><a href="#顺序表操控函数" class="headerlink" title="顺序表操控函数"></a>顺序表操控函数</h3><h4 id="1-初始化顺序表L"><a href="#1-初始化顺序表L" class="headerlink" title="1.初始化顺序表L"></a>1.初始化顺序表L</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Initlist_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123; <span class="comment">//初始化顺序表L</span></span><br><span class="line">L.data = <span class="keyword">new</span> ElemType[MAXSIZE];<span class="comment">//利用new 来创建动态数组</span></span><br><span class="line"><span class="keyword">if</span>(!L.data) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-在顺序表的指定位置插入数据"><a href="#2-在顺序表的指定位置插入数据" class="headerlink" title="2.在顺序表的指定位置插入数据"></a>2.在顺序表的指定位置插入数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123; <span class="comment">//插入表L</span></span><br><span class="line"><span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L.length==MAXSIZE) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表满</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">L.data[j+<span class="number">1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i<span class="number">-1</span>] = e;</span><br><span class="line">++L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>最好情况：在表尾插入(i=n+1) 元素后移语句不执行 时间复杂度O(1)<br>最坏情况：在表头插入(i=1) 元素后移语句执行n次 时间复杂度O(n)<br>平均情况：移动结点平均次数为$\frac{n}{2}$<br>因此 顺序表插入算法平均时间复杂度为O(n)</p><h4 id="3-在顺序表指定位置删除数据"><a href="#3-在顺序表指定位置删除数据" class="headerlink" title="3.在顺序表指定位置删除数据"></a>3.在顺序表指定位置删除数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i)</span></span>&#123;<span class="comment">//删除表位置i的元素</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">--L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>最好情况：删除表尾元素(i=n) 无须移动元素 时间复杂度O(1)<br>最坏情况：删除表头元素(i=1) 移动除第一个元素外的所有元素 时间复杂度O(n)<br>平均情况：移动结点平均次数为$\frac{n-1}{2}$<br>因此 顺序表删除算法平均时间复杂度为O(n)</p><h4 id="4-遍历整个表的数据元素并输出"><a href="#4-遍历整个表的数据元素并输出" class="headerlink" title="4.遍历整个表的数据元素并输出"></a>4.遍历整个表的数据元素并输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowList</span><span class="params">(SqList L)</span></span>&#123;<span class="comment">//遍历整个顺序表的元素并输出 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-销毁顺序表"><a href="#5-销毁顺序表" class="headerlink" title="5.销毁顺序表"></a>5.销毁顺序表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L.data) <span class="keyword">delete</span>[]L.data;<span class="comment">//释放存储空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 1 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 0 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 0 -2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType *data;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Initlist_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123;<span class="comment">//初始化顺序表L </span></span><br><span class="line">L.data = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line"><span class="keyword">if</span>(!L.data) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span>&#123;<span class="comment">//插入表L </span></span><br><span class="line"><span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L.length==MAXSIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">L.data[j+<span class="number">1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i<span class="number">-1</span>] = e;</span><br><span class="line">++L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i)</span></span>&#123;<span class="comment">//删除表位置i的元素 </span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">&#125; </span><br><span class="line">--L.length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CleanList</span><span class="params">(SqList &amp;L)</span></span>&#123;<span class="comment">//清空表L </span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetLength</span><span class="params">(SqList L)</span></span>&#123;<span class="comment">//求表长 </span></span><br><span class="line"><span class="keyword">return</span> (L.length); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShowList</span><span class="params">(SqList L)</span></span>&#123;<span class="comment">//遍历整个顺序表的元素并输出 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L.data) <span class="keyword">delete</span>[]L.data;<span class="comment">//释放存储空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,len;</span><br><span class="line">ElemType e;</span><br><span class="line">SqList L;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Initlist_Sq</span>(L)) cout&lt;&lt;<span class="string">&quot;顺序表初始化成功&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;顺序表初始化失败&quot;</span>&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输入相应的数字来进行相应的操作&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="type">int</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1.提供一个位置插入一个元素 2.删除提供位置的一个元素 3.求表长 4.获取表内所有的元素 5.清空表 0. exit&quot;</span>&lt;&lt;endl; </span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line"><span class="keyword">switch</span>(c)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入位置的序号和插入的元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;i&gt;&gt;e;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ListInsert_Sq</span>(L,i,e)) cout&lt;&lt;<span class="string">&quot;插入成功&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;插入失败&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入删除元素的位置序号&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ListDelete_Sq</span>(L,i)) cout&lt;&lt;<span class="string">&quot;删除成功&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;删除失败&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">len = <span class="built_in">GetLength</span>(L);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;表的长度为&quot;</span>&lt;&lt;len&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line"><span class="built_in">ShowList</span>(L);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CleanList</span>(L)) cout&lt;&lt;<span class="string">&quot;清空成功&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;清空失败&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">DestroyList</span>(L)) cout&lt;&lt;<span class="string">&quot;顺序表已销毁&quot;</span>&lt;&lt;endl; </span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;顺序表销毁失败&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>下一篇准备写单链表</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下python3.6配置numpy</title>
      <link href="/2019/01/13/Windows%E4%B8%8Bpython3-6%E9%85%8D%E7%BD%AEnumpy/"/>
      <url>/2019/01/13/Windows%E4%B8%8Bpython3-6%E9%85%8D%E7%BD%AEnumpy/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows下使用Pycharm编译器配置Python的Numpy库"><a href="#Windows下使用Pycharm编译器配置Python的Numpy库" class="headerlink" title="Windows下使用Pycharm编译器配置Python的Numpy库"></a>Windows下使用Pycharm编译器配置Python的Numpy库</h2><h3 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h3><pre><code>Windows系统 Python3.6 Pycharm2017.3.2 numpy-1.14.0</code></pre><h3 id="环境配置开始"><a href="#环境配置开始" class="headerlink" title="环境配置开始"></a>环境配置开始</h3><p>下载numpy</p><ul><li><p>1 第一种方法 在cmd里用pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install wheel</span><br><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>如果报错 换第二种方法</p><span id="more"></span> </li><li><p>2 第二种方法 直接下载安装<br>在 <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy">https://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy</a> 下载对应版本号和系统位数的文件<br>并在下载文件的文件夹使用cmd窗口或者git窗口安装下载的文件 eg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 下载的文件名(例如 numpy-1.14.0+mkl-cp36-cp36m-win_amd64.whl)</span><br></pre></td></tr></table></figure><p>该方法问题在于外网文件下载太慢 但我没出现问题</p><h4 id="numpy已经安装完毕了-如果打开cmd窗口进入python命令行-敲入测试命令"><a href="#numpy已经安装完毕了-如果打开cmd窗口进入python命令行-敲入测试命令" class="headerlink" title="numpy已经安装完毕了 如果打开cmd窗口进入python命令行 敲入测试命令"></a>numpy已经安装完毕了 如果打开cmd窗口进入python命令行 敲入测试命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import numpy</span><br><span class="line">&gt;&gt;&gt;numpy.random.rand(4,4)</span><br></pre></td></tr></table></figure><p>会出现4*4的随机数组表示numpy安装成功</p><h4 id="但是！在pycharm中-import-numpy报错！"><a href="#但是！在pycharm中-import-numpy报错！" class="headerlink" title="但是！在pycharm中 import numpy报错！"></a>但是！在pycharm中 import numpy报错！</h4><p>经过长时间排查 发现并不是numpy安装的问题 也不是版本错误的问题<br>而是pycharm没有numpy的模块包<br>需要设置pycharm<br>步骤如下</p><pre><code>  Pycharm的Setting/project/project Interpreter  点击绿色加号 Install Available Packages 在列表中找到numpy点击下方的Install Package</code></pre><p>操作完成后在pycharm里敲入测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">numpy.random.rand(4,4)</span><br></pre></td></tr></table></figure><p>不会对引入numpy报错 并成功输出随机数组<br>至此 Windows下Python安装numpy已经完成</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>安装numpy使我初入门python的我大费周章<br>我刚开始安装的python3.7.0 但是在Pycharm里调用的3.7的exe却出来的是3.6的python<br>我以为numpy是版本不对应 我重新装了python3.6并重新安装了对应版本的numpy发现在pycharm里还是无法调用<br>后来才发现pycharm也应该设置 不知道新建一个项目是不是还要我手动添加numpy才好使<br>感受就是Windows下玩Python真的太累了 还是Linux或者Mac环境下好玩 安装容易指令简单问题也少<br>如果要是安装小型的库的话直接把文件复制到 python3.6/Lib 目录下就行了<br>为什么没说是Lib/site-packages 因为我在添加graphics.py的时候发现放在site-packages文件夹下依旧import提示不存在<br>放在Lib下就不报错了<br>展望自己的学习路程 应该还需要安装Matplotlib的库 不知道会不会再写一篇关于Matplotlib的文章呢</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git上传文件到仓库中</title>
      <link href="/2019/01/12/Git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%BB%93%E5%BA%93%E4%B8%AD/"/>
      <url>/2019/01/12/Git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%BB%93%E5%BA%93%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="用git将项目代码上传到Github中"><a href="#用git将项目代码上传到Github中" class="headerlink" title="用git将项目代码上传到Github中"></a>用git将项目代码上传到Github中</h1><pre><code>下列操作前提：已经建立好Github仓库并绑定好SSH-Key并验证了用户名和密码</code></pre><h2 id="一、第一次提交到新仓库中"><a href="#一、第一次提交到新仓库中" class="headerlink" title="一、第一次提交到新仓库中"></a>一、第一次提交到新仓库中</h2><h3 id="第一步：建立Git本地仓库"><a href="#第一步：建立Git本地仓库" class="headerlink" title="第一步：建立Git本地仓库"></a>第一步：建立Git本地仓库</h3><p>右键项目文件夹 选择 Git Bush Here 执行git命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>文件目录里多了.git的隐藏文件</p><h3 id="第二步：将所有文件添加到仓库中"><a href="#第二步：将所有文件添加到仓库中" class="headerlink" title="第二步：将所有文件添加到仓库中"></a>第二步：将所有文件添加到仓库中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p>如果想添加某个特定的文件，只需把.换成特定的文件名即可</p><span id="more"></span> <h3 id="第三步：将add的文件commit到仓库"><a href="#第三步：将add的文件commit到仓库" class="headerlink" title="第三步：将add的文件commit到仓库"></a>第三步：将add的文件commit到仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;注释&quot;</span></span><br></pre></td></tr></table></figure><p>-m后必须赋注释的值</p><h3 id="第四步：将Github仓库和本地仓库关联"><a href="#第四步：将Github仓库和本地仓库关联" class="headerlink" title="第四步：将Github仓库和本地仓库关联"></a>第四步：将Github仓库和本地仓库关联</h3><p>以本人Github下Data-Structure仓库为例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/shaoyuanhangyes/Data-Structure.git</span><br></pre></td></tr></table></figure><h3 id="第五步：上传文件到Github仓库"><a href="#第五步：上传文件到Github仓库" class="headerlink" title="第五步：上传文件到Github仓库"></a>第五步：上传文件到Github仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="二、将曾提交过-即已存在-git-的新版本提交到仓库中"><a href="#二、将曾提交过-即已存在-git-的新版本提交到仓库中" class="headerlink" title="二、将曾提交过(即已存在.git)的新版本提交到仓库中"></a>二、将曾提交过(即已存在.git)的新版本提交到仓库中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/shaoyuanhangyes/Data-Structure.git</span><br><span class="line">$ git pull --rebase origin master </span><br><span class="line"><span class="comment">#获取远程库与本地同步</span></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="三、所有操作"><a href="#三、所有操作" class="headerlink" title="三、所有操作"></a>三、所有操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;注释&quot;</span></span><br><span class="line">$ git remote add origin https://github.com/shaoyuanhangyes/Data-Structure.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo自定义配置</title>
      <link href="/2019/01/11/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/01/11/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h3><p>添加一个 分类 页面，并在菜单中显示页面链接。</p><ul><li>1.新建一个页面，命名为 categories 。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></li><li>2.编辑刚新建的页面 index.md，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line"><span class="built_in">date</span>: 2018-01-14 20:26:39</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure><span id="more"></span> </li><li>3.在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure>以后更新文章的时候可以在md文件头部加上categories分类名了<h3 id="创建云标签"><a href="#创建云标签" class="headerlink" title="创建云标签"></a>创建云标签</h3>添加一个标签云页面，并在菜单中显示页面链接。</li><li>1.新建一个页面，命名为 tags 。命令如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure></li><li>2.编辑刚新建的页面 index.md，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: tags</span><br><span class="line"><span class="built_in">date</span>: 2018-01-14 21:04:12</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure></li><li>3.在菜单中添加链接。编辑主题的 _config.yml ，添加 tags 到 menu 中，如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3>编辑主题的 _config.yml，新增字段 avatar， 值设置成头像的链接地址。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure>其中，头像的链接地址可以是：<br>完整的互联网 URL，例如：<a href="https://storage.googleapis.com/ygoprodeck.com/pics/10443957.jpg">https://storage.googleapis.com/ygoprodeck.com/pics/10443957.jpg</a><br>站点内的地址，例如：</li></ul><pre><code>/uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录）</code></pre><p>或者</p><pre><code>/images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。</code></pre><h3 id="设置社交Link-amp-Icon"><a href="#设置社交Link-amp-Icon" class="headerlink" title="设置社交Link&amp;Icon"></a>设置社交Link&amp;Icon</h3><p>####Link<br>   编辑主题的 _config.yml，编辑字段 social，然后添加社交站点名称与地址即可。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/shaoyuanhangyes || github</span><br><span class="line">  Google: https://plus.google.com/110657431429268241192 || google</span><br><span class="line">  Weibo: https://weibo.com/u/1349974130 || weibo</span><br></pre></td></tr></table></figure><p>####Icon<br>将要替换的ico文件放在主题的</p><pre><code>source/images目录下</code></pre><p>并编辑主题的_config.yml，编辑字段 favicon</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon.ico</span><br><span class="line">  <span class="comment">#medium: /images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="comment">#apple_touch_icon: /images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="comment">#safari_pinned_tab: /images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure><h3 id="更改代码高亮样式"><a href="#更改代码高亮样式" class="headerlink" title="更改代码高亮样式"></a>更改代码高亮样式</h3><p>编辑主题的 _config.yml 添加字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_theme: night</span><br></pre></td></tr></table></figure><p>为黑底样式（个人偏好）</p><h3 id="关闭页面底部Hexo驱动等标签"><a href="#关闭页面底部Hexo驱动等标签" class="headerlink" title="关闭页面底部Hexo驱动等标签"></a>关闭页面底部Hexo驱动等标签</h3><p>编辑主题的_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">icon: user</span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, will be used `author` from Hexo main config.</span></span><br><span class="line">  copyright:</span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">  powered: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    version: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="设置文章截断（阅读全文）Read-More"><a href="#设置文章截断（阅读全文）Read-More" class="headerlink" title="设置文章截断（阅读全文）Read More"></a>设置文章截断（阅读全文）Read More</h3><p>编辑主题的_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  length: 200</span><br></pre></td></tr></table></figure><h3 id="添加本地搜索栏"><a href="#添加本地搜索栏" class="headerlink" title="添加本地搜索栏"></a>添加本地搜索栏</h3><p>首先在blog的工作目录执行npm安装指令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>其次在Hexo的配置文件 blog/_config.yml中 添加如下指令</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span> <span class="comment">#在public目录的根目录下生成search.xml 文件用于存储网站文章的文字数据</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>最后在主题NexT的配置文件 next/_config.yml</p><p>将local_search的开关打开</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/10/hello-world/"/>
      <url>/2019/01/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Windows下Hexo+Github搭建自己的Blog</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>github账户：<a href="mailto:&#115;&#104;&#x61;&#x6f;&#x79;&#x75;&#x61;&#x6e;&#104;&#97;&#110;&#103;&#121;&#x65;&#115;&#64;&#111;&#x75;&#x74;&#108;&#x6f;&#x6f;&#107;&#x2e;&#99;&#x6f;&#x6d;">&#115;&#104;&#x61;&#x6f;&#x79;&#x75;&#x61;&#x6e;&#104;&#97;&#110;&#103;&#121;&#x65;&#115;&#64;&#111;&#x75;&#x74;&#108;&#x6f;&#x6f;&#107;&#x2e;&#99;&#x6f;&#x6d;</a><br>建立好名字为shaoyuanhangyes.github.io的仓库并开启Github.Pages</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>安装完毕后在cmd里输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>出现版本信息后则说明安装正确</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>安装完毕后在cmd里输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>出现版本信息后则说明安装正确</p><span id="more"></span> <h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git config --global user.name <span class="string">&quot;shaoyuanhangyes&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;shaoyuanhangyes@outlook.com&quot;</span></span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;shaoyuanhangyes@outlook.com&quot;</span>//连续摁三次空格(设置空密码)</span><br></pre></td></tr></table></figure><p>在个人文件夹下出现 .shh文件夹 点击进入<br>用Sublime打开id_rsa.pub文件 复制密钥全部内容<br>再回到Github的Setting的SSH and GPG keys<br>点击New SSH key<br>把复制的信息粘贴到SSH密钥<br>确认即可</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在要安装的文件夹下鼠标右键选择Git Bash Here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>敲完回车可能没有任何提示，请一定要耐心等待<br>安装成功后，可以输入以下命令测试以下Hexo是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><p>如果能看到hexo的版本号信息，就表示安装成功了<br>然后依次输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>这时候在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到本地生成了Hexo博客界面</p><h3 id="配置Hexo到Github"><a href="#配置Hexo到Github" class="headerlink" title="配置Hexo到Github"></a>配置Hexo到Github</h3><p>在hexo文件夹下找到_config.yml文件用sublime打开拖到最底部将deploy设置更改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:shaoyuanhangyes/shaoyuanhangyes.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>保存后在git里敲命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g//generate</span><br><span class="line">$ hexo d//deploy</span><br></pre></td></tr></table></figure><p>若出现以下异常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><p>尝试输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>这时候如果弹出一个对话框，输入在guthub上面的用户名和密码即可<br>这时 访问Github的Page页面就是Hexo搭建的博客页面了</p><h2 id="更新Blog"><a href="#更新Blog" class="headerlink" title="更新Blog"></a>更新Blog</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="配置主题为next"><a href="#配置主题为next" class="headerlink" title="配置主题为next"></a>配置主题为next</h2><h3 id="clone-next文件"><a href="#clone-next文件" class="headerlink" title="clone next文件"></a>clone next文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>将hexo/_config.yml内主题更改为next</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme:next</span><br></pre></td></tr></table></figure><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><h4 id="增加标签-分类-归档菜单-更改主题为Pisces"><a href="#增加标签-分类-归档菜单-更改主题为Pisces" class="headerlink" title="增加标签 分类 归档菜单 更改主题为Pisces"></a>增加标签 分类 归档菜单 更改主题为Pisces</h4><p>文件目录hexo/themes/next下_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scheme: Pisces</span><br><span class="line"><span class="comment">#next主题为Pisces</span></span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure><h4 id="更改个人头像-网页icon-社交软件按钮菜单-代码黑底高亮风格"><a href="#更改个人头像-网页icon-社交软件按钮菜单-代码黑底高亮风格" class="headerlink" title="更改个人头像 网页icon 社交软件按钮菜单 代码黑底高亮风格"></a>更改个人头像 网页icon 社交软件按钮菜单 代码黑底高亮风格</h4><p>将个人头像avatar.jpg放入hexo/themes/next/source/images<br>将网页图标favicon.jpg放入hexo/themes/next/source/images(favicon.ico一直不显示 有可能是我采用的图标像素太大 最好是32x32)<br>文件目录hexo/themes/next下_config.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">avatar: /images/avatar.jpg</span><br><span class="line"></span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon.jpg</span><br><span class="line">  medium: /images/favicon.jpg</span><br><span class="line">  <span class="comment">#apple_touch_icon: /images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="comment">#safari_pinned_tab: /images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br><span class="line"></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/shaoyuanhangyes || github</span><br><span class="line">  E-Mail: mailto:shaoyuanhangoutlook@gmail.com || envelope</span><br><span class="line">  Google: https://plus.google.com/110657431429268241192 || google</span><br><span class="line">  Twitter: https://twitter.com/Ruojhen_syh || twitter</span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  Instagram: https://instagram.com/Ruojhen_syh || instagram</span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line">  Weibo: https://weibo.com/u/1349974130 || weibo</span><br><span class="line"></span><br><span class="line">highlight_theme: night</span><br></pre></td></tr></table></figure><p>更多个性化设置正在摸索未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> Hexo配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
